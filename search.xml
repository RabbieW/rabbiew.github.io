<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AtCoder Beginner Contest A-Ex 题解</title>
    <url>/2022/08/05/ABC261sol/</url>
    <content><![CDATA[<h1 id="a.-intersection">A. Intersection</h1>
<p>两个区间相交的条件：<span class="math inline">\(L_2 &gt; R_1\)</span> 或 <span class="math inline">\(L_1 &gt; R_2\)</span>。</p>
<p>所以答案为 <span class="math inline">\(\max\{L_2 - R_1,L_1 - R_2\}\)</span>。</p>
<h1 id="b.-tournament-result">B. Tournament Result</h1>
<p>答案合法当且仅当 <span class="math inline">\(A_{i,j} = A_{j,i} | j,i \in [1,N] \operatorname{and} j \neq i\)</span>。</p>
<p>直接暴力判断即可，时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h1 id="c.-newfolder1">C. NewFolder(1)</h1>
<p>用 <code>map</code> 记录每个文件名出现的次数，直接 <span class="math inline">\(O(n \log n)\)</span> 求解。</p>
<h1 id="d.-flipping-and-bonus">D. Flipping and Bonus</h1>
<p>考虑 DP。</p>
<p>用 <span class="math inline">\(f(i,j)\)</span> 表示当前枚举到第 <span class="math inline">\(i\)</span> 次掷硬币，计数器显示 <span class="math inline">\(j\)</span> 时最多赚多少钱。</p>
<p>令 <span class="math inline">\(D(C_i) = Y_i\)</span>，</p>
<p>显然转移方程为 <span class="math display">\[
f(0,0) = 0
\]</span></p>
<p><span class="math display">\[
f(i,j) =
\left \{
\begin{aligned}
&amp; f(i-1,j - 1) + X_i + D(j) &amp; &amp;j &gt; 0 \\
&amp; \max \limits_{k=0} ^{i-1} f(i-1,k) &amp; &amp;j=0
\end{aligned} 
\right.
\]</span></p>
<p>最后答案为 <span class="math inline">\(\max \limits _{i=0} ^n \{f(n,i)\}\)</span>。</p>
<p>时间复杂度为 <span class="math inline">\(O(n^2)\)</span>，记得开 <code>long long</code>。</p>
<h1 id="e.-many-operations">E. Many Operations</h1>
<p>对于每一个二进制位可以分别考虑。</p>
<p>对于每一<strong>轮</strong>（很多次）操作，可以 <span class="math inline">\(O(1)\)</span> 计算出这一轮操作前为 <span class="math inline">\(0/1\)</span> ，操作后变为什么：</p>
<p>用 <span class="math inline">\(f(i,0/1)\)</span> 表示第 <span class="math inline">\(i\)</span> 轮操作前为 <span class="math inline">\(0/1\)</span>，操作后变为什么；<span class="math inline">\(g(i,0/1)\)</span> 表示 <span class="math inline">\(0/1\)</span> 经过第 <span class="math inline">\(i\)</span> <strong>种</strong>操作后变为什么。</p>
<p>则 <span class="math inline">\(f(i,0) = g(i,f(i - 1,0))\)</span>，<span class="math inline">\(f(i,1) = g(i,f(i - 1,1))\)</span>。</p>
<p>显然 <span class="math inline">\(f\)</span> 的第一位是可以滚掉的（不滚也行？）。</p>
<p>只需要记录上一轮操作后<strong>最开始</strong>（<span class="math inline">\(C\)</span>）的第 <span class="math inline">\(k\)</span> 位变为什么，即可 <span class="math inline">\(O(1)\)</span> 求出这一轮操作后<strong>最开始</strong>的第 <span class="math inline">\(k\)</span> 位变为什么，并更新答案。</p>
<p>时间复杂度 <span class="math inline">\(O(n \log C)\)</span>。</p>
<p>代码（有点丑）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="type">int</span> t[<span class="number">200010</span>],a[<span class="number">200010</span>],f[<span class="number">3</span>],ans[<span class="number">200010</span>],g[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,t + i,a + i);</span><br><span class="line">    g[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">// g 表示初始值为 0/1 经过某一轮操作后变为什么</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,nw = (c &gt;&gt; i) % <span class="number">2</span>;i &lt;= <span class="number">30</span>;++ i,nw = (c &gt;&gt; i) % <span class="number">2</span>,g[<span class="number">0</span>] = <span class="number">0</span>,g[<span class="number">1</span>] = <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// nw 记录第 i 位现在是什么</span></span><br><span class="line">            <span class="type">int</span> tmp = (a[j] &gt;&gt; i) % <span class="number">2</span>; <span class="comment">// 求 a[j] 的第 i 位</span></span><br><span class="line">            <span class="keyword">if</span> (t[j] == <span class="number">1</span>) f[<span class="number">0</span>] = <span class="number">0</span>,f[<span class="number">1</span>] = (<span class="number">1</span> &amp; tmp);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t[j] == <span class="number">2</span>) f[<span class="number">0</span>] = (<span class="number">0</span> | tmp),f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> f[<span class="number">0</span>] = (<span class="number">0</span> ^ tmp),f[<span class="number">1</span>] = (<span class="number">1</span> ^ tmp);</span><br><span class="line">            <span class="comment">// f[0/1] 即题解中的 g(i,0/1)</span></span><br><span class="line">            g[<span class="number">0</span>] = f[g[<span class="number">0</span>]],g[<span class="number">1</span>] = f[g[<span class="number">1</span>]];</span><br><span class="line">            nw = g[nw];</span><br><span class="line">            ans[j] |= (nw &lt;&lt; i); <span class="comment">// 更新答案</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="f.-sorting-color-balls">F. Sorting Color Balls</h1>
<p>考虑所有数的颜色都不一样，答案即为逆序对个数。</p>
<p>若有数的颜色一样，那么答案就应减去这种颜色的数组成的逆序对个数。</p>
<p>所以只需要统计总逆序对个数和每种颜色的逆序对个数，时间复杂度为 <span class="math inline">\(O(n \log n)\)</span>。</p>
<p>记得开 <code>long long</code>。</p>
<p>可以先把数用 <code>vector</code> 按颜色分类，再求解。</p>
<p>代码（用了树状数组）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> val[<span class="number">300010</span>],c[<span class="number">300010</span>];</span><br><span class="line"><span class="type">int</span> tree[<span class="number">300010</span>];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v[<span class="number">300010</span>];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[x] += y;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        res += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,c + i),v[c[i]].<span class="built_in">push_back</span>(i);<span class="comment">// 将数按颜色分类</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,val + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        ans += <span class="built_in">query</span>(n) - <span class="built_in">query</span>(val[i]),<span class="built_in">upd</span>(val[i],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">upd</span>(val[i],<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; v[i].<span class="built_in">size</span>();j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = v[i][j];</span><br><span class="line">            ans -= <span class="built_in">query</span>(n) - <span class="built_in">query</span>(val[x]);</span><br><span class="line">            <span class="built_in">upd</span>(val[x],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; v[i].<span class="built_in">size</span>();j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = v[i][j];</span><br><span class="line">            <span class="built_in">upd</span>(val[x],<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="g.-replace">G. Replace</h1>
<p>反向思考，题目转化为能否从 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span>，操作全部反过来（字符串 <span class="math inline">\(\to\)</span> 字母）。</p>
<p>令 <span class="math inline">\(S(l,r)\)</span> 表示 <span class="math inline">\(S_lS_{l+1}\dots S_r\)</span>，<span class="math inline">\(len(S)\)</span> 表示 <span class="math inline">\(|S|\)</span>，<span class="math inline">\(n = len(T)\)</span>，<span class="math inline">\(m = ken(S)\)</span>。</p>
<p>考虑区间 DP，<span class="math inline">\(f(i,j,k)\)</span> 表示 <span class="math inline">\(T(i,j)\)</span> 变为字母 <span class="math inline">\(k\)</span> 的最小操作数，<span class="math inline">\(g(i,j,k,l)\)</span> 表示 <span class="math inline">\(T(i,j) \to A_k(1,l)\)</span> 的最小操作数。</p>
<p>我们先用替换后长度减小的操作更新，再用替换后长度不变（<span class="math inline">\(|A_i| = 1\)</span>）的操作更新，来保证多种情况叠加的正确转移。</p>
<p>对于长度为 <span class="math inline">\(1\)</span> 的区间，有 <span class="math inline">\(f(i,j,T_i) = 0\)</span>。</p>
<p>在求 <span class="math inline">\(g(i,j,k,l)\)</span> 时，把 <span class="math inline">\([i,j]\)</span> 划分成 <span class="math inline">\([i,p]\)</span> 和 <span class="math inline">\([p + 1,j]\)</span> 两个区间，则 <span class="math inline">\(S(i,p)\)</span> 应变为 <span class="math inline">\(A_k(1,l - 1)\)</span>，<span class="math inline">\(S(p + 1,j)\)</span> 应变为 <span class="math inline">\(A_k(l,l)\)</span>。转移方程为：<span class="math inline">\(g(i,j,k,l) = \min \limits _{p=i} ^{j-1} \{ g(i,p,k,l - 1) + f(p + 1,j,A_{k,l}) \}\)</span>。</p>
<p>而 <span class="math inline">\(g(i,j,k,len(S))\)</span> 表示把 <span class="math inline">\(T(i,j)\)</span> 变为 <span class="math inline">\(A_k\)</span> 的最小操作数。于是可以更新 <span class="math inline">\(C_k\)</span> 的答案：<span class="math inline">\(f(i,j,C_k) = \min\{ f(i,j,C_k),g(i,j,k,len(k)) + 1 \}\)</span>。</p>
<p>对于区间 <span class="math inline">\([i,j]\)</span>，求出所有 <span class="math inline">\(g(i,j,k,l)\)</span> 后，可以求出 <span class="math inline">\(f(i,j,k)\)</span>。</p>
<p>利用类似 Dijkstra 或 Floyd 的思想，把所有 <span class="math inline">\(len(A_i) = 1\)</span> 的 <span class="math inline">\(A_i\)</span> 和 <span class="math inline">\(C_i\)</span> 连一条权值为 <span class="math inline">\(1\)</span> 的有向边，把所有已知的 <span class="math inline">\(f(i,j,k)\)</span> 放进堆里，再类似求最短路把所有 <span class="math inline">\(f(i,j,k)\)</span> 求出来。</p>
<p>我们发现，在求 <span class="math inline">\(g(i,j,k,l)\)</span> 时，要用到 <span class="math inline">\(g(i,j_0,k,l)\)</span>（<span class="math inline">\(i \leq j_0 \leq j - 1\)</span>）和 <span class="math inline">\(f(i_0,j_0,k)\)</span> （<span class="math inline">\(i &lt; i_0 \leq j \leq n\)</span>）的答案，所以 <span class="math inline">\(i\)</span> 应倒序枚举。</p>
<p>接下来就只剩求答案了。用 <span class="math inline">\(h(i,j)\)</span> 表示 <span class="math inline">\(T(1,i)\)</span> 变为 <span class="math inline">\(S(1,j)\)</span> 的最小操作数。类似 <span class="math inline">\(g\)</span> 的转移方程，有 <span class="math inline">\(h(i,j) = \min \limits _{p=0} ^{i-1} \{ h(p,j - 1) + f(p + 1,i,S_j) \}\)</span>。</p>
<p>答案即为 <span class="math inline">\(h(n,m)\)</span>。</p>
<p>关于时间复杂度，对于区间 <span class="math inline">\([i,j]\)</span>，计算 <span class="math inline">\(g(i,j,k,l)\)</span> 的时间复杂度为 <span class="math inline">\(O(Kn\max(|A_i|))\)</span>，计算 <span class="math inline">\(f(i,j,k)\)</span> 的时间复杂度为 <span class="math inline">\(O((K + 26) \log 26)\)</span>；计算答案的复杂度为 <span class="math inline">\(O(n ^2 m)\)</span>。</p>
<p>总的时间复杂度为 <span class="math inline">\(O(n^3K\max(|A_i|) + n^2(K+26) \log 26 + n^2m)\)</span>，大约为 <span class="math inline">\(50^5 = 312500000\)</span>，常数约为 <span class="math inline">\(\frac{1}{12}\)</span> ~ <span class="math inline">\(\frac{1}{6}\)</span>（据官方题解所述），所以跑的过去。</p>
<p>答案最大为 <span class="math inline">\(32000\)</span>，不用开 <code>long long</code>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pair pair <span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf int(0x3f3f3f3f)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">60</span>],t[<span class="number">60</span>],a[<span class="number">60</span>][<span class="number">60</span>],c[<span class="number">60</span>];</span><br><span class="line"><span class="type">int</span> n,m,len[<span class="number">60</span>],K;</span><br><span class="line"><span class="type">int</span> f[<span class="number">60</span>][<span class="number">60</span>][<span class="number">30</span>],g[<span class="number">60</span>][<span class="number">60</span>][<span class="number">60</span>][<span class="number">60</span>],h[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v[<span class="number">30</span>];</span><br><span class="line">priority_queue &lt;Pair, vector &lt;Pair&gt;, greater &lt;Pair&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(t + <span class="number">1</span>),m = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;K);<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= K;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c%s&quot;</span>,c + i,a[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        len[i] = <span class="built_in">strlen</span>(a[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (len[i] == <span class="number">1</span>) v[a[i][<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>].<span class="built_in">push_back</span>(c[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i;j &lt;= n;j ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= K;k ++)</span><br><span class="line">                g[i][j][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i;j &lt;= n;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j][t[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,t[i] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= K;k ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (len[k] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>;l &lt;= len[k];l ++)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> p = i;p &lt; j;p ++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (g[i][p][k][l - <span class="number">1</span>] == inf || f[p + <span class="number">1</span>][j][a[k][l] - <span class="string">&#x27;a&#x27;</span>] == inf) <span class="keyword">continue</span>;</span><br><span class="line">                            g[i][j][k][l] = <span class="built_in">min</span>(g[i][j][k][l],g[i][p][k][l - <span class="number">1</span>] + f[p + <span class="number">1</span>][j][a[k][l] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">if</span> (g[i][j][k][len[k]] + <span class="number">1</span> &lt; f[i][j][c[k] - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        f[i][j][c[k] - <span class="string">&#x27;a&#x27;</span>] = g[i][j][k][len[k]] + <span class="number">1</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(f[i][j][c[k] - <span class="string">&#x27;a&#x27;</span>],c[k] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> nw = q.<span class="built_in">top</span>().second,res = q.<span class="built_in">top</span>().first;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (res != f[i][j][nw]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>;p &lt; v[nw].<span class="built_in">size</span>();p ++)</span><br><span class="line">                    <span class="keyword">if</span> (res + <span class="number">1</span> &lt; f[i][j][v[nw][p]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        f[i][j][v[nw][p]] = res + <span class="number">1</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(res + <span class="number">1</span>,v[nw][p]));</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= K;k ++) g[i][j][k][<span class="number">1</span>] = f[i][j][a[k][<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    h[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; i;k ++)</span><br><span class="line">                <span class="keyword">if</span> (j) h[i][j] = <span class="built_in">min</span>(h[i][j],h[k][j - <span class="number">1</span>] + f[k + <span class="number">1</span>][i][s[j] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">    <span class="keyword">if</span> (h[n][m] &gt;= inf) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,h[n][m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（终于结束了QAQ）</p>
<h1 id="ex.-game-on-graph">Ex. Game on Graph</h1>
<p>先考虑只判断游戏是否会无限进行下去。</p>
<p>用 <span class="math inline">\(f(i,1/2)\)</span> 表示现在在点 <span class="math inline">\(i\)</span>，该 Arisa / Kasumi 走时游戏是否会无限进行，会则值为 <span class="math inline">\(1\)</span>，否则为 <span class="math inline">\(0\)</span>。</p>
<p>令 <span class="math inline">\(out(i)\)</span> 表示点 <span class="math inline">\(i\)</span> 的出度，</p>
<p>则有</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
f(i,1) &amp;= \max \limits _{j = son(i)} f(j,2) &amp; &amp;out(i) &gt; 0\\
f(i,2) &amp;= \max \limits _{j=son(i)} f(j,1) &amp; &amp;out(i) &gt; 0 \\
f(i,1) &amp;= f(i,2) = 0 &amp; &amp;out(i)=0
\end {aligned}
\right.
\]</span></p>
<p>时间复杂度 <span class="math inline">\(O(M)\)</span> 即可求出解。</p>
<p>考虑图为 DAG 的情况。</p>
<p>用 <span class="math inline">\(g(i,1/2)\)</span> 表示现在在点 <span class="math inline">\(i\)</span>，该 Arisa / Kasumi 走时，在这之后经过的边的边权之和。</p>
<p>令 <span class="math inline">\(dis(i,j)\)</span> 表示点 <span class="math inline">\(i,j\)</span> 之间的距离，</p>
<p>则有</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
g(i,1) &amp;= \min \limits _{j=son(i)} \{ g(j,2) + dis(i,j) \} &amp; &amp;out(i) &gt; 0 \\
g(i,2) &amp;= \max \limits _{j=son(i)} \{ g(j,1) + dis(i,j) \} &amp; &amp;out(i) &gt; 0 \\
g(i,1) &amp;= g(i,2) = 0 &amp; &amp;out(i) = 0
\end{aligned}
\right.
\]</span></p>
<p><span class="math inline">\(g(i,1/2)\)</span> 初始值为 <span class="math inline">\(inf\)</span>，时间复杂度 <span class="math inline">\(O(m)\)</span> 即可求出解。</p>
<p>现在来考虑原题的情况。把上面的 DP 倒过来做，将所有边反向连接，从 <span class="math inline">\(out(i) = 0\)</span> 的点开始，类似 Dijkstra / 拓扑排序的思想更新答案，每次把更新完的点放进堆里，注意 <span class="math inline">\(\min\)</span> 和 <span class="math inline">\(\max\)</span> 的处理。</p>
<p>用 <span class="math inline">\(g(i,1/2) = inf\)</span> 表示游戏会无限进行，发现 <span class="math inline">\(g\)</span> 可以代替 <span class="math inline">\(f\)</span>。</p>
<p>注意，<span class="math inline">\(g(i,2)\)</span> 的优先级应比 <span class="math inline">\(g(i,1)\)</span> 高（自己想一想？），所以在更新 <span class="math inline">\(g(son(i),2)\)</span> 的答案时，应等到所有可以到达 <span class="math inline">\(son(i)\)</span> 的点都更新完 <span class="math inline">\(g(son(i),2)\)</span> 的答案后，再把 <span class="math inline">\(son(i)\)</span> 放进堆里，不然会影响之后算出来的答案。要判断是否所有可以到达 <span class="math inline">\(son(i)\)</span> 的点都更新完 <span class="math inline">\(g(son(i),2)\)</span> 的答案，可以采用这样的策略：每次更新完 <span class="math inline">\(g(son(i),2)\)</span> 的答案后就把 <span class="math inline">\(in(son(i)) \to in(son(i))-1\)</span>，当 <span class="math inline">\(in(son(i))=0\)</span> 时就把 <span class="math inline">\(son(i)\)</span> 入堆，原因显然（结合堆的性质，想一想每个点被放进堆的顺序）。这样做也可以去除环的影响。</p>
<p>最后的答案就是 <span class="math inline">\(g(v,1)\)</span>。</p>
<p>这个 DP 的时间复杂度为 <span class="math inline">\(O(M \log M)\)</span>。</p>
<p>代码（记得开 <code>long long</code>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf (long long)(1e18)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pair pair <span class="string">&lt;long long, pair &lt;long long,long long&gt;</span> &gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll n,m,v;</span><br><span class="line">ll to[<span class="number">200010</span>],val[<span class="number">200010</span>],in[<span class="number">200010</span>],nxt[<span class="number">200010</span>],head[<span class="number">200010</span>],cnt,p[<span class="number">200010</span>];</span><br><span class="line">ll f[<span class="number">200010</span>][<span class="number">3</span>];</span><br><span class="line">priority_queue&lt;Pair, vector &lt;Pair&gt;, greater &lt;Pair&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++ cnt] = y;</span><br><span class="line">    val[cnt] = z;</span><br><span class="line">    nxt[cnt] = head[x];</span><br><span class="line">    in[y] ++;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= n;i ++,p[i] = <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (!in[i]) f[i][<span class="number">1</span>] = f[i][<span class="number">2</span>] = <span class="number">0</span>,q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="built_in">make_pair</span>(i,<span class="number">1</span>))),q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="built_in">make_pair</span>(i,<span class="number">2</span>)));</span><br><span class="line">        <span class="keyword">else</span> f[i][<span class="number">1</span>] = f[i][<span class="number">2</span>] = inf;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ll x = q.<span class="built_in">top</span>().second.first,op = q.<span class="built_in">top</span>().second.second,tmp = q.<span class="built_in">top</span>().first;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">2</span>) tmp = -tmp;</span><br><span class="line">        <span class="keyword">if</span> (f[x][op] != tmp) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (ll i = head[x];i;i = nxt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ll u = to[i],dis = val[i];</span><br><span class="line">                <span class="keyword">if</span> (f[u][<span class="number">1</span>] &gt; tmp + dis) f[u][<span class="number">1</span>] = tmp + dis,q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(f[u][<span class="number">1</span>],<span class="built_in">make_pair</span>(u,<span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (ll i = head[x];i;i = nxt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ll u = to[i],dis = val[i];</span><br><span class="line">                <span class="keyword">if</span> (f[u][<span class="number">2</span>] &lt; tmp + dis || !p[u]) f[u][<span class="number">2</span>] = tmp + dis;</span><br><span class="line">                <span class="keyword">if</span> (!p[u]) p[u] = <span class="number">1</span>;</span><br><span class="line">                in[u] --;</span><br><span class="line">                <span class="keyword">if</span> (!in[u]) q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-f[u][<span class="number">2</span>],<span class="built_in">make_pair</span>(u,<span class="number">2</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;v);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        <span class="built_in">add</span>(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line">    <span class="keyword">if</span> (f[v][<span class="number">1</span>] &gt;= inf) <span class="built_in">printf</span>(<span class="string">&quot;INFINITY\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[v][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>AC 自动机 学习笔记</title>
    <url>/2021/12/07/AC-Automaton/</url>
    <content><![CDATA[<h1 id="前置知识">前置知识</h1>
<ul>
<li>Trie 树</li>
<li>KMP 的思想（也许不用？）</li>
</ul>
<h1 id="ac自动机是什么">AC自动机是什么？</h1>
<p><del>可以帮你自动A题的作弊玩意</del></p>
<blockquote>
<p>AC 自动机是 以 Trie 的结构为基础，结合 KMP 的思想 建立的。 简单来说，建立一个 AC 自动机有两个步骤： 1.基础的 Trie 结构：将所有的模式串构成一棵 Trie。 2.KMP 的思想：对 Trie 树上所有的结点构造失配指针。 然后就可以利用它进行多模式匹配了。 ——OI-Wiki</p>
</blockquote>
<h1 id="模板题">模板题</h1>
<p><a href="https://www.luogu.com.cn/problem/P3808" class="uri">https://www.luogu.com.cn/problem/P3808</a> 给定 <span class="math inline">\(n\)</span> 个模式串 <span class="math inline">\(s_{1,\dots ,n}\)</span> 和一个文本串 <span class="math inline">\(t\)</span>，求有多少个不同的模式串在文本串里出现过。 两个模式串不同当且仅当他们<strong>编号</strong>不同。</p>
<p><span class="math inline">\(1 \leq n \leq 1e6\)</span>，<span class="math inline">\(1 \leq |t| \leq 1e6\)</span>，<span class="math inline">\(1 \leq \sum \limits_{i=1} ^n |s_i| \leq 1e6\)</span>。</p>
<h1 id="算法流程">算法流程</h1>
<p>对于上面这道题，显然我们可以对于每个模式串都判断一次是否在文本串里，时间复杂度 <span class="math inline">\(O(n · |t|)\)</span>。很明显过不了。</p>
<p>这时，我们想到：KMP 算法中，我们利用了<strong>失配指针</strong>减少了不必要的比较，提高了算法效率！这种想法是否也可以用在这一题里呢？</p>
<p>显然是可以的。</p>
<p>考虑两个模式串 <code>abcd</code> 和 <code>bce</code>，文本串为 <code>abce</code>。</p>
<p>对于第一个模式串，当我们判断到文本串 <code>e</code> 这个字符时，发现不对了。如果按照上面的思路，我们需要从头再枚举，判断第二个模式串是否出现。但是，我们观察到，<code>bce</code> 的前两个字符在判断一个模式串时就已经被比较过了，产生了不必要的比较。因此，我们可以用一个失配指针，从第一个模式串的 <code>c</code> 指向第二个模式串的 <code>c</code>。</p>
<p>存储模式串，我们使用 Trie 树。</p>
<p>通过上面的这个例子，我们可以发现：当一个模式串的某一前缀为另一模式串的子串时，可以用上失配指针。</p>
<p>具体地说，若 <span class="math inline">\(S_i(1,k) = S_j(x,x+k-1)\)</span>，就产生一个从 <span class="math inline">\(S_j[x+k-1]\)</span> 到 <span class="math inline">\(S_i[k]\)</span> 的失配指针，因为当 <span class="math inline">\(S_j(1,x+k-1)\)</span> 在文本串中时，<span class="math inline">\(S_j(x,x+k-1)=S_i(1,k)\)</span> 也一定在文本串中，我们无需比较 <span class="math inline">\(S_i\)</span> 的前 <span class="math inline">\(k\)</span> 位。</p>
<p>通过一段分析，我们已经大致得出了算法的思路：存模式串，建失配指针，查找。</p>
<p>接下来就只剩细节问题了。</p>
<h2 id="失配指针的建立">失配指针的建立</h2>
<p>我们使用 BFS 建立失配指针。</p>
<p>来看看这样的一个 Trie 树。</p>
<p>（Trie 树的所有节点都代表了一个字符串，所有边都代表了一个字符）</p>
<p>（图待补充）</p>
<p>很明显，对于第一层的所有节点，失配指针只能指向根节点。</p>
<p>对于第二层及以下的层：</p>
<p>设当前正在考虑的节点为 <span class="math inline">\(i\)</span>，它代表的字符串为 <span class="math inline">\(tree[i]\)</span>，其父亲为 <span class="math inline">\(fa[i]\)</span>，<span class="math inline">\(x\)</span> 的失配指针指向的节点为 <span class="math inline">\(fail[x]\)</span>，连接 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的边代表的字符为 <span class="math inline">\(c(x,y)\)</span>。</p>
<p>根据失配指针的定义，<span class="math inline">\(tree[fa[i]](x_0,x_0+k-1)=tree[fail[fa[i]]](1,k)\)</span>。</p>
<p>若 <span class="math inline">\(i\)</span> 存在： 若 <span class="math inline">\(fail[fa[i]]\)</span> 的一个儿子 <span class="math inline">\(r\)</span> 满足 <span class="math inline">\(c(fa[i],i)=c(fail[fa[i]],r)\)</span>，则 <span class="math inline">\(tree[i](x_0,x_0+k)=tree[r](1,k+1)\)</span>，即 <span class="math inline">\(i\)</span> 的失配指针应指向 <span class="math inline">\(r\)</span>。否则 <span class="math inline">\(i\)</span> 的失配指针指向根节点。同时将 <span class="math inline">\(i\)</span> 入队。</p>
<p>若 <span class="math inline">\(i\)</span> 这个节点不存在，则给 <span class="math inline">\(fa[i]\)</span> 和 <span class="math inline">\(fail[fa[i]]\)</span> 的满足 <span class="math inline">\(c(fa[i],i)=c(fail[fa[i]],r)\)</span> 的儿子 <span class="math inline">\(r\)</span> 连一条边。</p>
<p>这样，经过一次 BFS，失配指针就建立好了。</p>
<h2 id="查找答案">查找答案</h2>
<p>和暴力的思路差不多，在 Trie 树中，一个一个字符查找文本串，如果到了一个模式串的末尾就更新答案，如果匹配不上就跳失配指针。</p>
<h1 id="代码">代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> tr[<span class="number">1000010</span>][<span class="number">30</span>],tg[<span class="number">1000010</span>],fail[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nw = <span class="number">0</span>,len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tr[nw][s[i] - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">            tr[nw][s[i] - <span class="string">&#x27;a&#x27;</span>] = ++ cnt;</span><br><span class="line">        nw = tr[nw][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tg[nw] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i ++)</span><br><span class="line">        <span class="keyword">if</span> (tr[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nw = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i ++)</span><br><span class="line">            <span class="keyword">if</span> (tr[nw][i])</span><br><span class="line">                fail[tr[nw][i]] = tr[fail[nw]][i],q.<span class="built_in">push</span>(tr[nw][i]);</span><br><span class="line">            <span class="keyword">else</span> tr[nw][i] = tr[fail[nw]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nw = <span class="number">0</span>,ans = <span class="number">0</span>,len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        nw = tr[nw][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = nw;j &amp;&amp; tg[j] != <span class="number">-1</span>;j = fail[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ans += tg[j];</span><br><span class="line">            tg[j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        <span class="built_in">add</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="built_in">query</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例题">例题</h1>
<p><a href="https://www.luogu.com.cn/problem/P3808" class="uri">https://www.luogu.com.cn/problem/P3808</a>（模板）<a href="https://www.luogu.com.cn/problem/P3796" class="uri">https://www.luogu.com.cn/problem/P3796</a>（加强版） （待补充）</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1713D 题解</title>
    <url>/2022/08/09/CF1713D/</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p>这是一道交互题。</p>
<p>有一场 <span class="math inline">\(2^n\)</span> 个人参加的淘汰赛，结果已定，你最多使用 $  2^{n + 1} $ 次询问，求出淘汰赛的冠军编号。每次询问的格式为 <code>? a b</code>，表示询问编号为 <span class="math inline">\(a\)</span> 的人和编号为 <span class="math inline">\(b\)</span> 的人哪个赢的次数多，询问的答案为 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(2\)</span> 表示 <span class="math inline">\(a\)</span> 赢的场数等于、大于或小于 <span class="math inline">\(b\)</span>。最后输出 <code>! a</code>，表示淘汰赛的冠军编号。</p>
<p><span class="math inline">\(1 \leq n\leq 17\)</span>。</p>
<h1 id="思路">思路</h1>
<p>先考虑 <span class="math inline">\(n=1\)</span> 的情况，显然直接询问 <code>? 1 2</code> 即可求出答案。</p>
<p>考虑 <span class="math inline">\(n=2\)</span> 的情况，</p>
<p><a href="https://imgtu.com/i/vlK3X8"><img src="https://s1.ax1x.com/2022/08/09/vlK3X8.png" alt="vlK3X8.png" /></a></p>
<p>如图，<span class="math inline">\(1\)</span> 和 <span class="math inline">\(2\)</span> 中一定有一个在第一轮就被淘汰了，<span class="math inline">\(3\)</span> 和 <span class="math inline">\(4\)</span> 也是，第一轮之后剩下的两个一定有一个是冠军，赢的场数一定不同且比被淘汰的人多。被淘汰的人赢的场数是一样的。</p>
<p>我们可以询问 <code>? 1 3</code>，如果得到答案是 <span class="math inline">\(0\)</span>，就得出 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(3\)</span> 都被淘汰了，冠军只可能是 <span class="math inline">\(2\)</span> 或 <span class="math inline">\(4\)</span>，一次询问得出答案；</p>
<p>如果答案是 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(2\)</span>，那么赢的场数较少的那一个人一定不可能是冠军，和赢的场数较多的人在第一轮比赛的人也一定不可能是冠军。因此就只剩两个人有可能是冠军了，一次询问得出答案。</p>
<p>综上，<span class="math inline">\(n=2\)</span> 时，可以通过两次询问确定答案。</p>
<p>考虑 <span class="math inline">\(n &gt; 2\)</span> 的情况。</p>
<p>当 <span class="math inline">\(2 \mid n\)</span> 时，画出来的赛况图（像样例解释那样的）一定可以分为若干个 <span class="math inline">\(n=2\)</span> 的情况。考虑对赛况图进行搜索，用每个点代表<strong>这一层代表的轮</strong>中<strong>这一个位置人的编号</strong>，则根节点的值就是答案，如样例中的图：</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/vjudge_pic/CF1713D/27b478ab2bf58dd616a7ef478d5125bdbaa0416b.png" alt="img" /><figcaption>img</figcaption>
</figure>
<p>对于每个从上往下数奇数层（除最后一层外）上的点，一定可以从最后一层开始用 <span class="math inline">\(2\)</span> 次询问求出这个点的答案，再用这个答案往上求答案。此时总共有 <span class="math inline">\(2^n (\frac {1}{2}+\frac{1}{8}+\frac{1}{32}+\dots+\frac{1}{2^{n-1}}) = 2^{n-1}(1+\frac{1}{4}+\frac{1}{16}+\dots+\frac{1}{2^{n-2}})=2^{n-1}\times \frac{4}{3}(1-\frac{1}{2^n})=\frac{1}{3}\times 2^{n+1}(1-\frac{1}{2^n})\)</span> 次询问，满足题意；</p>
<p>当 <span class="math inline">\(2 \nmid n\)</span> 时，画出来的赛况图一定可以分为若干个 <span class="math inline">\(n=2\)</span> 的情况和一个 <span class="math inline">\(n=1\)</span> 的情况，可以类比 <span class="math inline">\(2 \mid n\)</span> 的情况。此时总共有 <span class="math inline">\(2 ^n (\frac{1}{2}+\frac{1}{8}+\frac{1}{32}+\dots+\frac{1}{2^{n-2}})+1 = 2^n(\frac{1}{2}+\frac{1}{8}+\frac{1}{32}+\dots+\frac{1}{2^{n-2}}+\frac{1}{2^n}) = 2^{n+1}\times \frac{4}{3}(1 - \frac{1}{2^{n+1}})\)</span> 次询问，满足题意。</p>
<h1 id="代码">代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t,n,m;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">600010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[x] = l;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(x &lt;&lt; <span class="number">1</span>,l,(l + r) / <span class="number">2</span>,dep + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,(l + r) / <span class="number">2</span> + <span class="number">1</span>,r,dep + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (dep % <span class="number">2</span> == <span class="number">1</span> - n % <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>,ans[x &lt;&lt; <span class="number">2</span>],ans[(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;&lt; <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;res);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>,ans[x &lt;&lt; <span class="number">2</span> | <span class="number">1</span>],ans[(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;&lt; <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">2</span>) ans[x] = ans[(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> ans[x] = ans[x &lt;&lt; <span class="number">2</span> | <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>,ans[x &lt;&lt; <span class="number">2</span>],ans[(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">2</span>) ans[x] = ans[(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> ans[x] = ans[x &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>,ans[x &lt;&lt; <span class="number">2</span> | <span class="number">1</span>],ans[(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">2</span>) ans[x] = ans[(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> ans[x] = ans[x &lt;&lt; <span class="number">2</span> | <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        m = (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) ans[(<span class="number">1</span> &lt;&lt; n - <span class="number">1</span>) + i] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> res;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>,ans[<span class="number">2</span>],ans[<span class="number">3</span>]);</span><br><span class="line">            <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">2</span>) ans[<span class="number">1</span>] = ans[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">else</span> ans[<span class="number">1</span>] = ans[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;! %d\n&quot;</span>,ans[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>DP 优化</title>
    <url>/2022/02/19/DP%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>upd on 20220405 修了炸了的图和 LaTeX</p>
<p>upd on 20230903 关于数据结构优化 DP，可以看看新写的博客~</p>
<p>题单：<a href="https://www.luogu.com.cn/training/144843" class="uri">https://www.luogu.com.cn/training/144843</a></p>
<p>有的时候，普通的动态规划不能通过题目，需要用到一些数据结构或思想进行优化。</p>
<h1 id="单调队列优化">单调队列优化</h1>
<h2 id="前置知识">前置知识</h2>
<ul>
<li>单调队列</li>
</ul>
<h2 id="主要思想">主要思想</h2>
<p>在 dp 转移的时候，会取上一个阶段最优的答案进行转移得到现在的答案。</p>
<p>而一个一个枚举上一个阶段的所有情况会导致时间复杂度增加，所以我们可以使用单调队列进行优化。</p>
<p>由于单调队列的时间复杂度很小，所以经常被使用。</p>
<h2 id="例题">例题</h2>
<p>CF372C Watching Fireworks is Fun <a href="https://codeforces.com/problemset/problem/372/C" class="uri">https://codeforces.com/problemset/problem/372/C</a></p>
<h3 id="解法">解法</h3>
<p>普通的 dp 解法时间复杂度为 <span class="math inline">\(O(mn^2)\)</span>，显然过不去。</p>
<p>观察转移方程：<span class="math inline">\(f_{i,j}\)</span>​ 表示第 <span class="math inline">\(i\)</span>​ 个烟花，在位置 <span class="math inline">\(j\)</span>​ 的最优答案。</p>
<p><span class="math display">\[
f_{i,j} = \max \limits _{k=1} ^{n} \{f_{i-1,k}+b_i-|a_i-j|\}
\]</span></p>
<p>由于我们枚举了 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span>，所以可以把确定的量提出来：</p>
<p><span class="math display">\[
f_{i,j} = \max \limits _{k=1} ^n \{f_{i-1,k}\}+b_i-|a_i-j|\}
\]</span></p>
<p>时间复杂度降为了 <span class="math inline">\(O(mn)\)</span>，可以过。</p>
<h2 id="单调队列优化多重背包">单调队列优化多重背包</h2>
<p>观察一下朴素多重背包算法的式子：</p>
<p><span class="math display">\[
f[i][j]=\max \limits _{k=0} ^{m[i]} \{ f[i-1][j-k\dot \space w[i]]+k\dot \space v[i] \}
\]</span></p>
<p>其中 <span class="math inline">\(i\)</span> 表示现在枚举到第 <span class="math inline">\(i\)</span> 中物品，<span class="math inline">\(j\)</span> 表示已经用了的背包容量，<span class="math inline">\(k\)</span> 表示第 <span class="math inline">\(i\)</span> 种物品放几个，<span class="math inline">\(w[i]\)</span> 表示体积，<span class="math inline">\(v[i]\)</span>​ 表示价值，<span class="math inline">\(m[i]\)</span> 表示物品个数。</p>
<p>令 <span class="math inline">\(x=j-w[i]\)</span>，可以发现只有在 <span class="math inline">\(j \equiv x \space (mod\space w[i])\)</span>​ 的情况下才能转移。</p>
<p>我们把这个式子改一下：</p>
<p><span class="math display">\[
\begin{aligned}
f[i][j+y\dot \space w[i]] &amp;=\max \limits _{k=1} ^{m[i]} \{ f[i-1][j+(y-k)w[i]]+k\dot \space v[i] \}\\
&amp;= \max \limits _{k=1} ^{m[i]} \{ f[i-1][j+(y-k) \dot \space w[i]] -(y-k)v[i] \}+y\dot \space v[i]
\end{aligned}
\]</span></p>
<p>令 <span class="math inline">\(t=y-k\)</span>​​，则</p>
<p><span class="math display">\[
f[i][j+y\dot \ w[i]]=\max \limits _{t=y-m[i]} ^{y-1} \{ f[i-1][j+t\dot \ w[i]] - t\dot \ v[i] \}+y\dot \ v[i]
\]</span></p>
<p>花括号内的东西可以用单调队列维护。</p>
<p>枚举 <span class="math inline">\(j\)</span>​ 的时间复杂度为 <span class="math inline">\(O(w[i])\)</span>​，枚举 <span class="math inline">\(t\)</span>​ 的时间复杂度为 <span class="math inline">\(O([\tfrac {W}{w[i]}])\)</span>​，</p>
<p>总的时间复杂度就是 <span class="math inline">\(O(n)\times O(w[i]) \times O([\tfrac{W}{w[i]}])=O(nW)\)</span>​。</p>
<h2 id="练习题">练习题</h2>
<p>多重背包板子：Luogu P1776 宝物筛选 <a href="https://www.luogu.com.cn/problem/P1776" class="uri">https://www.luogu.com.cn/problem/P1776</a>（用单调队列做）</p>
<p>Loj #10183 股票交易 <a href="https://loj.ac/p/10183" class="uri">https://loj.ac/p/10183</a></p>
<h1 id="斜率优化">斜率优化</h1>
<h2 id="主要思想-1">主要思想</h2>
<p>有一些题目，可以把转移方程看做直线的方程，把问题转化为求二维平面上选择一些点，最小化直线的截距。</p>
<h2 id="例题-1">例题</h2>
<p>Loj 玩具装箱 <a href="https://loj.ac/p/10188" class="uri">https://loj.ac/p/10188</a></p>
<h3 id="解法-1">解法</h3>
<p>状态转移方程：<span class="math inline">\(f_i\)</span>​​​ 表示以 <span class="math inline">\(i\)</span>​ 为右端点分一段的最小代价，<span class="math inline">\(sum_i\)</span>​ 表示 <span class="math inline">\(c\)</span>​​ 数组的前缀和。</p>
<p><span class="math display">\[
f_{i}=\min \limits _{j=0} ^{i-1} \{ f_j + (i-(j+1) + sum_i-sum_j - L) ^2 \}
\]</span></p>
<p>枚举 <span class="math inline">\(i\)</span>，把确定的提出来：</p>
<p><span class="math display">\[
\begin{aligned}
f_i &amp;= \min \limits _{j=0} ^{i-1} \{ f_j + (i+sum_i - 1-L) ^2 + (j + sum_j) ^2 - 2 (i+sum_i-1-L)(j+sum_j) \}\\
&amp;= \min \limits _{j=0} ^{i-1} \{ f_j+(j+sum_j) ^2 - 2(i + sum_i-1-L)(j + sum_j) \} + (i+sum_i - 1 - L) ^2
\end{aligned}
\]</span></p>
<p>令 <span class="math inline">\(g_i=sum_i+i\)</span>，<span class="math inline">\(L&#39;=L+1\)</span>，则</p>
<p><span class="math display">\[
f_i-(g_i-L&#39;)^2 = \min \{ f_j+g_j\ ^2 - 2(g_i-L&#39;)g_j \}
\]</span></p>
<p>我们把直线的方程 <span class="math inline">\(y=kx+b\)</span>​ 变一下，就可以得到 <span class="math inline">\(b=y-kx\)</span>​。</p>
<p>令</p>
<p><span class="math display">\[
b_i=f_i-(g_i-L&#39;) ^2\\
y_j = f_j+g_j\ ^2\\
k_i = 2(g_i-L&#39;)\\
x_j = g_j
\]</span></p>
<p>我们就成功地把转移方程变成了直线方程：</p>
<p><span class="math display">\[
b_i=\min \limits _{j=0} ^{i-1} \{ y_j - k_i x_j \}
\]</span></p>
<p><span class="math inline">\(k_i\)</span> 表示一条经过点 <span class="math inline">\((x_j,y_j)\)</span>​ 的直线的斜率。</p>
<p>把问题转化为了选择合适的 <span class="math inline">\(j\)</span>，使得 <span class="math inline">\(b_i\)</span>，也就是直线的<strong>截距</strong>最小。</p>
<ul>
<li>怎么求这个点呢？</li>
</ul>
<p>我们画一下图。<img src="https://img-blog.csdnimg.cn/img_convert/1a4c5acab541717529a52b690ea8b9f7.png" alt="qOAi8I.png" /></p>
<p>红色直线的斜率为 <span class="math inline">\(k_i\)</span>。</p>
<p>我们把这条直线向上移，直到碰到一个点：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4b56c25dd85f3cce0c38a0cdc0bbd337.png" alt="qOAl2q.png" /> 碰到的第一个点就是要求的点。</p>
<p>证明：反证法，若继续向上移，<span class="math inline">\(b_i\)</span> 会继续变大，所以后面的都不会比这个点更优。</p>
<p>不难发现可能的答案在下凸壳（黑色线）上。</p>
<p>所以我们不需要枚举每一个点，只需要维护下凸壳上的点即可。</p>
<p>这个点的性质为：它和左边的点连成的直线的斜率 <span class="math inline">\(\leq k_i&lt;\)</span> 它和右边的点连成的直线的斜率。</p>
<p>而本题中，<span class="math inline">\(k_i=2(g_i-L&#39;)\)</span>​​​，<span class="math inline">\(g_i\)</span>​​​ 随着 <span class="math inline">\(i\)</span>​​​ 的增加而增加，所以 <span class="math inline">\(k_i\)</span>​​​​ 是递增的。</p>
<p>所以可以用单调队列维护下凸壳，用一个指针 <span class="math inline">\(ans\)</span> 维护答案。</p>
<p>由于 <span class="math inline">\(k_i\)</span> 单调递增，所以每次 <span class="math inline">\(ans\)</span>​ 的移动次数为均摊 <span class="math inline">\(O(1)\)</span>。</p>
<p>在更新完 <span class="math inline">\(f_i\)</span> 后，我们把 <span class="math inline">\((x_i,y_i)\)</span>​ 也加进去。</p>
<p>这样，就成功地把时间复杂度降到了 <span class="math inline">\(O(n)\)</span>。</p>
<h2 id="总结">总结</h2>
<p>斜率优化的思想就是：把状态转移方程通过转化，把确定的量提到外面来，变成直线方程，使点的坐标代表待定的值，斜率和截距代表确定的值和待求的值，再转化成让截距最小的问题。</p>
<h2 id="练习题-1">练习题</h2>
<h3 id="sdoi2016-征途">[SDOI2016] 征途</h3>
<p><a href="https://loj.ac/p/2035" class="uri">https://loj.ac/p/2035</a> / <a href="https://www.luogu.com.cn/problem/P4072" class="uri">https://www.luogu.com.cn/problem/P4072</a></p>
<p><strong>题解</strong></p>
<p><span class="math display">\[
\begin {aligned}
ans &amp;= m ^2 \frac {\sum (dis[i]-average)^2}{m}\\
&amp;= m\sum(dis[i]-average)^2\\
&amp;= m\sum(dis[i] ^2 + average ^2 - 2dis[i]\dot \ average)\\
&amp;= m\sum(dis[i]^2)-2\dot \ sumdis ^2 + m^2 \dot \ \frac {sumdis^2}{m^2}\\
&amp;= m\sum(dis[i] ^2) - sumdis^2
\end {aligned}
\]</span></p>
<p>所以问题变为了使 <span class="math inline">\(\sum (dis[i]^2)\)</span> 最小。</p>
<p>状态转移：</p>
<p><span class="math display">\[
f[i]=\min \limits _{j=0} ^{i-1} \{ f[j]+(s[i]-s[j])^2 \}\\
\implies f[i] = \min \{ f[j]+s[i] ^2 + s[j] ^2 - 2 s[i]s[j] \}\\
\implies f[i]-s[i] ^2 = \min \{ f[j]+s[j] ^2 - 2s[i]s[j] \}\\
\implies b = \min \{ y-kx \}
\]</span></p>
<p>也就是：</p>
<p><span class="math display">\[
b[i]=f[i]-s[i] ^2\\
y[j]=f[j]+s[j] ^2\\
k[i]=2s[i]\\
x[j]=s[j]
\]</span></p>
<p>后面就和上面那道题一样了。</p>
<h1 id="四边形不等式优化">四边形不等式优化</h1>
<h2 id="四边形不等式">四边形不等式</h2>
<blockquote>
<p>设<span class="math inline">\(w(x,y)\)</span>是定义在整数集合上的二元函数。若对于定义域上的任意整数 <span class="math inline">\(a,b,c,d\)</span>​，其中 <span class="math inline">\(a\leq b \leq c \leq d\)</span>​，都有 <span class="math inline">\(w(a,d)+w(b,c) \geq w(a,c) + w(b,d)\)</span>​ 成立，则称函数 <span class="math inline">\(w\)</span>​​ 满足<strong>四边形不等式</strong>。</p>
<p>若等号永远成立，则称函数 满足<strong>四边形恒等式</strong>。</p>
</blockquote>
<h3 id="定理另一种定义">定理（另一种定义）</h3>
<p>设 <span class="math inline">\(w(x,y)\)</span>​​ 是定义在整数集合上的二元函数。若对于定义域上的任意整数 <span class="math inline">\(a,b\)</span>​，其中 <span class="math inline">\(a &lt;b\)</span>​，</p>
<p>都有 <span class="math inline">\(w(a,b + 1) + w(a+1,b) \geq w(a,b)+w(a+1,b+1)\)</span>​ 成立，则函数 <span class="math inline">\(w\)</span>​ 满足四边形不等式。</p>
<h3 id="定理证明">定理证明</h3>
<p>对于 <span class="math inline">\(a&lt;c\)</span>，有 <span class="math inline">\(w(a,c+1)+w(a+1,c) \geq w(a,c)+w(a+1,c+1)\)</span>；</p>
<p>对于 <span class="math inline">\(a+1 &lt;c\)</span>，有 <span class="math inline">\(w(a+1,c+1)+w(a+2,c) \geq w(a+1,c)+w(a+1,c+1)\)</span>。</p>
<p>两式相加，得到 <span class="math inline">\(w(a,c+1)+w(a+2,c) \geq w(a+1,c)+w(a+2,c+1)\)</span>。</p>
<p>以此类推，对任意的 <span class="math inline">\(a \leq b \leq c\)</span>，有 <span class="math inline">\(w(a,c+1)+w(b,c) \geq w(a,c)+w(b,c+1)\)</span>。</p>
<p>同理，对任意的 <span class="math inline">\(a\leq b \leq c \leq d\)</span>，有 <span class="math inline">\(w(a,d)+w(b,c) \geq w(a,c)+w(b,d)\)</span>。</p>
<h2 id="一维线性-dp-的四边形不等式优化">一维线性 dp 的四边形不等式优化</h2>
<h3 id="决策单调性">决策单调性</h3>
<p>对于形如 <span class="math inline">\(f[i]=\min \limits _{j=0} ^{i-1} \{ f[j] + val(j,i) \}\)</span> 的转移方程，记 <span class="math inline">\(p[i]\)</span> 为令 <span class="math inline">\(f[i]\)</span> 取到最小值的值，即 <span class="math inline">\(f[i]\)</span> 的最优决策。若 <span class="math inline">\(p\)</span> 单调不减，则称 <span class="math inline">\(f\)</span>​ 具有决策单调性。</p>
<h3 id="定理">定理</h3>
<p>在状态转移方程 <span class="math inline">\(f[i]=\min \limits _{j=0} ^{i-1} \{ f[j] + val(j,i) \}\)</span> 中，若函数 <span class="math inline">\(val\)</span> 满足四边形不等式，则 <span class="math inline">\(f\)</span>​ 具有决策单调性。</p>
<h3 id="定理证明-1">定理证明</h3>
<p><span class="math display">\[
f[i]=\min {f[j]+w(j,i)}\\
\implies f[p[i]]+w(p[i],i) \leq f[j]+w(j,i) \space\space\space\space\space (1)\\
j\leq p[i] \leq i \leq i&#39; \\
\implies w(j,i&#39;)+w(p[i],i)\geq w(j,i)+w(p[i],i&#39;)\\
\implies w(j,i&#39;)-w(j,i) \geq w(p[i],i&#39;) - w(p[i],i)\space\space\space\space\space (2)\\
(1)+(2) \implies f[j]+w(j,i&#39;) \geq f[p[i]]+w(p[i],i&#39;)
\]</span></p>
<p>也就是对于 <span class="math inline">\(i&#39;\)</span> 来说，<span class="math inline">\(p[i]\)</span> 比 <span class="math inline">\(j\)</span> 更优，即 <span class="math inline">\(p[i&#39;] \geq p[i]\)</span>。</p>
<h3 id="优化过程">优化过程</h3>
<p>当 <span class="math inline">\(f\)</span> 具有决策单调性时，<span class="math inline">\(p\)</span> 会被分成若干段，使每一段中所有元素的值相同，如下图：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/edb2e1339326ae02e80406e57aa745ba.png" alt="qOkLgx.png" /><figcaption>qOkLgx.png</figcaption>
</figure>
<p>当我们求出了一个新的 <span class="math inline">\(f[i]\)</span>，就可以通过一些操作计算出有哪些 <span class="math inline">\(i&#39;\)</span> 的最优决策是 <span class="math inline">\(p[i]\)</span>。</p>
<p>根据决策单调性，我们一定可以找出一个位置 <span class="math inline">\(pos\)</span>，使得 <span class="math inline">\(pos\)</span> 之前的所有位置目前存储的决策比 <span class="math inline">\(p[i]\)</span> 更优，而 <span class="math inline">\(pos\)</span> 及以后的所有位置目前存储的决策不比 <span class="math inline">\(p[i]\)</span>​ 更优。</p>
<p>我们的目标就变为了找出 <span class="math inline">\(pos\)</span>，并把 <span class="math inline">\(pos\)</span> 及以后的所有位置存储的决策更新为 <span class="math inline">\(p[i]\)</span>。</p>
<p>直接暴力修改显然会超时，还不如不优化。这时，我们可以借助队列。</p>
<p>我们把 <span class="math inline">\(p\)</span>​​​​ 的每一段用一个三元组记录下来：<span class="math inline">\((p_t,l_t,r_t)\)</span>​​​​​，其中 <span class="math inline">\(p\)</span>​​​ 记录的是当前存储的决策，<span class="math inline">\(l\)</span>​​​ 和 <span class="math inline">\(r\)</span>​​​ 分别时这一段的左端点和右端点。设队尾为 <span class="math inline">\((p_0,l_0,r_0)\)</span>​​​。</p>
<p>如果对于 <span class="math inline">\(l_0\)</span>​ 来说，<span class="math inline">\(p[i]\)</span>​ 比 <span class="math inline">\(p_0\)</span>​​​ 更优，则代表我们需要更新这一段存储的决策，直接弹出队尾；</p>
<p>如果对于 <span class="math inline">\(r_0\)</span>​​​ 来说，<span class="math inline">\(p_0\)</span>​​​ 比 <span class="math inline">\(p[i]\)</span>​​​ 更优，则代表我们已经找到了最右的存储决策比 <span class="math inline">\(p[i]\)</span> 更优的点，即 <span class="math inline">\(pos-1\)</span>​，把新的三元组 <span class="math inline">\((p[i],r_0+1,n)\)</span>​​ 插入队尾；</p>
<p>否则，进行二分查找，找到 <span class="math inline">\(pos\)</span>，更新 <span class="math inline">\(r_0\)</span>，把新三元组 <span class="math inline">\((p[i],pos,n)\)</span>​ 插入队尾。</p>
<p>这样，我们就把 <span class="math inline">\(O(n^2)\)</span> 的时间复杂度优化到了 <span class="math inline">\(O(n \log n)\)</span>​。</p>
<h2 id="二维区间dp的四边形不等式优化">二维区间dp的四边形不等式优化</h2>
<p>朴素的转移方程：<span class="math inline">\(f(i,j)=\min \limits _{i \leq k &lt; j} \{ f(i,k)+f(k+1,j)+w(i,j) \}\)</span></p>
<h3 id="定理1">定理1</h3>
<p>在转移方程 <span class="math inline">\(f(i,j)=\min \limits _{i \leq k &lt; j} \{ f(i,k)+f(k+1,j)+w(i,j) \}\)</span>（<span class="math inline">\(f(i,i)=w(i,i)=0\)</span>）中，如果下面两个条件成立：</p>
<ol type="1">
<li><span class="math inline">\(w\)</span> 满足四边形不等式；</li>
<li>对于任意的 <span class="math inline">\(a\leq b \leq c \leq d\)</span>，有 <span class="math inline">\(w(a,d) \geq w(b,c)\)</span>​。</li>
</ol>
<p>那么 <span class="math inline">\(f\)</span> 也满足四边形不等式。</p>
<h3 id="定理2二维决策单调性">定理2（二维决策单调性）</h3>
<p>在转移方程 <span class="math inline">\(f(i,j)=\min \limits _{i \leq k &lt; j} \{ f(i,k)+f(k+1,j)+w(i,j) \}\)</span>（<span class="math inline">\(f(i,i)=w(i,i)=0\)</span>）中，记 <span class="math inline">\(p(i,j)\)</span> 为 <span class="math inline">\(f(i,j)\)</span> 的最优决策。</p>
<p>如果 <span class="math inline">\(f\)</span> 满足四边形不等式，那么对于任意 <span class="math inline">\(i&lt;j\)</span>，有 <span class="math inline">\(p(i,j-1) \leq p(i,j) \leq p(i+1,j)\)</span>。</p>
<hr />
<p>有了定理2，我们就只需要在 <span class="math inline">\(p(l,r-1) \leq k \leq p(l+1,r)\)</span> 的范围内枚举 <span class="math inline">\(k\)</span>，时间复杂度为 <span class="math inline">\(O(n^2)\)</span>。</p>
<h2 id="练习题-2">练习题</h2>
<h3 id="luogu-p1880-石子合并">Luogu P1880 石子合并</h3>
<p><a href="https://www.luogu.com.cn/problem/P1880" class="uri">https://www.luogu.com.cn/problem/P1880</a> <span class="math inline">\(n\leq 5000\)</span>​</p>
<h3 id="luogu-p4767-ioi2000-邮局">Luogu P4767 [IOI2000] 邮局</h3>
<p><a href="https://www.luogu.com.cn/problem/P4767" class="uri">https://www.luogu.com.cn/problem/P4767</a></p>
<p><strong>题解</strong></p>
<p>转移方程：</p>
<p><span class="math display">\[
f[i][j]=\min \limits _{k=0} ^{i-1} \{ f[k][j-1]+w(k+1,i) \}
\]</span></p>
<p>其中<span class="math inline">\(f[i][j]\)</span> 表示前 <span class="math inline">\(i\)</span> 个村庄放了 <span class="math inline">\(j\)</span> 个邮局的最小距离和，<span class="math inline">\(w(i,j)\)</span> 表示第 <span class="math inline">\(i\)</span> ~ <span class="math inline">\(j\)</span> 个村庄中放一个邮局的最小距离和。</p>
<p>显然在一个区间中，邮局要放在最中间的那个村庄那里。</p>
<p><span class="math inline">\(sumx[i]\)</span> 表示前 <span class="math inline">\(i\)</span> 个村庄的坐标和。</p>
<p>对于 <span class="math inline">\(w\)</span>：</p>
<p><span class="math display">\[
w(i,j)=sumx[j]-sumx[(i+j)/2]-sumx[(i+j-1)/2] + sumx[i-1]\\
\implies w(l,r+1)+w(l+1,r)-w(l,r) - w(l+1,r+1)=sumx[(l+r+1)/2]-sumx[(l+r-1)/2]\geq 0\\
\implies w(l,r+1)+w(l+1,r) \geq w(l,r)+w(l+1,r+1)
\]</span></p>
<p>所以 <span class="math inline">\(w\)</span>​ 满足四边形不等式。</p>
<p>又因为显然对于任意的 <span class="math inline">\(a\leq b \leq c \leq d\)</span>，有 <span class="math inline">\(w(a,d) \geq w(b,c)\)</span>，</p>
<p>所以 <span class="math inline">\(f\)</span> 满足四边形不等式，具有二维决策单调性。</p>
<p>时间复杂度为 <span class="math inline">\(O(nV)\)</span>。</p>
<h3 id="spoj-larmy">SPOJ LARMY</h3>
<p><a href="https://www.spoj.com/problems/LARMY/" class="uri">https://www.spoj.com/problems/LARMY/</a></p>
<h1 id="kmp">KMP（？）</h1>
<p>主要是思想。</p>
<p>KMP算法中，通过<strong>记录失配指针</strong>减少枚举的量，优化了时间复杂度。AC自动机就运用了这种思路。</p>
<p>扩展KMP算法中，通过<strong>记录最靠右的已经算出的区间</strong>，让待计算的一部分直接使用之前算出的结果，减少了枚举的量，优化了时间复杂度。Manacher也运用了类似的思路。</p>
<h1 id="数据结构优化">数据结构优化</h1>
<p>在一些情况下，我们可以用数据结构维护决策的候选集合，从而快速执行插入、查找、删除等操作。</p>
<p>主要是把转移的一部分过程用数据结构优化。</p>
<p>upd on 2023/9: 可以看看新写的线段树优化 DP 的博客！</p>
<h2 id="练习题-3">练习题</h2>
<p>（注意选用好写、适用的数据结构）</p>
<h3 id="luogu-p1442-铁球落地">Luogu P1442 铁球落地</h3>
<p><a href="https://www.luogu.com.cn/problem/P1442" class="uri">https://www.luogu.com.cn/problem/P1442</a></p>
<p><strong>题解</strong></p>
<p>线段树优化dp。 先离散化，预处理出每一块木板左边会掉到那块木板，右边会掉到哪里，再从下往上dp。 预处理的时候用线段树优化。</p>
<h3 id="luogu-p1020-导弹拦截">Luogu P1020 导弹拦截</h3>
<p><a href="https://www.luogu.com.cn/problem/P1020" class="uri">https://www.luogu.com.cn/problem/P1020</a></p>
<p><strong>题解</strong></p>
<p>朴素算法的基础上，用树状数组 / 线段树维护最优决策。</p>
<h1 id="其他的dp题">其他的dp题</h1>
<h2 id="cf1627e-not-escaping">CF1627E Not Escaping</h2>
<p><a href="https://codeforces.com/problemset/problem/1627/E" class="uri">https://codeforces.com/problemset/problem/1627/E</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>SA 的 基础 知识</title>
    <url>/2022/08/06/SA/</url>
    <content><![CDATA[<h1 id="sa-的-基础-知识">SA 的 基础 知识</h1>
<p><del>你问我为什么是基础？因为我还没有学会更难的</del></p>
<h2 id="后缀数组">后缀数组</h2>
<h3 id="后缀数组sa是什么">后缀数组（SA）是什么？</h3>
<p>主要指两个数组：<span class="math inline">\(sa\)</span> 和 <span class="math inline">\(rk\)</span>。</p>
<p><span class="math inline">\(sa\)</span> 存储的是<strong>后缀是什么</strong>，<span class="math inline">\(rk\)</span>​ 存储的是<strong>排名是多少</strong>。</p>
<p><span class="math inline">\(sa[i]\)</span> 代表将所有后缀排序后，排名为 <span class="math inline">\(i\)</span> 的后缀；<span class="math inline">\(rk[i]\)</span> 表示从第 <span class="math inline">\(i\)</span> 个字符开始的后缀的排名。</p>
<p>显然，有性质 <span class="math inline">\(sa[rk[i]]=rk[sa[i]]=i\)</span>。​</p>
<p>知道这两个数组中的一个可以 <span class="math inline">\(O(n)\)</span>​ 求出另一个。</p>
<p>下面用 <span class="math inline">\(Sa(i)\)</span>​ 表示从第 <span class="math inline">\(i\)</span>​ 个字符开始的后缀，<span class="math inline">\(Str(i,j)\)</span>​ 表示从第 <span class="math inline">\(i\)</span>​ 个字符开始，长度为 <span class="math inline">\(j\)</span>​​ 的字符串。</p>
<h3 id="维护方法">维护方法</h3>
<p><strong>算法一</strong>：暴力求出每一个后缀，存进一个数组里，<code>sort</code> 排序。由于比较两个字符串的大小是 <span class="math inline">\(O(n)\)</span>​ 的，所以时间复杂度为 <span class="math inline">\(O(n^2 \log n)\)</span>​​​​。</p>
<p><strong>算法二</strong>：</p>
<p>运用倍增的思想，用 <span class="math inline">\(rk_{len}[i]\)</span> 表示的 <span class="math inline">\(Str(i,2 ^{len})\)</span>​排名，</p>
<p>可以用 <span class="math inline">\(rk _{len-1}\)</span> 推出 <span class="math inline">\(rk _{len}\)</span>。</p>
<p>显然，<span class="math inline">\(Str(i,2 ^{len})\)</span>​​​​ 是由 <span class="math inline">\(Str(i,2 ^{len-1})\)</span>​​​​ 和 <span class="math inline">\(Str(i + 2 ^{len - 1},2 ^{len - 1})\)</span>​​​​​ 两个字符串组成的。</p>
<p>根据字符串大小比较的规则，两个长度为 <span class="math inline">\(len\)</span>​ 的字符串的大小为以 <span class="math inline">\(Str(i,2 ^{len - 1})\)</span> 为第一关键字，以 <span class="math inline">\(Str(j,2 ^{len - 1})\)</span> 为第二关键字比较的结果。</p>
<p>因此，按照上述比较规则，将上一次求出的结果进行排序即可得出这一次的结果。</p>
<p>注意，排序后要进行去重，因为两个一样的字符串排名是相等的。</p>
<p>时间复杂度 <span class="math inline">\(O(n \log^2 n)\)</span>。</p>
<p>倍增排序示意图（from OI-Wiki）：</p>
<p><img src="https://oi-wiki.org/string/images/sa2.png" /></p>
<p><strong>算法三</strong>：可以用<a href="https://oi-wiki.org/basic/radix-sort/">基数排序</a>将算法二优化至 <span class="math inline">\(O(n \log n)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">2000010</span>];</span><br><span class="line"><span class="type">int</span> rk[<span class="number">2000010</span>],sa[<span class="number">1000010</span>],num[<span class="number">1000010</span>],tmp[<span class="number">2000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    m = <span class="built_in">max</span>(n,<span class="number">250</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cnt[s[i]] ++,rk[i] = s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rk[i]] --] = i;<span class="comment">// 对每个后缀的第一位计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>;len &lt;= n;len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) num[i] = sa[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cnt[rk[num[i] + len]] ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rk[num[i] + len]] --] = num[i];<span class="comment">// 对第二关键字计数排序</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) num[i] = sa[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cnt[rk[num[i]]] ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rk[num[i]]] --] = num[i];<span class="comment">// 对第一关键字计数排序</span></span><br><span class="line">        <span class="type">int</span> no = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) tmp[i] = rk[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[sa[i]] == tmp[sa[i - <span class="number">1</span>]] &amp;&amp; tmp[sa[i] + len] == tmp[sa[i - <span class="number">1</span>] + len])</span><br><span class="line">                rk[sa[i]] = no;</span><br><span class="line">            <span class="keyword">else</span> no ++,rk[sa[i]] = no;</span><br><span class="line">            <span class="comment">// 计算每个字符串的排名</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sa[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法四</strong>：有时间复杂度 <span class="math inline">\(O(n)\)</span>​​ 的算法​，但是一般来说算法三够用<del>但是我不会</del></p>
<p>模板：<a href="https://loj.ac/p/111">LOJ #111 后缀排序</a> （Luogu P3809）</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">2000010</span>];</span><br><span class="line"><span class="type">int</span> rk[<span class="number">2000010</span>],sa[<span class="number">1000010</span>],num[<span class="number">1000010</span>],tmp[<span class="number">2000010</span>],rn[<span class="number">2000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    m = <span class="built_in">max</span>(n,<span class="number">250</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cnt[s[i]] ++,rk[i] = s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rk[i]] --] = i;<span class="comment">// 对每个后缀的第一位计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>;len &lt; n;len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> no = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// num[no] 表示按第二关键字排好序后，第 no 位对应的第一关键字 x 的 sa[x] 是什么</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= n - len + <span class="number">1</span>;i --) no ++,num[no] = i;</span><br><span class="line">        <span class="comment">// 后缀长度不满 len，就直接把这个后缀扔到前面去（第二关键字为 0）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="keyword">if</span> (sa[i] &gt; len) no ++,num[no] = sa[i] - len;</span><br><span class="line">        <span class="comment">// 剩下的按第二关键字的顺序把第一关键字排好</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) rn[i] = rk[num[i]],cnt[rn[i]] ++;<span class="comment">// 记录 rk[num[i]]，减少不连续访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rn[i]] --] = num[i];<span class="comment">// 对第一关键字计数排序</span></span><br><span class="line">        no = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) tmp[i] = rk[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[sa[i]] == tmp[sa[i - <span class="number">1</span>]] &amp;&amp; tmp[sa[i] + len] == tmp[sa[i - <span class="number">1</span>] + len])</span><br><span class="line">                rk[sa[i]] = no;</span><br><span class="line">            <span class="keyword">else</span> no ++,rk[sa[i]] = no;</span><br><span class="line">            <span class="comment">// 处理 rk</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (no == n) <span class="keyword">break</span>;<span class="comment">// 如果每个后缀的排名都不一样了，意味着排好了（这之后每个后缀的排名都不会变）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sa[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题">例题</h3>
<h4 id="字符串匹配">字符串匹配</h4>
<p>即在主串 <span class="math inline">\(T\)</span> 中寻找模式串 <span class="math inline">\(S\)</span>​。</p>
<p><strong>解法</strong>：</p>
<p>若 <span class="math inline">\(S\)</span> 在 <span class="math inline">\(T\)</span> 中出现，那么它一定是一些后缀的前缀。</p>
<p>由于已经将后缀通过后缀数组有序化，那么前缀为 <span class="math inline">\(S\)</span> 的后缀一定是连续的，直接二分查找即可。时间复杂度 <span class="math inline">\(O(n \log n + \log n)\)</span>，可以求出 <span class="math inline">\(S\)</span> 的每个出现位置。</p>
<hr />
<h4 id="luogu-p4051-jsoi字符加密"><a href="https://www.luogu.com.cn/problem/P4051">Luogu P4051 [JSOI]字符加密</a></h4>
<p>喜欢钻研问题的JS 同学，最近又迷上了对加密方法的思考。一天，他突然想出了一种他认为是终极的加密办法：把需要加密的信息排成一圈，显然，它们有很多种不同的读法。</p>
<p>例如‘JSOI07’，可以读作： JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 把它们按照字符串的大小排序： 07JSOI 7JSOI0 I07JSO JSOI07 OI07JS SOI07J 读出最后一列字符：I0O7SJ，就是加密后的字符串。给定一个字符串 <span class="math inline">\(S\)</span>，求加密后的字符串。</p>
<p>对于 <span class="math inline">\(40 \%\)</span> 的数据，<span class="math inline">\(\left| s \right| \leq 10000\)</span>；</p>
<p>对于所有数据，<span class="math inline">\(\left| s \right| \leq 10^5\)</span>。</p>
<p><strong>解法</strong>：</p>
<p>将字符串复制一遍到后面，就变成了普通的后缀排序问题。</p>
<hr />
<h4 id="luogu-p2870-usaco07decbest-cow-line-g"><a href="https://www.luogu.com.cn/problem/P2870">Luogu P2870 [USACO07DEC]Best Cow Line G</a></h4>
<p>给你一个字符串，每次从首或尾取一个字符组成字符串，问所有能够组成的字符串中字典序最小的一个。</p>
<p><span class="math inline">\(1 \leq N \leq 5\times 10^5\)</span>。</p>
<p><strong>解法</strong>：</p>
<p>考虑暴力做法，每次从头选还是从尾选只需要判断原串小还是反串小，选小的那个更优，<span class="math inline">\(O(n)\)</span> 判断，总时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>考虑优化判断过程。</p>
<h3 id="height-数组"><span class="math inline">\(height\)</span> 数组</h3>
<h4 id="lcp"><span class="math inline">\(lcp\)</span></h4>
<p><span class="math inline">\(lcp(i,j)\)</span> 表示字符串 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span>​ 的最长公共前缀。</p>
<p>下文中用 <span class="math inline">\(lcp(i,j)\)</span> 表示它们的最长公共前缀长度。</p>
<h4 id="定义">定义</h4>
<p><span class="math inline">\(height_i\)</span> 表示 <span class="math inline">\(lcp(sa[i - 1],sa[i])\)</span>。</p>
<h4 id="求-height-数组">求 <span class="math inline">\(height\)</span> 数组</h4>
<p>有一个定理：<span class="math inline">\(height_{rk[i]} \geq height_{rk[i - 1]} - 1\)</span>。</p>
<p>证明：</p>
<p>定义 <span class="math inline">\(Suffix(x)\)</span> 为排名为 <span class="math inline">\(x\)</span> 的后缀，<span class="math inline">\(S(x)\)</span> 表示以第 <span class="math inline">\(x\)</span> 个字符开头的后缀。</p>
<p>设已知 <span class="math inline">\(height_{rk[i - 1]}\)</span>。</p>
<p>若 <span class="math inline">\(height_{rk[i - 1]} \leq 1\)</span>，上式成立；</p>
<p>若 <span class="math inline">\(height_{rk[i - 1]} &gt; 1\)</span>：</p>
<p>设 <span class="math inline">\(Suffix(rk[i - 1])\)</span> 为 <code>aAC</code>，<span class="math inline">\(Suffix(rk[i - 1] - 1)\)</span> 为 <code>aAB</code>，且 <span class="math inline">\(lcp(B,C) = 0\)</span>，<span class="math inline">\(B &lt; C\)</span>，则 <span class="math inline">\(height_{rk[i - 1]} = 1+|A|\)</span>。</p>
<p>而 <span class="math inline">\(S(i)\)</span> 为 <code>AC</code>，<span class="math inline">\(S(sa[rk[i - 1] - 1] + 1)\)</span> 即 <span class="math inline">\(Suffix(rk[i - 1] - 1)\)</span> 在原串中的后一个后缀为 <code>AB</code>，</p>
<p>所以 <span class="math inline">\(S(sa[rk[i - 1] - 1] + 1)\)</span> 肯定在 <span class="math inline">\(S(i)\)</span> 前面。</p>
<p>所以 <span class="math inline">\(lcp(s(i),s(sa[rk[i] - 1])) \geq |A| = height_{rk[i - 1]} - 1\)</span>，即它们的最大公共前缀有一个前缀为 <code>A</code>。</p>
<h4 id="height-数组求-lcp"><span class="math inline">\(height\)</span> 数组求 <span class="math inline">\(lcp\)</span></h4>
<p>有一个定理：<span class="math inline">\(lcp(sa_i,sa_j) = \min \limits _{k=i + 1} ^j \{ height_k \}\)</span>。</p>
<p>证明：感性理解一下，由于后缀已经排好了序，两个后缀的排名差越大，<span class="math inline">\(lcp\)</span> 就越小，</p>
<p><span class="math inline">\(lcp(sa_{i},sa_{i+2}) = \min \{ height_{i + 1},height_{i + 2} \}\)</span>。</p>
<hr />
<p>有了这个定理，两个<strong>子串</strong>求 <span class="math inline">\(lcp\)</span> 就变成了区间求最小值（RMQ）问题。通常用 ST 表解决，或者观察题目性质，或者其他数据结构。</p>
<p><span class="math inline">\(lcp(Str(l_1,r_1),Str(l_2,r_2)) = \min \{ lcp(S(l_1),S(l_2)), (r_1 - l_1 + 1),(r_2 - l_2 + 1) \}\)</span>。</p>
<p>https://oi-wiki.org/string/sa/</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>点分治 &amp; 点分树</title>
    <url>/2023/05/01/%E7%82%B9%E5%88%86%E6%B2%BB%E5%92%8C%E7%82%B9%E5%88%86%E6%A0%91/</url>
    <content><![CDATA[<h1 id="点分治树分治">点分治（树分治）</h1>
<h2 id="点分治是什么">点分治是什么？</h2>
<p>字面上理解，点分治就是“点”和“分治”。它的思路是把一个无根树树上问题拆分成若干个规模更小的无根树上问题和一个有根树（？）上问题。</p>
<h2 id="例题">例题</h2>
<p><a href="https://www.luogu.com.cn/problem/P3806">【模板】点分治1 - 洛谷</a></p>
<p>给定一棵有 <span class="math inline">\(n\)</span> 个节点的树，<span class="math inline">\(m\)</span> 次询问树上距离为 <span class="math inline">\(k\)</span> 的点对是否存在。</p>
<p><span class="math inline">\(1 \le n \le 10^4\)</span>，<span class="math inline">\(1 \leq m \le 100\)</span>，<span class="math inline">\(1 \le k \le 10^7\)</span>，边权 <span class="math inline">\(1 \le w \le 10^4\)</span>。</p>
<h3 id="暴力做法">暴力做法</h3>
<p>每次询问，考虑对于每一个点，用树形 dp 求出经过这个点（包括以这个点为端点）的路径中是否有长度为 <span class="math inline">\(k\)</span> 的，这个判断可以处理出深度后用双指针实现。时间复杂度 <span class="math inline">\(O(mn^2\log n)\)</span>，显然过不去。换根 dp 也因为 <span class="math inline">\(k\)</span> 太大，做不了。</p>
<h3 id="点分治做法">点分治做法</h3>
<p>考虑优化这个暴力，发现对于每个点都做一次树形 dp 很浪费时间。</p>
<p>看一下一棵树上的路径有哪些？</p>
<p>我们可以简单把树上的所有路径分为两类：<strong>经过根节点的</strong> 和 <strong>不经过根节点的</strong>。而暴力做法中，就是把每个点都当成一次根节点，在经过根节点的路径中找长度为 <span class="math inline">\(k\)</span> 的。</p>
<p>一个显然的发现是，不经过根节点的路径肯定在根节点的一个子树中。把根节点删掉，剩下的几个子树就成为了几个规模更小的同样的问题，可以分治解决。时间复杂度为 <span class="math inline">\(O(mn\log n\times 层数)\)</span>。</p>
<p>这个“层数“看起来很难受，如果随便取每次分治的根节点（也就是 <strong>分治中心</strong>）的话，层数可以达到 <span class="math inline">\(O(n)\)</span> 级别，那就优化了个寂寞。我们要想办法把层数减少。</p>
<p>可以想到，每次 <strong>分出来的几个子问题的规模最大的要尽量小</strong>，才能使得时间减少。这让我们想到了<strong>重心</strong>。</p>
<p>树的重心有一条性质，叫做 <strong>以树的重心为根时，所有子树的大小都不超过整棵树大小的一半</strong>。这条性质使得分治的层数变成了 <span class="math inline">\(O(\log n)\)</span> 级别，总的时间复杂度变成了 <span class="math inline">\(O(mn\log^2 n)\)</span>，足以通过这道题。</p>
<h3 id="总结">总结</h3>
<p>至此，我们已经了解了这道题中的点分治做法，可以归纳成下面几步：</p>
<ol type="1">
<li><p>找重心，作为根；</p></li>
<li><p>树形 dp+ 双指针求解每个询问；</p></li>
<li><p>递归求解每个子树。</p></li>
</ol>
<p>而点分治的大多数问题，只是把第 <span class="math inline">\(2\)</span> 步改一改，总体思路都是一样的。</p>
<h3 id="例题代码点分治主体部分">例题代码（点分治主体部分）</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fndroot</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> la)</span><span class="comment">//找根</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    maxsiz[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == la || vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">fndroot</span>(u,x);</span><br><span class="line">        siz[x] += siz[u];</span><br><span class="line">        maxsiz[x] = <span class="built_in">max</span>(maxsiz[x],siz[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxsiz[x] = <span class="built_in">max</span>(maxsiz[x],nsiz - siz[x]);</span><br><span class="line">    <span class="keyword">if</span> (maxsiz[x] &lt; maxsiz[root]) root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">caldis</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> la,<span class="type">int</span> topx)</span><span class="comment">//树形 dp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == la || vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dis[u] = dis[x] + val[i];</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dis[u],topx));</span><br><span class="line">        <span class="built_in">caldis</span>(u,x,topx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//双指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v.<span class="built_in">clear</span>();</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,x));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dis[u] = val[i];</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dis[u],u));</span><br><span class="line">        <span class="built_in">caldis</span>(u,x,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[l].first + v[r].first &lt; que[i]) l ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v[l].first + v[r].first &gt; que[i]) r --;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[l].second == v[r].second)</span><br><span class="line">                &#123;    </span><br><span class="line">                    <span class="keyword">if</span> (v[r].first == v[r - <span class="number">1</span>].first) r --;</span><br><span class="line">                    <span class="keyword">else</span> l ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans[i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//点分治主体</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cal</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        nsiz = siz[u];</span><br><span class="line">        root = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fndroot</span>(u,x);</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="另关于找重心">另：关于找重心</h3>
<p><a href="https://liu-cheng-ao.blog.uoj.ac/blog/2969">一种基于错误的寻找重心方法的点分治的复杂度分析 - 博客 - liu_cheng_ao的博客</a></p>
<h4 id="section"></h4>
<h2 id="练习题目">练习题目</h2>
<p><a href="https://www.luogu.com.cn/problem/P4178">Tree - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2634">[国家集训队]聪聪可可 - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P4149">[IOI2011]Race - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2664">树上游戏 - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3714">[BJOI2017]树的难题 - 洛谷</a></p>
<h1 id="点分树动态点分治">点分树（动态点分治）</h1>
<p>在点分治中，我们依次作为分治中心的点根据访问顺序可以形成一棵树（就像 dfs 树那样），这棵树成为点分树。</p>
<p>这颗树的节点与原树的节点相同，且深度为 <span class="math inline">\(O(\log n)\)</span>，所以许多点分树上的暴力做法的时间复杂度都是正确的。</p>
<p>点分树有一个常用性质：点分树上两点的 LCA 一定在这两点在原树上的路径上。</p>
<p>还有一个注意点：点分树上两点的关系（父子关系之类的）与原树上这两点的关系 <strong>并没有什么关系</strong>。</p>
<h2 id="例题-1">例题</h2>
<p><a href="https://www.luogu.com.cn/problem/P6329">【模板】点分树 | 震波 - 洛谷</a></p>
<p>题面见链接。</p>
<h3 id="做法">做法</h3>
<p>想一想与点 <span class="math inline">\(x\)</span> 距离为 <span class="math inline">\(k\)</span> 的点有哪些。（以下都是在点分树上）</p>
<p>这些点可能在 <span class="math inline">\(x\)</span> 的子树里，可能在 <span class="math inline">\(x\)</span> 的父亲的子树里但不在 <span class="math inline">\(x\)</span> 的子树里，可能在 <span class="math inline">\(x\)</span> 的父亲的父亲的子树里但不在 <span class="math inline">\(x\)</span> 的父亲的子树里……</p>
<p>于是我们想到，可以用一个（<span class="math inline">\(n\)</span> 个？）数据结构存下每个点的子树的节点信息，比如距离 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(k\)</span> 的点的价值和，询问的时候一层一层往父亲跳，同时更新答案就可以了。正好层数那么少，数据结构用动态开点线段树或者什么别的就行了。</p>
<p>但是还有一个问题：跳到 <span class="math inline">\(x\)</span> 的父亲之后，怎么找 <span class="math inline">\(x\)</span> 的子树以外的距离 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(k\)</span> 的点呢？</p>
<p>显然，直接减掉 <span class="math inline">\(x\)</span> 的子树内的就好了。具体的说，用 <span class="math inline">\(dis(x,y)\)</span> 表示点 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的距离，要找的点的权值和就是 <span class="math inline">\(\sum \limits _{u \in fa(x) 的子树 \&amp; dis(x,u)=k} val(u) - \sum \limits _{u \in x 的子树 \&amp; dis(x,u)=k} val(u)\)</span>。</p>
<p>根据上面提到的性质，这个式子可以变为：<span class="math inline">\(\sum \limits _{u \in fa(x) 的子树 \&amp; dis(fa(x),u)=k-dis(x,fa(x))} val(u)-\sum \limits _{u \in x 的子树 \&amp; dis(fa(x),u)=k-dis(x,fa(x))}val(u)\)</span>。</p>
<p>左半部分可以继续用数据结构求出，而右半部分则需要多维护一个叫 <span class="math inline">\(dis(fa(x),u)\)</span> 的东西。根据上面的注意点，<span class="math inline">\(dis(fa(x),u) \neq dis(x,u)+dis(x,fa(x))\)</span>，所以我们必须多用一个数据结构维护这个东西。</p>
<p>至于修改操作，直接一层一层往上跳修改就好了。</p>
<p>时间复杂度为 <span class="math inline">\(O(n\log^2 n+m\log^2 n)\)</span>。</p>
<h2 id="练习题">练习题</h2>
<p><a href="https://www.luogu.com.cn/problem/P3241">[HNOI2015]开店 - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2056">[ZJOI2007] 捉迷藏 - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/SP2666">QTREE4 - Query on a tree IV - 洛谷</a> <a href="https://www.luogu.com.cn/problem/P4115">Qtree4 - 洛谷</a>（卡常题）</p>
<p><a href="https://www.luogu.com.cn/problem/P3345">[ZJOI2015]幻想乡战略游戏 - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P4565">[CTSC2018]暴力写挂 - 洛谷</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树 &amp; 线段树合并优化 DP</title>
    <url>/2023/05/19/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96DP/</url>
    <content><![CDATA[<h1 id="线段树优化-dp">线段树优化 DP</h1>
<p>有一些 DP 的初始化和转移操作可以转化为序列上 / 值域上的区间操作 / 区间查询问题，可以用线段树加速这些操作。</p>
<h2 id="例题-1.-noip1999-普及组-导弹拦截---洛谷">例题 1. <a href="https://www.luogu.com.cn/problem/P1020">[NOIP1999 普及组] 导弹拦截 - 洛谷</a></h2>
<p>求序列的最长不上升 / 最长上升子序列，<span class="math inline">\(1 \le n \le 10^5\)</span>，<span class="math inline">\(1 \le a_i \le 5\times10^4\)</span>。</p>
<hr />
<p>以最长不上升子序列为例。</p>
<p>朴素转移方程：<span class="math inline">\(f_i = \max \limits _{j=0} ^{i - 1} (f_j+1)[a_j \ge a_i \lor j=0 ]\)</span>，<span class="math inline">\(f_i\)</span> 表示以 <span class="math inline">\(a_i\)</span> 结尾的最长子序列，从 <span class="math inline">\(f_0\)</span> 转移表示作为开头。这个 DP 时间复杂度为 <span class="math inline">\(\mathcal{O} (n^2)\)</span>。</p>
<p>考虑优化。枚举到 <span class="math inline">\(k\)</span> 时，如果有 <span class="math inline">\(i,j \le k\)</span>，<span class="math inline">\(a_i = a_j\)</span> 且 <span class="math inline">\(f_i &lt; f_j\)</span>，那么 <span class="math inline">\(f_i\)</span> 显然没用。由于值域很小，可以用 <span class="math inline">\(g_i\)</span> 记录 <span class="math inline">\(\max \limits _{a_j=i} f_j\)</span>，转移方程变为 <span class="math inline">\(f_i = \max \limits _{j=a_i} ^{V} g_j\)</span>，在计算 <span class="math inline">\(f_i\)</span> 的同时更新 <span class="math inline">\(g_{a_i}\)</span> 即可，时间复杂度 <span class="math inline">\(\mathcal{O}(nV)\)</span>。</p>
<p>发现转移时，相当于在 <span class="math inline">\([0,V]\)</span> 中求了一次后缀最大值，可以用数据结构维护区间最大值，更新 <span class="math inline">\(g_{a_i}\)</span> 的操作转化为单点修改，可以用线段树或其他数据结构维护，时间复杂度 <span class="math inline">\(\mathcal{O}(n\log V)\)</span>，可以通过。</p>
<h2 id="例题-2.-problem---1334f---codeforces">例题 2. <a href="https://codeforces.com/problemset/problem/1334/F">Problem - 1334F - Codeforces</a></h2>
<p>翻译：<a href="https://www.luogu.com.cn/problem/CF1334F">Strange Function - 洛谷</a></p>
<p>定义函数 <span class="math inline">\(f\)</span>：<span class="math inline">\(f(x)\)</span> 为所有满足 <span class="math inline">\(x_i&gt;x_{1,2,\cdots,i-1}\)</span> 的 <span class="math inline">\(x_i\)</span> 组成的序列，例如 <span class="math inline">\(f[3,1,2,7,7,3,6,7,8]=[3,7,8]\)</span>。</p>
<p>给出两个序列 <span class="math inline">\(a,b\)</span>，你可以删掉 <span class="math inline">\(a\)</span> 中的一些元素。删掉 <span class="math inline">\(a_i\)</span> 的代价为 <span class="math inline">\(p_i\)</span>。你需要求出最小代价使得 <span class="math inline">\(f(a)=b\)</span> 或给出无解。</p>
<p><span class="math inline">\(1 \le |a| \le 5\times 10^5\)</span>，<span class="math inline">\(b_{i-1} &lt; b_i\)</span>。</p>
<hr />
<p>设计状态 <span class="math inline">\(f_{i,j}\)</span> 表示现在考虑到第 <span class="math inline">\(i\)</span> 个序列 <span class="math inline">\(a\)</span> 中的元素，考虑完元素 <span class="math inline">\(i\)</span> 后新序列的目前最大值（有可能不在目前的新序列中）为 <span class="math inline">\(b_j\)</span>，目前代价最小为 <span class="math inline">\(f_{i,j}\)</span>。</p>
<p>设 <span class="math inline">\(b_{k} \le a_i &lt; b_{k+1}\)</span>。</p>
<p>先假设 <span class="math inline">\(b_j\)</span> 已经 / 将来一定会取到。</p>
<p><span class="math inline">\(p_i&gt;0\)</span> 时，若 <span class="math inline">\(b_{j} \le a_i\)</span> 即 <span class="math inline">\(j \le k\)</span>，为了不改变目前最大值，<span class="math inline">\(a_i\)</span> 必须删除，<span class="math inline">\(f_{i,j} \leftarrow f_{i-1,j}+p_i\)</span>；否则，<span class="math inline">\(a_i\)</span> 删不删都可以，<span class="math inline">\(f_{i,j} \leftarrow f_{i-1,j}\)</span>。</p>
<p><span class="math inline">\(p_i &lt; 0\)</span> 时，<span class="math inline">\(a_i\)</span> 删除更优，<span class="math inline">\(f_{i,j} \leftarrow f_{i-1,j}+p_i\)</span>。</p>
<p>为了保证最后 <span class="math inline">\(b_j\)</span> 可以取到，当 <span class="math inline">\(a_i=b_j\)</span> 时，<span class="math inline">\(a_i\)</span> 不能删除，<span class="math inline">\(f_{i,j} = \min \limits _{v=0} ^j f_{i-1,v} = \min \limits _{v=0} ^{j} f_{i,v} - p_i\)</span>（减 <span class="math inline">\(p_i\)</span> 是因为 <span class="math inline">\(v \le j\)</span>，在上面加上了 <span class="math inline">\(p_i\)</span>，要把 <span class="math inline">\(p_i\)</span> 减回来）。</p>
<p>最终答案即为 <span class="math inline">\(f_{|a|,|b|}\)</span>。</p>
<p>发现上面的几个式子可以转化为区间加、区间查询和单点修改，可以用线段树维护。时间复杂度 <span class="math inline">\(\mathcal{O}(|a|\log |b|)\)</span>。</p>
<p>DP 的主要代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,a + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,p + i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,b + i),pl[b[i]] = i;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>,b + m + <span class="number">1</span>,a[i]) - b;</span><br><span class="line">        <span class="keyword">if</span> (p[i] &gt; <span class="number">0</span>) <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">0</span>,x - <span class="number">1</span>,p[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">0</span>,m,p[i]);</span><br><span class="line">        <span class="keyword">if</span> (pl[a[i]]) <span class="built_in">upd</span>(<span class="number">1</span>,pl[a[i]],<span class="built_in">query</span>(<span class="number">1</span>,pl[a[i]] - <span class="number">1</span>) - p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// add 为区间加，query 为区间查询，upd 为单点修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">query</span>(<span class="number">1</span>,m) &lt; <span class="number">1e15</span>) <span class="built_in">printf</span>(<span class="string">&quot;YES\n%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,m));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题-3.-某位歌姬的故事---洛谷-ex---max-limited-sequence">例题 3. <a href="https://www.luogu.com.cn/problem/P4229">某位歌姬的故事 - 洛谷</a> / <a href="https://atcoder.jp/contests/abc262/tasks/abc262_h">Ex - Max Limited Sequence</a></h2>
<p><del>其中前一道题实际上可以不用线段树优化 DP。</del></p>
<p>构造一个长度为 <span class="math inline">\(n\)</span> 的整数序列 <span class="math inline">\(a\)</span>，要求 <span class="math inline">\(1\le a_i \le A\)</span>，还有 <span class="math inline">\(Q\)</span> 条形如 <span class="math inline">\(\max \{a_{l_i},a_{l_i+1},\cdots,a_{r_i}\}=m_i\)</span> 的限制，问有多少种构造方法。</p>
<p>要求时间复杂度为 <span class="math inline">\(\mathcal{O}(Q\log Q)\)</span>，空间线性。</p>
<hr />
<p>先求出每个位置上的数最大可以填多少，设为 <span class="math inline">\(b\)</span>，顺便判断是否有解：限制 <span class="math inline">\(i\)</span> 可能被满足当且仅当 <span class="math inline">\(\max \limits _{j=l_i} ^{r_i} b_j = m_i\)</span>。</p>
<p>类似<a href="https://www.luogu.com.cn/problem/P3813">[FJOI2017]矩阵填数 - 洛谷</a>这道题，<span class="math inline">\(b_i\)</span> 不同的两个位置的填法互不相关，可以依次求 <span class="math inline">\(b_i=x\)</span> 的所有位置的填法，再乘起来。</p>
<p>把位置、限制按 <span class="math inline">\(b\)</span> 分类，分别存起来，所有 <span class="math inline">\(b_i=x\)</span> 的位置把整个序列分成若干个左闭右开的区间。现在求 <span class="math inline">\(b_i=x\)</span> 的位置的填法数。注意 DP 时一个点不仅代表这一个点填什么，还代表了一个左闭右开的区间，设 <span class="math inline">\(i\)</span> 代表的区间长度为 <span class="math inline">\(len_i\)</span>。</p>
<p>设计状态 <span class="math inline">\(f_{i,j}\)</span> 表示现在填到第 <span class="math inline">\(i\)</span> 个位置，上一个填 <span class="math inline">\(x\)</span> 的位置为 <span class="math inline">\(j\)</span>，填法有 <span class="math inline">\(f_{i,j}\)</span> 种。</p>
<p><strong>一个观察：右端点在 <span class="math inline">\(i\)</span> 代表的区间中的所有限制，只要满足了左端点最靠右的一个，剩下的所有都满足了</strong>。因此只需要考虑左端点最靠右的一个询问，设这个左端点为 <span class="math inline">\(y\)</span>。则 <span class="math inline">\(y\)</span> 到 <span class="math inline">\(i\)</span> 中至少要有一个填 <span class="math inline">\(x\)</span>。</p>
<p>如果 <span class="math inline">\(i\)</span> 不填 <span class="math inline">\(x\)</span>，则 <span class="math inline">\(y\)</span> 到 <span class="math inline">\(i-1\)</span> 中至少有一个 <span class="math inline">\(x\)</span>，所以 <span class="math inline">\(\forall j: 0 \le j &lt; y,\ f_{i,j}\leftarrow 0\)</span>，<span class="math inline">\(\forall j : y \le j &lt; i, \ f_{i,j} \leftarrow f_{i-1,j} \times (x-1)^{len_i}\)</span>。</p>
<p>如果填了 <span class="math inline">\(x\)</span>，则 <span class="math inline">\(f_{i,i}\leftarrow \sum \limits _{j=0} ^{i-1} f_{i-1,j} \times [x^{len_i} - (x-1)^{len_i}]\)</span>。</p>
<p>这里，位置编号是从 <span class="math inline">\(1\)</span> 开始的，<span class="math inline">\(f_{i,0}\)</span> 表示一个 <span class="math inline">\(x\)</span> 都没有。</p>
<p>答案即为 <span class="math inline">\(\sum \limits _{i=0} ^{last} f_{last,i}\)</span>。</p>
<p>考虑优化，发现上面的转移可以转化为区间推平、区间乘、区间查询和单点修改，可以用线段树维护。</p>
<p>在实现时，区间查询的结果也可以用另外一个数组记录，看起来好看一点。</p>
<p>我的代码写得非常丑，好看的正解代码可以在洛谷 / AT 上找 qwq</p>
<p>AT 那道题和这题是一样的，只是没有多测。</p>
<h2 id="其他题目">其他题目</h2>
<p><a href="https://www.luogu.com.cn/problem/P2605" class="uri">https://www.luogu.com.cn/problem/P2605</a></p>
<p>待补充</p>
<h1 id="线段树合并优化-dp">线段树合并优化 DP</h1>
<p>在一些树上 DP 的题目中，需要把父亲和儿子的 DP 信息合并起来，而合并的过程可以转化为线段树合并操作。</p>
<h2 id="例题-1.-pkuwc2018-minimax---洛谷">例题 1. <a href="https://www.luogu.com.cn/problem/P5298">[PKUWC2018] Minimax - 洛谷</a></h2>
<p>小 <span class="math inline">\(C\)</span> 有一棵 <span class="math inline">\(n\)</span> 个结点的有根树，根是 <span class="math inline">\(1\)</span> 号结点，且每个结点最多有两个子结点。</p>
<p>定义结点 <span class="math inline">\(x\)</span> 的权值为：</p>
<p>1.若 <span class="math inline">\(x\)</span> 没有子结点，那么它的权值会在输入里给出，<strong>保证这类点中每个结点的权值互不相同</strong>。</p>
<p>2.若 <span class="math inline">\(x\)</span> 有子结点，那么它的权值有 <span class="math inline">\(p_x\)</span> 的概率是它的子结点的权值的最大值，有 <span class="math inline">\(1-p_x\)</span> 的概率是它的子结点的权值的最小值。</p>
<p>现在小 <span class="math inline">\(C\)</span> 想知道，假设 <span class="math inline">\(1\)</span> 号结点的权值有 <span class="math inline">\(m\)</span> 种可能性，<strong>权值第 <span class="math inline">\(i\)</span> 小</strong>的可能性的权值是 <span class="math inline">\(V_i\)</span>，它的概率为 <span class="math inline">\(D_i(D_i&gt;0)\)</span>，求：</p>
<p><span class="math display">\[
\sum_{i=1}^{m}i\cdot V_i\cdot D_i^2
\]</span></p>
<p>你需要输出答案对 <span class="math inline">\(998244353\)</span> 取模的值。</p>
<hr />
<p>一眼树形 DP。设计状态 <span class="math inline">\(f_{x,i}\)</span> 表示节点 <span class="math inline">\(x\)</span> 取到权值 <span class="math inline">\(i\)</span> 的概率。</p>
<p>若 <span class="math inline">\(x\)</span> 为叶子节点，则 <span class="math inline">\(f_{x,i} \leftarrow [val_x = i] val_x\)</span>；</p>
<p>若 <span class="math inline">\(x\)</span> 只有一个儿子，则 <span class="math inline">\(f_{x,i} \leftarrow f_{son_x,i}\)</span>；</p>
<p>否则，设 <span class="math inline">\(x\)</span> 的两个儿子为 <span class="math inline">\(lson\)</span> 和 <span class="math inline">\(rson\)</span>。</p>
<p><span class="math display">\[
f_{x,i} \leftarrow p_x\sum \limits _{j=1} ^{i-1} f_{lson,j} f_{rson,i} + (1-p_x)\sum \limits _{j=i+1} ^{V} f_{lson,j}f_{rson,i} +p_x\sum \limits _{j=1}^{i-1} f_{lson,i}f_{rson,j}+(1-p_x)\sum\limits_{j=i+1}^V f_{lson,i}f_{rson,j}+f_{lson,i}f_{rson,i}
\]</span></p>
<p>要怎么把线段树合并和这个东西结合起来呢？</p>
<p><span class="math inline">\(x\)</span> 为叶子节点就是单点修改，只有一个儿子就是 <code>rt[x] = rt[sonx]</code>，主要问题是两个儿子的情况。</p>
<p>想一下线段树合并的过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y; <span class="comment">// 其中一个为空就直接返回</span></span><br><span class="line">    <span class="comment">// tree[x] &lt;- tree[y]</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> x; <span class="comment">// 没法往下分就返回</span></span><br><span class="line">    tree[x].ls = <span class="built_in">merge</span>(tree[x].ls,tree[y].ls,l,mid);</span><br><span class="line">    tree[x].rs = <span class="built_in">merge</span>(tree[x].rs,tree[y].rs,mid + <span class="number">1</span>,r); <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设现在 <span class="math inline">\(f\)</span> 数组已经成功地存在了两棵线段树里，要把 <span class="math inline">\(f_{rson}\)</span> 合并到 <span class="math inline">\(f_{lson}\)</span> 上作为 <span class="math inline">\(f_x\)</span>。</p>
<p>现在合并到了区间 <span class="math inline">\([l,r]\)</span>。如果 <span class="math inline">\(f_{rson}\)</span> 在 <span class="math inline">\([l,r]\)</span> 没有值，即 <span class="math inline">\(y\)</span> 为空，那么对于所有 <span class="math inline">\(i \in [l,r]\)</span>，和它的值有关的 <span class="math inline">\(f_{rson}\)</span> 中的值都在这个区间外面，与 <span class="math inline">\(i\)</span> 本身无关，只与 <span class="math inline">\([l,r]\)</span> 有关。具体来说，上面转移方程中，第一项、第二项和最后一项都是 <span class="math inline">\(0\)</span>，第三项变为 <span class="math inline">\(p_x\sum \limits _{j=1} ^{l-1} f_{lson,i}f_{rson,j}\)</span>，第四项变为 <span class="math inline">\((1-p_x)\sum \limits _{j=r+1}^V f_{lson,i}f_{rson,j}\)</span>。发现实际上就是给 <span class="math inline">\([l,r]\)</span> 中的每个位置乘上 <span class="math inline">\(p_x \sum \limits _{j=1}^{l-1}f_{rson,j}+(1-p_x)\sum \limits _{j=r+1}^Vf_{rson,j}\)</span>，变成了区间乘。<span class="math inline">\(x\)</span> 为空时同理，因为 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的关系是对等的。发现要维护一些前缀和和后缀和，在下分时顺便更新之后传下去就行了。</p>
<p>如果 <span class="math inline">\(l=r\)</span>，直接根据转移方程暴力合并就行了。在这道题中，由于点的权值互不相同，所以不会有这种情况。</p>
<p>否则往下继续分就行了。注意下分前先下传 tag，合并完儿子之后再 pushup。</p>
<p>合并的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> xsum,<span class="type">int</span> ysum,<span class="type">int</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x &amp;&amp; !y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="built_in">swap</span>(x,y),<span class="built_in">swap</span>(xsum,ysum);</span><br><span class="line">        tree[x].sum = <span class="number">1ll</span> * tree[x].sum * xsum % mod;</span><br><span class="line">        tree[x].tg = <span class="number">1ll</span> * tree[x].tg * xsum % mod;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x),<span class="built_in">pushdown</span>(y);</span><br><span class="line">    <span class="type">int</span> tmpx = tree[tree[x].ls].sum,tmpy = tree[tree[y].ls].sum;</span><br><span class="line">    tree[x].ls = <span class="built_in">merge</span>(tree[x].ls,tree[y].ls,l,mid,(xsum + <span class="number">1ll</span> * tree[tree[y].rs].sum * (<span class="number">1</span> - P + mod) % mod) % mod,(ysum + <span class="number">1ll</span> * tree[tree[x].rs].sum * (<span class="number">1</span> - P + mod) % mod) % mod,P);</span><br><span class="line">    tree[x].rs = <span class="built_in">merge</span>(tree[x].rs,tree[y].rs,mid + <span class="number">1</span>,r,(xsum + <span class="number">1ll</span> * tmpy * P % mod) % mod,(ysum + <span class="number">1ll</span> * tmpx * P % mod) % mod,P);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下的都是动态开点线段树板子。</p>
<p>最后查询的时候，就是在根节点的线段树上单点查找。</p>
<h2 id="例题-2.-noi2020-命运---洛谷">例题 2. <a href="https://www.luogu.com.cn/problem/P6773">[NOI2020] 命运 - 洛谷</a></h2>
<p>给定一棵树 <span class="math inline">\(T = (V, E)\)</span> 和点对集合 <span class="math inline">\(\mathcal Q \subseteq V \times V\)</span> ，满足对于所有 <span class="math inline">\((u, v) \in \mathcal Q\)</span>，都有 <span class="math inline">\(u \neq v\)</span>，并且 <span class="math inline">\(u\)</span> 是 <span class="math inline">\(v\)</span> 在树 <span class="math inline">\(T\)</span> 上的祖先。其中 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(E\)</span> 分别代表树 <span class="math inline">\(T\)</span> 的结点集和边集。求有多少个不同的函数 <span class="math inline">\(f\)</span> : <span class="math inline">\(E \to \{0, 1\}\)</span>（将每条边 <span class="math inline">\(e \in E\)</span> 的 <span class="math inline">\(f(e)\)</span> 值置为 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span>），满足对于任何 <span class="math inline">\((u, v) \in \mathcal Q\)</span>，都存在 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 路径上的一条边 <span class="math inline">\(e\)</span> 使得 <span class="math inline">\(f(e) = 1\)</span>。由于答案可能非常大，你只需要输出结果对 <span class="math inline">\(998,244,353\)</span>（一个素数）取模的结果。</p>
<p><span class="math inline">\(1 \le n \le 5 \times 10 ^5\)</span>，<span class="math inline">\(1 \le m \le 5 \times 10^5\)</span>。</p>
<hr />
<p>这道题和前面讲的 某位歌姬的故事 这道题很像，这道题就是把那道题的部分分做法搬到了树上。</p>
<p>这道题也有<strong>一个观察：对于下端点相同的限制，上端点最深的满足，则这些限制都满足</strong>。</p>
<p>设计状态 <span class="math inline">\(f_{i,j}\)</span> 表示在节点 <span class="math inline">\(i\)</span> 的子树中，还未被满足的限制中上端点最深的深度为 <span class="math inline">\(j\)</span>，方案数为 <span class="math inline">\(f_{i,j}\)</span>。根节点深度为 <span class="math inline">\(1\)</span>。</p>
<p>转移方程：</p>
<p><span class="math display">\[
f_{x,i} \leftarrow \sum \limits _{j=0} ^{i - 1} f_{x,i}f_{son,j}+\sum\limits _{j=0} ^{i-1} f_{x,j}f_{son,i}+f_{x,i}f_{xon,i}+f_{x,i}\sum \limits _{j=0}^{dep_x}f_{son,j}
\]</span></p>
<p>前面三项是 <span class="math inline">\(edge(x,son)=0\)</span>，最后一项是填 <span class="math inline">\(1\)</span>。</p>
<p>类似上一道题，这题也可以用线段树合并优化转移。但要注意，这道题里 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(son\)</span> 的关系并不对等，要分别讨论左边为空和右边为空的情况。</p>
<p>合并代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pre,<span class="type">int</span> sonpre,<span class="type">int</span> sondep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    printf(&quot;%d %d %d %d %d %d %d\n&quot;,x,y,l,r,pre,sonpre,sondep);</span></span><br><span class="line">    <span class="keyword">if</span> (!x &amp;&amp; !y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">        tree[x].sum = <span class="number">1ll</span> * tree[x].sum * pre % mod;</span><br><span class="line"><span class="comment">//        printf(&quot;sum %d\n&quot;,tree[x].sum);</span></span><br><span class="line">        tree[x].tg = <span class="number">1ll</span> * tree[x].tg * pre % mod;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!y)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[x].sum = <span class="number">1ll</span> * tree[x].sum * (sondep + sonpre) % mod;</span><br><span class="line">        tree[x].tg = <span class="number">1ll</span> * tree[x].tg * (sondep + sonpre) % mod;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (l == r)</span><br><span class="line">     &#123;</span><br><span class="line">        tree[x].sum = (<span class="number">1ll</span> * tree[x].sum * ((sondep + sonpre) % mod + tree[y].sum) % mod + <span class="number">1ll</span> * tree[y].sum * pre % mod) % mod;</span><br><span class="line"><span class="comment">//        printf(&quot;sum %d\n&quot;,tree[x].sum);</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x),<span class="built_in">pushdown</span>(y);</span><br><span class="line">    <span class="type">int</span> newpre = (pre + tree[tree[x].ls].sum) % mod;</span><br><span class="line">    <span class="type">int</span> newsonpre = (sonpre + tree[tree[y].ls].sum) % mod;</span><br><span class="line">    tree[x].ls = <span class="built_in">merge</span>(tree[x].ls,tree[y].ls,l,mid,pre,sonpre,sondep);</span><br><span class="line">    tree[x].rs = <span class="built_in">merge</span>(tree[x].rs,tree[y].rs,mid + <span class="number">1</span>,r,newpre,newsonpre,sondep);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>遇到整个区间转移的问题，可以往线段树优化上考虑。（？）</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>DP</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
