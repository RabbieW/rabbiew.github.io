<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AtCoder Beginner Contest A-Ex 题解</title>
    <url>/2022/08/05/ABC261sol/</url>
    <content><![CDATA[<h1 id="A-Intersection"><a href="#A-Intersection" class="headerlink" title="A. Intersection"></a>A. Intersection</h1><p>两个区间相交的条件：$L_2 &gt; R_1$ 或 $L_1 &gt; R_2$。</p>
<p>所以答案为 $\max{L_2 - R_1,L_1 - R_2}$。</p>
<h1 id="B-Tournament-Result"><a href="#B-Tournament-Result" class="headerlink" title="B. Tournament Result"></a>B. Tournament Result</h1><p>答案合法当且仅当 $A_{i,j} &#x3D; A_{j,i} | j,i \in [1,N] \operatorname{and} j \neq i$。</p>
<p>直接暴力判断即可，时间复杂度 $O(n^2)$。</p>
<h1 id="C-NewFolder-1"><a href="#C-NewFolder-1" class="headerlink" title="C. NewFolder(1)"></a>C. NewFolder(1)</h1><p>用 <code>map</code> 记录每个文件名出现的次数，直接 $O(n \log n)$ 求解。</p>
<h1 id="D-Flipping-and-Bonus"><a href="#D-Flipping-and-Bonus" class="headerlink" title="D. Flipping and Bonus"></a>D. Flipping and Bonus</h1><p>考虑 DP。</p>
<p>用 $f(i,j)$ 表示当前枚举到第 $i$ 次掷硬币，计数器显示 $j$ 时最多赚多少钱。</p>
<p>令 $D(C_i) &#x3D; Y_i$，</p>
<p>显然转移方程为<br>$$<br>f(0,0) &#x3D; 0<br>$$</p>
<p>$$<br>f(i,j) &#x3D; \begin{cases} {\begin{aligned} &amp; f(i-1,j - 1) + X_i + D(j) &amp; &amp;j &gt; 0 \newline &amp; \max \limits_{k&#x3D;0} ^{i-1} f(i-1,k) &amp; &amp;j&#x3D;0 \end{aligned} } \end{cases}<br>$$</p>
<p>最后答案为 $\max \limits _{i&#x3D;0} ^n {f(n,i)}$。</p>
<p>时间复杂度为 $O(n^2)$，记得开 <code>long long</code>。</p>
<h1 id="E-Many-Operations"><a href="#E-Many-Operations" class="headerlink" title="E. Many Operations"></a>E. Many Operations</h1><p>对于每一个二进制位可以分别考虑。</p>
<p>对于每一<strong>轮</strong>（很多次）操作，可以 $O(1)$ 计算出这一轮操作前为 $0&#x2F;1$ ，操作后变为什么：</p>
<p>用 $f(i,0&#x2F;1)$ 表示第 $i$ 轮操作前为 $0&#x2F;1$，操作后变为什么；$g(i,0&#x2F;1)$ 表示 $0&#x2F;1$ 经过第 $i$ <strong>种</strong>操作后变为什么。</p>
<p>则 $f(i,0) &#x3D; g(i,f(i - 1,0))$，$f(i,1) &#x3D; g(i,f(i - 1,1))$。</p>
<p>显然 $f$ 的第一位是可以滚掉的（不滚也行？）。</p>
<p>只需要记录上一轮操作后<strong>最开始</strong>（$C$）的第 $k$ 位变为什么，即可 $O(1)$ 求出这一轮操作后<strong>最开始</strong>的第 $k$ 位变为什么，并更新答案。</p>
<p>时间复杂度 $O(n \log C)$。</p>
<p>代码（有点丑）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="type">int</span> t[<span class="number">200010</span>],a[<span class="number">200010</span>],f[<span class="number">3</span>],ans[<span class="number">200010</span>],g[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,t + i,a + i);</span><br><span class="line">    g[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">// g 表示初始值为 0/1 经过某一轮操作后变为什么</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,nw = (c &gt;&gt; i) % <span class="number">2</span>;i &lt;= <span class="number">30</span>;++ i,nw = (c &gt;&gt; i) % <span class="number">2</span>,g[<span class="number">0</span>] = <span class="number">0</span>,g[<span class="number">1</span>] = <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// nw 记录第 i 位现在是什么</span></span><br><span class="line">            <span class="type">int</span> tmp = (a[j] &gt;&gt; i) % <span class="number">2</span>; <span class="comment">// 求 a[j] 的第 i 位</span></span><br><span class="line">            <span class="keyword">if</span> (t[j] == <span class="number">1</span>) f[<span class="number">0</span>] = <span class="number">0</span>,f[<span class="number">1</span>] = (<span class="number">1</span> &amp; tmp);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t[j] == <span class="number">2</span>) f[<span class="number">0</span>] = (<span class="number">0</span> | tmp),f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> f[<span class="number">0</span>] = (<span class="number">0</span> ^ tmp),f[<span class="number">1</span>] = (<span class="number">1</span> ^ tmp);</span><br><span class="line">            <span class="comment">// f[0/1] 即题解中的 g(i,0/1)</span></span><br><span class="line">            g[<span class="number">0</span>] = f[g[<span class="number">0</span>]],g[<span class="number">1</span>] = f[g[<span class="number">1</span>]];</span><br><span class="line">            nw = g[nw];</span><br><span class="line">            ans[j] |= (nw &lt;&lt; i); <span class="comment">// 更新答案</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="F-Sorting-Color-Balls"><a href="#F-Sorting-Color-Balls" class="headerlink" title="F. Sorting Color Balls"></a>F. Sorting Color Balls</h1><p>考虑所有数的颜色都不一样，答案即为逆序对个数。</p>
<p>若有数的颜色一样，那么答案就应减去这种颜色的数组成的逆序对个数。</p>
<p>所以只需要统计总逆序对个数和每种颜色的逆序对个数，时间复杂度为 $O(n \log n)$。</p>
<p>记得开 <code>long long</code>。</p>
<p>可以先把数用 <code>vector</code> 按颜色分类，再求解。</p>
<p>代码（用了树状数组）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> val[<span class="number">300010</span>],c[<span class="number">300010</span>];</span><br><span class="line"><span class="type">int</span> tree[<span class="number">300010</span>];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v[<span class="number">300010</span>];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[x] += y;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        res += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,c + i),v[c[i]].<span class="built_in">push_back</span>(i);<span class="comment">// 将数按颜色分类</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,val + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        ans += <span class="built_in">query</span>(n) - <span class="built_in">query</span>(val[i]),<span class="built_in">upd</span>(val[i],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">upd</span>(val[i],<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; v[i].<span class="built_in">size</span>();j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = v[i][j];</span><br><span class="line">            ans -= <span class="built_in">query</span>(n) - <span class="built_in">query</span>(val[x]);</span><br><span class="line">            <span class="built_in">upd</span>(val[x],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; v[i].<span class="built_in">size</span>();j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = v[i][j];</span><br><span class="line">            <span class="built_in">upd</span>(val[x],<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="G-Replace"><a href="#G-Replace" class="headerlink" title="G. Replace"></a>G. Replace</h1><p>反向思考，题目转化为能否从 $T$ 到 $S$，操作全部反过来（字符串 $\to$ 字母）。</p>
<p>令 $S(l,r)$ 表示 $S_lS_{l+1}\dots S_r$，$len(S)$ 表示 $|S|$，$n &#x3D; len(T)$，$m &#x3D; ken(S)$。</p>
<p>考虑区间 DP，$f(i,j,k)$ 表示 $T(i,j)$ 变为字母 $k$ 的最小操作数，$g(i,j,k,l)$ 表示 $T(i,j) \to A_k(1,l)$ 的最小操作数。</p>
<p>我们先用替换后长度减小的操作更新，再用替换后长度不变（$|A_i| &#x3D; 1$）的操作更新，来保证多种情况叠加的正确转移。</p>
<p>对于长度为 $1$ 的区间，有 $f(i,j,T_i) &#x3D; 0$。</p>
<p>在求 $g(i,j,k,l)$ 时，把 $[i,j]$ 划分成 $[i,p]$ 和 $[p + 1,j]$ 两个区间，则 $S(i,p)$ 应变为 $A_k(1,l - 1)$，$S(p + 1,j)$ 应变为 $A_k(l,l)$。转移方程为：$g(i,j,k,l) &#x3D; \min \limits <em>{p&#x3D;i} ^{j-1} { ( g(i,p,k,l - 1) + f(p + 1,j, A</em>{k,l } ) ) } $。</p>
<p>而 $g(i,j,k,len(S))$ 表示把 $T(i,j)$ 变为 $A_k$ 的最小操作数。于是可以更新 $C_k$ 的答案：$f(i,j,C_k) &#x3D; \min{ f(i,j,C_k),g(i,j,k,len(k)) + 1 }$。</p>
<p>对于区间 $[i,j]$，求出所有 $g(i,j,k,l)$ 后，可以求出 $f(i,j,k)$。</p>
<p>利用类似 Dijkstra 或 Floyd 的思想，把所有 $len(A_i) &#x3D; 1$ 的 $A_i$ 和 $C_i$ 连一条权值为 $1$ 的有向边，把所有已知的 $f(i,j,k)$ 放进堆里，再类似求最短路把所有 $f(i,j,k)$ 求出来。</p>
<p>我们发现，在求 $g(i,j,k,l)$ 时，要用到 $g(i,j_0,k,l)$（$i \leq j_0 \leq j - 1$）和 $f(i_0,j_0,k)$ （$i &lt; i_0 \leq j \leq n$）的答案，所以 $i$ 应倒序枚举。</p>
<p>接下来就只剩求答案了。用 $h(i,j)$ 表示 $T(1,i)$ 变为 $S(1,j)$ 的最小操作数。类似 $g$ 的转移方程，有 $h(i,j) &#x3D; \min \limits _{p&#x3D;0} ^{i-1} { h(p,j - 1) + f(p + 1,i,S_j) }$。</p>
<p>答案即为 $h(n,m)$。</p>
<p>关于时间复杂度，对于区间 $[i,j]$，计算 $g(i,j,k,l)$ 的时间复杂度为 $O(Kn\max(|A_i|))$，计算 $f(i,j,k)$ 的时间复杂度为 $O((K + 26) \log 26)$；计算答案的复杂度为 $O(n ^2 m)$。</p>
<p>总的时间复杂度为 $O(n^3K\max(|A_i|) + n^2(K+26) \log 26 + n^2m)$，大约为 $50^5 &#x3D; 312500000$，常数约为 $\frac{1}{12}$ ~ $\frac{1}{6}$（据官方题解所述），所以跑的过去。</p>
<p>答案最大为 $32000$，不用开 <code>long long</code>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pair pair <span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf int(0x3f3f3f3f)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">60</span>],t[<span class="number">60</span>],a[<span class="number">60</span>][<span class="number">60</span>],c[<span class="number">60</span>];</span><br><span class="line"><span class="type">int</span> n,m,len[<span class="number">60</span>],K;</span><br><span class="line"><span class="type">int</span> f[<span class="number">60</span>][<span class="number">60</span>][<span class="number">30</span>],g[<span class="number">60</span>][<span class="number">60</span>][<span class="number">60</span>][<span class="number">60</span>],h[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v[<span class="number">30</span>];</span><br><span class="line">priority_queue &lt;Pair, vector &lt;Pair&gt;, greater &lt;Pair&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(t + <span class="number">1</span>),m = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;K);<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= K;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c%s&quot;</span>,c + i,a[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        len[i] = <span class="built_in">strlen</span>(a[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (len[i] == <span class="number">1</span>) v[a[i][<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>].<span class="built_in">push_back</span>(c[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i;j &lt;= n;j ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= K;k ++)</span><br><span class="line">                g[i][j][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i;j &lt;= n;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j][t[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,t[i] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= K;k ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (len[k] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>;l &lt;= len[k];l ++)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> p = i;p &lt; j;p ++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (g[i][p][k][l - <span class="number">1</span>] == inf || f[p + <span class="number">1</span>][j][a[k][l] - <span class="string">&#x27;a&#x27;</span>] == inf) <span class="keyword">continue</span>;</span><br><span class="line">                            g[i][j][k][l] = <span class="built_in">min</span>(g[i][j][k][l],g[i][p][k][l - <span class="number">1</span>] + f[p + <span class="number">1</span>][j][a[k][l] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">if</span> (g[i][j][k][len[k]] + <span class="number">1</span> &lt; f[i][j][c[k] - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        f[i][j][c[k] - <span class="string">&#x27;a&#x27;</span>] = g[i][j][k][len[k]] + <span class="number">1</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(f[i][j][c[k] - <span class="string">&#x27;a&#x27;</span>],c[k] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> nw = q.<span class="built_in">top</span>().second,res = q.<span class="built_in">top</span>().first;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (res != f[i][j][nw]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>;p &lt; v[nw].<span class="built_in">size</span>();p ++)</span><br><span class="line">                    <span class="keyword">if</span> (res + <span class="number">1</span> &lt; f[i][j][v[nw][p]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        f[i][j][v[nw][p]] = res + <span class="number">1</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(res + <span class="number">1</span>,v[nw][p]));</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= K;k ++) g[i][j][k][<span class="number">1</span>] = f[i][j][a[k][<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    h[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; i;k ++)</span><br><span class="line">                <span class="keyword">if</span> (j) h[i][j] = <span class="built_in">min</span>(h[i][j],h[k][j - <span class="number">1</span>] + f[k + <span class="number">1</span>][i][s[j] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">    <span class="keyword">if</span> (h[n][m] &gt;= inf) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,h[n][m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（终于结束了QAQ）</p>
<h1 id="Ex-Game-on-Graph"><a href="#Ex-Game-on-Graph" class="headerlink" title="Ex. Game on Graph"></a>Ex. Game on Graph</h1><p>先考虑只判断游戏是否会无限进行下去。</p>
<p>用 $f(i,1&#x2F;2)$ 表示现在在点 $i$，该 Arisa &#x2F; Kasumi 走时游戏是否会无限进行，会则值为 $1$，否则为 $0$。</p>
<p>令 $out(i)$ 表示点 $i$ 的出度，</p>
<p>则有</p>
<p>$$<br>\begin{cases} \begin{aligned} f(i,1) &amp;&#x3D; \max \limits _{j &#x3D; son(i)} f(j,2) &amp; &amp;out(i) &gt; 0\newline f(i,2) &amp;&#x3D; \max \limits _{j&#x3D;son(i)} f(j,1) &amp; &amp;out(i) &gt; 0 \newline f(i,1) &amp;&#x3D; f(i,2) &#x3D; 0 &amp; &amp;out(i)&#x3D;0 \end {aligned} \end{cases}<br>$$</p>
<p>时间复杂度 $O(M)$ 即可求出解。</p>
<p>考虑图为 DAG 的情况。</p>
<p>用 $g(i,1&#x2F;2)$ 表示现在在点 $i$，该 Arisa &#x2F; Kasumi 走时，在这之后经过的边的边权之和。</p>
<p>令 $dis(i,j)$ 表示点 $i,j$ 之间的距离，</p>
<p>则有</p>
<p>$$<br>\begin{cases} \begin{aligned} g(i,1) &amp;&#x3D; \min \limits _{j&#x3D;son(i)} { g(j,2) + dis(i,j) } &amp; &amp;out(i) &gt; 0 \newline g(i,2) &amp;&#x3D; \max \limits _{j&#x3D;son(i)} { g(j,1) + dis(i,j) } &amp; &amp;out(i) &gt; 0 \newline g(i,1) &amp;&#x3D; g(i,2) &#x3D; 0 &amp; &amp;out(i) &#x3D; 0 \end{aligned} \end{cases}<br>$$</p>
<p>$g(i,1&#x2F;2)$ 初始值为 $inf$，时间复杂度 $O(m)$ 即可求出解。</p>
<p>现在来考虑原题的情况。把上面的 DP 倒过来做，将所有边反向连接，从 $out(i) &#x3D; 0$ 的点开始，类似 Dijkstra &#x2F; 拓扑排序的思想更新答案，每次把更新完的点放进堆里，注意 $\min$ 和 $\max$ 的处理。</p>
<p>用 $g(i,1&#x2F;2) &#x3D; inf$ 表示游戏会无限进行，发现 $g$ 可以代替 $f$。</p>
<p>注意，$g(i,2)$ 的优先级应比 $g(i,1)$ 高（自己想一想？），所以在更新 $g(son(i),2)$ 的答案时，应等到所有可以到达 $son(i)$ 的点都更新完 $g(son(i),2)$ 的答案后，再把 $son(i)$ 放进堆里，不然会影响之后算出来的答案。要判断是否所有可以到达 $son(i)$ 的点都更新完 $g(son(i),2)$ 的答案，可以采用这样的策略：每次更新完 $g(son(i),2)$ 的答案后就把 $in(son(i)) \to in(son(i))-1$，当 $in(son(i))&#x3D;0$ 时就把 $son(i)$ 入堆，原因显然（结合堆的性质，想一想每个点被放进堆的顺序）。这样做也可以去除环的影响。</p>
<p>最后的答案就是 $g(v,1)$。</p>
<p>这个 DP 的时间复杂度为 $O(M \log M)$。</p>
<p>代码（记得开 <code>long long</code>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf (long long)(1e18)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pair pair <span class="string">&lt;long long, pair &lt;long long,long long&gt;</span> &gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll n,m,v;</span><br><span class="line">ll to[<span class="number">200010</span>],val[<span class="number">200010</span>],in[<span class="number">200010</span>],nxt[<span class="number">200010</span>],head[<span class="number">200010</span>],cnt,p[<span class="number">200010</span>];</span><br><span class="line">ll f[<span class="number">200010</span>][<span class="number">3</span>];</span><br><span class="line">priority_queue&lt;Pair, vector &lt;Pair&gt;, greater &lt;Pair&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++ cnt] = y;</span><br><span class="line">    val[cnt] = z;</span><br><span class="line">    nxt[cnt] = head[x];</span><br><span class="line">    in[y] ++;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= n;i ++,p[i] = <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (!in[i]) f[i][<span class="number">1</span>] = f[i][<span class="number">2</span>] = <span class="number">0</span>,q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="built_in">make_pair</span>(i,<span class="number">1</span>))),q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="built_in">make_pair</span>(i,<span class="number">2</span>)));</span><br><span class="line">        <span class="keyword">else</span> f[i][<span class="number">1</span>] = f[i][<span class="number">2</span>] = inf;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ll x = q.<span class="built_in">top</span>().second.first,op = q.<span class="built_in">top</span>().second.second,tmp = q.<span class="built_in">top</span>().first;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">2</span>) tmp = -tmp;</span><br><span class="line">        <span class="keyword">if</span> (f[x][op] != tmp) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (ll i = head[x];i;i = nxt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ll u = to[i],dis = val[i];</span><br><span class="line">                <span class="keyword">if</span> (f[u][<span class="number">1</span>] &gt; tmp + dis) f[u][<span class="number">1</span>] = tmp + dis,q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(f[u][<span class="number">1</span>],<span class="built_in">make_pair</span>(u,<span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (ll i = head[x];i;i = nxt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ll u = to[i],dis = val[i];</span><br><span class="line">                <span class="keyword">if</span> (f[u][<span class="number">2</span>] &lt; tmp + dis || !p[u]) f[u][<span class="number">2</span>] = tmp + dis;</span><br><span class="line">                <span class="keyword">if</span> (!p[u]) p[u] = <span class="number">1</span>;</span><br><span class="line">                in[u] --;</span><br><span class="line">                <span class="keyword">if</span> (!in[u]) q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-f[u][<span class="number">2</span>],<span class="built_in">make_pair</span>(u,<span class="number">2</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;v);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        <span class="built_in">add</span>(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line">    <span class="keyword">if</span> (f[v][<span class="number">1</span>] &gt;= inf) <span class="built_in">printf</span>(<span class="string">&quot;INFINITY\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[v][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>AC 自动机 学习笔记</title>
    <url>/2021/12/07/AC-Automaton/</url>
    <content><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul>
<li>Trie 树</li>
<li>KMP 的思想（也许不用？）</li>
</ul>
<h1 id="AC自动机是什么？"><a href="#AC自动机是什么？" class="headerlink" title="AC自动机是什么？"></a>AC自动机是什么？</h1><p><del>可以帮你自动A题的作弊玩意</del></p>
<blockquote>
<p>AC 自动机是 以 Trie 的结构为基础，结合 KMP 的思想 建立的。<br>简单来说，建立一个 AC 自动机有两个步骤：<br>1.基础的 Trie 结构：将所有的模式串构成一棵 Trie。<br>2.KMP 的思想：对 Trie 树上所有的结点构造失配指针。<br>然后就可以利用它进行多模式匹配了。<br>——OI-Wiki</p>
</blockquote>
<h1 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h1><p><a href="https://www.luogu.com.cn/problem/P3808">https://www.luogu.com.cn/problem/P3808</a><br>给定 $n$ 个模式串 $s_{1,\dots ,n}$ 和一个文本串 $t$，求有多少个不同的模式串在文本串里出现过。<br>两个模式串不同当且仅当他们<strong>编号</strong>不同。</p>
<p>$1 \leq n \leq 1e6$，$1 \leq |t| \leq 1e6$，$1 \leq \sum \limits_{i&#x3D;1} ^n |s_i| \leq 1e6$。</p>
<h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>对于上面这道题，显然我们可以对于每个模式串都判断一次是否在文本串里，时间复杂度 $O(n · |t|)$。很明显过不了。</p>
<p>这时，我们想到：KMP 算法中，我们利用了<strong>失配指针</strong>减少了不必要的比较，提高了算法效率！这种想法是否也可以用在这一题里呢？</p>
<p>显然是可以的。</p>
<p>考虑两个模式串 <code>abcd</code> 和 <code>bce</code>，文本串为 <code>abce</code>。</p>
<p>对于第一个模式串，当我们判断到文本串 <code>e</code> 这个字符时，发现不对了。如果按照上面的思路，我们需要从头再枚举，判断第二个模式串是否出现。但是，我们观察到，<code>bce</code> 的前两个字符在判断一个模式串时就已经被比较过了，产生了不必要的比较。因此，我们可以用一个失配指针，从第一个模式串的 <code>c</code> 指向第二个模式串的 <code>c</code>。</p>
<p>存储模式串，我们使用 Trie 树。</p>
<p>通过上面的这个例子，我们可以发现：当一个模式串的某一前缀为另一模式串的子串时，可以用上失配指针。</p>
<p>具体地说，若 $S_i(1,k) &#x3D; S_j(x,x+k-1)$，就产生一个从 $S_j[x+k-1]$ 到 $S_i[k]$ 的失配指针，因为当 $S_j(1,x+k-1)$ 在文本串中时，$S_j(x,x+k-1)&#x3D;S_i(1,k)$ 也一定在文本串中，我们无需比较 $S_i$ 的前  $k$ 位。</p>
<p>通过一段分析，我们已经大致得出了算法的思路：存模式串，建失配指针，查找。</p>
<p>接下来就只剩细节问题了。</p>
<h2 id="失配指针的建立"><a href="#失配指针的建立" class="headerlink" title="失配指针的建立"></a>失配指针的建立</h2><p>我们使用 BFS 建立失配指针。</p>
<p>来看看这样的一个 Trie 树。</p>
<p>（Trie 树的所有节点都代表了一个字符串，所有边都代表了一个字符）</p>
<p>（图待补充）</p>
<p>很明显，对于第一层的所有节点，失配指针只能指向根节点。</p>
<p>对于第二层及以下的层：</p>
<p>设当前正在考虑的节点为 $i$，它代表的字符串为 $tree[i]$，其父亲为 $fa[i]$，$x$ 的失配指针指向的节点为 $fail[x]$，连接 $x$ 和 $y$ 的边代表的字符为 $c(x,y)$。</p>
<p>根据失配指针的定义，$tree[fa[i]] (x_0,x_0+k-1)&#x3D;tree[fail[fa[i]]] (1,k)$。</p>
<p>若 $i$ 存在：<br>若 $fail[fa[i]]$ 的一个儿子 $r$ 满足 $c(fa[i],i)&#x3D;c(fail[fa[i]],r)$，则 $tree[i] (x_0,x_0+k)&#x3D;tree[r] (1,k+1)$，即 $i$ 的失配指针应指向 $r$。否则 $i$ 的失配指针指向根节点。同时将 $i$ 入队。</p>
<p>若 $i$ 这个节点不存在，则给 $fa[i]$ 和 $fail[fa[i]]$ 的满足 $c(fa[i],i)&#x3D;c(fail[fa[i]],r)$ 的儿子 $r$ 连一条边。</p>
<p>这样，经过一次 BFS，失配指针就建立好了。</p>
<h2 id="查找答案"><a href="#查找答案" class="headerlink" title="查找答案"></a>查找答案</h2><p>和暴力的思路差不多，在 Trie 树中，一个一个字符查找文本串，如果到了一个模式串的末尾就更新答案，如果匹配不上就跳失配指针。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> tr[<span class="number">1000010</span>][<span class="number">30</span>],tg[<span class="number">1000010</span>],fail[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nw = <span class="number">0</span>,len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tr[nw][s[i] - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">            tr[nw][s[i] - <span class="string">&#x27;a&#x27;</span>] = ++ cnt;</span><br><span class="line">        nw = tr[nw][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tg[nw] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i ++)</span><br><span class="line">        <span class="keyword">if</span> (tr[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nw = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i ++)</span><br><span class="line">            <span class="keyword">if</span> (tr[nw][i])</span><br><span class="line">                fail[tr[nw][i]] = tr[fail[nw]][i],q.<span class="built_in">push</span>(tr[nw][i]);</span><br><span class="line">            <span class="keyword">else</span> tr[nw][i] = tr[fail[nw]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nw = <span class="number">0</span>,ans = <span class="number">0</span>,len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        nw = tr[nw][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = nw;j &amp;&amp; tg[j] != <span class="number">-1</span>;j = fail[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ans += tg[j];</span><br><span class="line">            tg[j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        <span class="built_in">add</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="built_in">query</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.com.cn/problem/P3808">https://www.luogu.com.cn/problem/P3808</a>（模板）</p>
<p><a href="https://www.luogu.com.cn/problem/P3796">https://www.luogu.com.cn/problem/P3796</a>（加强版）<br>（待补充）</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1713D 题解</title>
    <url>/2022/08/09/CF1713D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>这是一道交互题。</p>
<p>有一场 $2^n$ 个人参加的淘汰赛，结果已定，你最多使用 $ \left \lceil \frac{1}{3} \cdot 2^{n + 1} \right \rceil $ 次询问，求出淘汰赛的冠军编号。每次询问的格式为 <code>? a b</code>，表示询问编号为 $a$ 的人和编号为 $b$ 的人哪个赢的次数多，询问的答案为 $0$ 或 $1$ 或 $2$ 表示 $a$ 赢的场数等于、大于或小于 $b$。最后输出 <code>! a</code>，表示淘汰赛的冠军编号。</p>
<p>$1 \leq n\leq 17$。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先考虑 $n&#x3D;1$ 的情况，显然直接询问 <code>? 1 2</code> 即可求出答案。</p>
<p>考虑 $n&#x3D;2$ 的情况，</p>
<p><a href="https://imgtu.com/i/vlK3X8"><img src="https://s1.ax1x.com/2022/08/09/vlK3X8.png" alt="vlK3X8.png"></a></p>
<p>如图，$1$ 和 $2$ 中一定有一个在第一轮就被淘汰了，$3$ 和 $4$ 也是，第一轮之后剩下的两个一定有一个是冠军，赢的场数一定不同且比被淘汰的人多。被淘汰的人赢的场数是一样的。</p>
<p>我们可以询问 <code>? 1 3</code>，如果得到答案是 $0$，就得出 $1$ 和 $3$ 都被淘汰了，冠军只可能是 $2$ 或 $4$，一次询问得出答案；</p>
<p>如果答案是 $1$ 或 $2$，那么赢的场数较少的那一个人一定不可能是冠军，和赢的场数较多的人在第一轮比赛的人也一定不可能是冠军。因此就只剩两个人有可能是冠军了，一次询问得出答案。</p>
<p>综上，$n&#x3D;2$ 时，可以通过两次询问确定答案。</p>
<p>考虑 $n &gt; 2$ 的情况。</p>
<p>当 $2 \mid n$ 时，画出来的赛况图（像样例解释那样的）一定可以分为若干个 $n&#x3D;2$ 的情况。考虑对赛况图进行搜索，用每个点代表<strong>这一层代表的轮</strong>中<strong>这一个位置人的编号</strong>，则根节点的值就是答案，如样例中的图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/CF1713D/27b478ab2bf58dd616a7ef478d5125bdbaa0416b.png" alt="img"></p>
<p>对于每个从上往下数奇数层（除最后一层外）上的点，一定可以从最后一层开始用 $2$ 次询问求出这个点的答案，再用这个答案往上求答案。此时总共有 $2^n (\frac {1}{2}+\frac{1}{8}+\frac{1}{32}+\dots+\frac{1}{2^{n-1}}) &#x3D; 2^{n-1}(1+\frac{1}{4}+\frac{1}{16}+\dots+\frac{1}{2^{n-2}})&#x3D;2^{n-1}\times \frac{4}{3}(1-\frac{1}{2^n})&#x3D;\frac{1}{3}\times 2^{n+1}(1-\frac{1}{2^n})$ 次询问，满足题意；</p>
<p>当 $2 \nmid n$ 时，画出来的赛况图一定可以分为若干个 $n&#x3D;2$ 的情况和一个 $n&#x3D;1$ 的情况，可以类比 $2 \mid n$ 的情况。此时总共有 $2 ^n (\frac{1}{2}+\frac{1}{8}+\frac{1}{32}+\dots+\frac{1}{2^{n-2}})+1 &#x3D; 2^n(\frac{1}{2}+\frac{1}{8}+\frac{1}{32}+\dots+\frac{1}{2^{n-2}}+\frac{1}{2^n}) &#x3D; 2^{n+1}\times \frac{4}{3}(1 - \frac{1}{2^{n+1}})$ 次询问，满足题意。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t,n,m;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">600010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[x] = l;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(x &lt;&lt; <span class="number">1</span>,l,(l + r) / <span class="number">2</span>,dep + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,(l + r) / <span class="number">2</span> + <span class="number">1</span>,r,dep + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (dep % <span class="number">2</span> == <span class="number">1</span> - n % <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>,ans[x &lt;&lt; <span class="number">2</span>],ans[(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;&lt; <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;res);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>,ans[x &lt;&lt; <span class="number">2</span> | <span class="number">1</span>],ans[(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;&lt; <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">2</span>) ans[x] = ans[(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> ans[x] = ans[x &lt;&lt; <span class="number">2</span> | <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>,ans[x &lt;&lt; <span class="number">2</span>],ans[(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">2</span>) ans[x] = ans[(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> ans[x] = ans[x &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>,ans[x &lt;&lt; <span class="number">2</span> | <span class="number">1</span>],ans[(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">2</span>) ans[x] = ans[(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> ans[x] = ans[x &lt;&lt; <span class="number">2</span> | <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        m = (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) ans[(<span class="number">1</span> &lt;&lt; n - <span class="number">1</span>) + i] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> res;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>,ans[<span class="number">2</span>],ans[<span class="number">3</span>]);</span><br><span class="line">            <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">2</span>) ans[<span class="number">1</span>] = ans[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">else</span> ans[<span class="number">1</span>] = ans[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;! %d\n&quot;</span>,ans[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1975F Set</title>
    <url>/2024/05/31/CF1975F/</url>
    <content><![CDATA[<p><strong>题意</strong></p>
<p>对于集合 $T \subseteq { 0,1,2,\cdots }$，定义函数 $f(T) &#x3D; \sum \limits _{i \in T} 2^i$，也就是每个数出没出现对应一个二进制数。</p>
<p>给定集合 $V_0,V_1,\cdots,V_{2^n - 1}$，求所有的集合 $S$，使得对于所有 $T \subseteq { 0,1,2,\cdots}$，都有 $|S\cap T| \in V_{f(T)}$。也就是，对于每一个 $T$，你的 $S$ 和 $T$ 的共同元素个数是 $V_{f(T)}$ 中的某一个。</p>
<p><strong>解法</strong></p>
<p>从 $0$ 开始依次考虑每一个元素是否在 $S$ 里面。如果 $i$ 在 $S$ 里面，所有包含 $i$ 的 $T$ 对应的 $V_{f(T)}$ 可以选的数就都要减一，因为选了一个 $i$。对于两个集合 $T_1$ 和 $T_2$，如果它们只在有没有 $i$ 上不一样，其中 $T_1$ 包含 $i$，那么两个集合可以合并成一个：$V_{f(T’)}&#x3D;(V_{f(T_1)} &gt;&gt; 1) \cap V_{f(T_2)}$。同理，如果 $i$ 不在 $S$ 里面，则 $V_{f(T’)}&#x3D;V_{f(T_1)} \cap V_{f(T_2)}$。</p>
<p>发现两个集合可以合并成另外两个集合，每考虑一个 $i$ 后集合总数不变。可以把新合并出来的集合存在原来两个集合的位置，类似 FFT（？）。对于每个 $i$ 直接暴力合并，总时间复杂度为 $O(n 2^n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2000010</span>],nw[<span class="number">2000010</span>];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    a[<span class="number">0</span>] = (<span class="number">1</span> &lt;&lt; (n + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; (<span class="number">1</span> &lt;&lt; n);i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>;w &lt; (<span class="number">1</span> &lt;&lt; n);w += (<span class="number">1</span> &lt;&lt; (i + <span class="number">1</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = w;j &lt; w + (<span class="number">1</span> &lt;&lt; i);j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k = j + (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                <span class="type">int</span> tmpa = a[j],tmpb = a[k];</span><br><span class="line">                a[k] = (tmpa &amp; (tmpb &gt;&gt; <span class="number">1</span>));</span><br><span class="line">                a[j] = (tmpa &amp; tmpb);</span><br><span class="line">                nw[k] = nw[k] ^ (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; (<span class="number">1</span> &lt;&lt; n);i ++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] &amp; <span class="number">1</span>) Ans.<span class="built_in">push_back</span>(nw[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Ans.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : Ans) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>JOI 2025 Final 只不过是长的领带 2 / Just Long Neckties 2 题解</title>
    <url>/2025/02/08/JOI2025-final-just-long-neckties-2-solution/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/P11665">洛谷 P11665</a>。</p>
<p>题目即从原序列取出若干个数形成新序列，且原序列中相邻两个数至少取一个，求新序列最少用几个不下降子序列可以覆盖。</p>
<p>考虑贪心，如果原序列的某个数要放进新序列，就把它安排在当前所有不下降子序列中，结尾的数小于等于它的最大的一个后面，找不到就新加一个序列。可以发现，过程中某一时刻，所有不下降子序列的最后一个数都不同，可以用 $2^{21}$ 种状态表示。</p>
<p>于是有一个简单的 DP，记 $f_{i,S}$ 表示当前考虑到第 $i$ 个数，不下降子序列的状态为 $S$ 是否可行。</p>
<p>如果 $f_{i,S}&#x3D;1$，且 $a_{i+1} \in S$，则 $f_{i+1,S}&#x3D;1$；同理，如果 $f_{i,S}&#x3D;1$ 且 $a_{i+2} \in S$，则 $f_{i+2,S}&#x3D;1$。也就是说，从一个 $f_{i,S}&#x3D;1$ 的状态，可以一直推到 $f_{j-1,S}&#x3D;1$，其中 $j$ 是最小的满足 $a_j \notin S$，$a_{j+1} \notin S$ 的数。这个 $j$ 可以通过预处理后暴力得出（对每个位置，预处理 $nxt_{i,x}$ 为大于 $i$ 的最小的 $j$，使得 $a_j&#x3D;x$；$nxtt_{i,x}$ 为大于等于 $i$ 的最小的 $j$，使得 $a_{j+1}&#x3D;x$；查询时暴力往后跳）。发现对于一个状态 $S$，重要的只有最大的 $k$ 使得 $f_{k,S}&#x3D;1$，记这样的 $k$ 为 $g_S$。此时的 $j$ 即为 $g_S + 1$。</p>
<p>然后就可以得出 $g_S$ 的求解方法。考虑从小到大计算，由于 $a_{g_S + 1}$ 和 $a_{g_S + 2}$ 至少要选一个，下一个放进不下降子序列集合的数一定是这两个之一。分类讨论放哪一个数，得出新的 $S’$，再计算 $g_{S’}$ 即可。若此时发现 $S’$ 可以把剩下的序列全部覆盖掉，则更新答案。</p>
<p>总的时间复杂度为 $\mathcal{O}(nV+V^22^V)$，此处 $V&#x3D;\max{a_i}&#x3D;21$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5000010</span>];</span><br><span class="line"><span class="type">int</span> nxt[<span class="number">5000010</span>][<span class="number">23</span>],nxtt[<span class="number">5000010</span>][<span class="number">23</span>],las[<span class="number">23</span>];</span><br><span class="line"><span class="type">int</span> f[(<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">10</span>],ans = <span class="number">40</span>;</span><br><span class="line"><span class="type">int</span> cnt[(<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a + i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">21</span>;j ++) nxtt[i][j] = nxtt[las[a[i]]][j];</span><br><span class="line">		nxtt[i][a[i + <span class="number">1</span>]] = i + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">21</span>;j ++) nxt[i][j] = las[j];</span><br><span class="line">		las[a[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">21</span>;i ++) nxt[<span class="number">0</span>][i] = las[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">21</span>);i ++) cnt[i] = cnt[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">21</span>);i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!f[i] &amp;&amp; i) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> Nxt = f[i] + <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> res = <span class="number">0</span>,tnxt = Nxt;</span><br><span class="line">		Nxt = n + <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = a[tnxt] - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j --)</span><br><span class="line">			<span class="keyword">if</span> ((i &gt;&gt; j &amp; <span class="number">1</span>) || !j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> tmp = (i &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">21</span>) - <span class="number">1</span> - (<span class="number">1</span> &lt;&lt; j))) ^ (<span class="number">1</span> &lt;&lt; (a[tnxt] - <span class="number">1</span>));</span><br><span class="line">				res = tmp;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">21</span>;k ++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (tmp &gt;&gt; k &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="type">int</span> t = nxt[tnxt][k + <span class="number">1</span>];</span><br><span class="line">					<span class="keyword">if</span> (!t) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>;w &lt; <span class="number">21</span>;w ++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> (tmp &gt;&gt; w &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">						<span class="type">int</span> tt = nxtt[t][w + <span class="number">1</span>];</span><br><span class="line">						<span class="keyword">if</span> (!tt) <span class="keyword">continue</span>;</span><br><span class="line">						Nxt = <span class="built_in">min</span>(Nxt,tt - <span class="number">1</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (Nxt &gt;= n)</span><br><span class="line">			ans = <span class="built_in">min</span>(ans,cnt[res]);</span><br><span class="line">		<span class="keyword">else</span> f[res] = <span class="built_in">max</span>(f[res],Nxt - <span class="number">1</span>);</span><br><span class="line">		Nxt = n + <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = a[tnxt + <span class="number">1</span>] - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j --)</span><br><span class="line">			<span class="keyword">if</span> ((i &gt;&gt; j &amp; <span class="number">1</span>) || !j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> tmp = (i &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">21</span>) - <span class="number">1</span> - (<span class="number">1</span> &lt;&lt; j))) ^ (<span class="number">1</span> &lt;&lt; (a[tnxt + <span class="number">1</span>] - <span class="number">1</span>));</span><br><span class="line">				res = tmp;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">21</span>;k ++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (tmp &gt;&gt; k &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="type">int</span> t = nxt[tnxt + <span class="number">1</span>][k + <span class="number">1</span>];</span><br><span class="line">					<span class="keyword">if</span> (!t) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>;w &lt; <span class="number">21</span>;w ++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> (tmp &gt;&gt; w &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">						<span class="type">int</span> tt = nxtt[t][w + <span class="number">1</span>];</span><br><span class="line">						<span class="keyword">if</span> (!tt) <span class="keyword">continue</span>;</span><br><span class="line">						Nxt = <span class="built_in">min</span>(Nxt,tt - <span class="number">1</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (Nxt &gt;= n)</span><br><span class="line">			ans = <span class="built_in">min</span>(ans,cnt[res]);</span><br><span class="line">		<span class="keyword">else</span> f[res] = <span class="built_in">max</span>(f[res],Nxt - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI2014 购票</title>
    <url>/2024/05/31/NOI2014%E8%B4%AD%E7%A5%A8/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/P2305">洛谷</a>；<a href="https://loj.ac/p/2249">LOJ</a>。</p>
<p>一眼看错题目的式子，$dp_v+q_v$ 其实是 $d\cdot p_v+q_v$<br>(</p>
<p>每个点要往上跳，考虑 DP，点 $u$ 可以从深度大于等于某个值的祖先 $v$ 转移：$f_u &#x3D; \min { f_v + dis(u,v) p_u + q_u } &#x3D; \min { f_v + dep(u) p_u - dep(v)p_u + q_u } &#x3D; \min { f_v - dep(v)p_u } + dep(u)p_u + q_u$。直接斜率优化，$dep(v)$ 有单调性，维护下凸壳，二分找转移点，可以解决链的情况。</p>
<p>考虑怎么放到树上，这里写点分治的做法。有根树上的点分治和无根树上的很像，只是计算下面的点需要先算好上面的点，有一个先后顺序。于是可以先算上面的一部分，再算上面对下面的贡献，最后再算下面。具体步骤如下：</p>
<ol>
<li>找当前求解的块的重心作为分治中心；</li>
<li>递归求解重心以上的部分（也就是看成重心为根的树后，包括原来的根的那一棵子树）；</li>
<li>算上面部分对下面所有点的贡献；</li>
<li>递归求解重心的子树。</li>
</ol>
<p>第三步与 cdq 分治算贡献的操作类似（是一样的吗？）。分析时间复杂度，每次递归，块的大小都会减半，总共 $O(\log n)$ 层，每一层的总大小都是 $O(n)$。每层中第三步的时间复杂度为 $O(n \log n)$，总时间复杂度为 $O(n \log^2 n)$。</p>
<p>需要注意的细节有：每次用到的连通块是否包含重心；连通块大小为 $2$ 时小心重心不停选同一个点，导致每次递归都是一样的连通块，死循环。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pair pair <span class="string">&lt;long long, long long&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll inf = <span class="number">5e17</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,t;</span><br><span class="line"><span class="type">int</span> to[<span class="number">400010</span>],nxt[<span class="number">400010</span>],head[<span class="number">200010</span>],cnt;</span><br><span class="line">ll p[<span class="number">200010</span>],q[<span class="number">200010</span>];</span><br><span class="line">ll val[<span class="number">400010</span>];</span><br><span class="line"><span class="type">int</span> st[<span class="number">200010</span>],tp;</span><br><span class="line">ll dis[<span class="number">200010</span>],lim[<span class="number">200010</span>],dep[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> siz[<span class="number">200010</span>],maxsiz[<span class="number">200010</span>],nsiz,root,vis[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> ind[<span class="number">200010</span>],len;</span><br><span class="line">Pair wai[<span class="number">200010</span>],st2[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> lenwai;</span><br><span class="line">ll f[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++ cnt] = y;</span><br><span class="line">    val[cnt] = z;</span><br><span class="line">    nxt[cnt] = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> la)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[++ tp] = x;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>,r = tp,res = <span class="number">0</span>;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = ((l + r) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (dis[x] - dis[st[mid]] &lt;= lim[x]) res = mid,r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lim[x] = dep[st[res]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == la) <span class="keyword">continue</span>;</span><br><span class="line">        dis[u] = dis[x] + val[i];</span><br><span class="line">        dep[u] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">pre</span>(u,x);</span><br><span class="line">        siz[x] += siz[u];</span><br><span class="line">    &#125;</span><br><span class="line">    tp --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fndroot</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    maxsiz[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (dep[u] &lt; dep[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">fndroot</span>(u);</span><br><span class="line">        maxsiz[x] = <span class="built_in">max</span>(maxsiz[x],siz[u]);</span><br><span class="line">        siz[x] += siz[u];</span><br><span class="line">    &#125;</span><br><span class="line">    maxsiz[x] = <span class="built_in">max</span>(maxsiz[x],nsiz - siz[x]);</span><br><span class="line">    <span class="keyword">if</span> (siz[x] &gt; <span class="number">1</span> &amp;&amp; maxsiz[x] &lt; maxsiz[root]) root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getchain</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> ed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ind[++ len] = x;</span><br><span class="line">    <span class="keyword">if</span> (x == ed) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (dep[u] &lt; dep[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getchain</span>(u,ed)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len --;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">calk</span><span class="params">(Pair x,Pair y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span> <span class="type">double</span>)<span class="number">1.0</span> * (y.second - x.second) / (y.first - x.first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(Pair x,Pair y,Pair z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">calk</span>(x,y) &gt;= <span class="built_in">calk</span>(x,z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> stdep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="built_in">max</span>(<span class="number">1ll</span>,lim[x] - stdep + <span class="number">1</span>);</span><br><span class="line">    wai[++ lenwai] = <span class="built_in">make_pair</span>(tmp,x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> ((x != root &amp;&amp; vis[x]) || dep[u] &lt; dep[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">solve</span>(u,stdep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfz</span><span class="params">(<span class="type">int</span> rt)</span><span class="comment">// 点分治</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    root = <span class="number">0</span>;</span><br><span class="line">    maxsiz[<span class="number">0</span>] = n + <span class="number">1</span>;</span><br><span class="line">    nsiz = siz[rt];</span><br><span class="line">    <span class="keyword">if</span> (nsiz == <span class="number">1</span> || vis[rt]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">fndroot</span>(rt);</span><br><span class="line">    <span class="type">int</span> tmp = root;</span><br><span class="line">    vis[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfz</span>(rt);<span class="comment">// 算根到重心以上的树的答案</span></span><br><span class="line">    root = tmp;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getchain</span>(rt,root);<span class="comment">// 把根到重心的链拉出来</span></span><br><span class="line">    lenwai = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">solve</span>(root,dep[rt]);</span><br><span class="line">    <span class="built_in">sort</span>(wai + <span class="number">1</span>,wai + lenwai + <span class="number">1</span>,[](Pair x,Pair y)&#123;<span class="keyword">return</span> x.first &gt; y.first;&#125;);</span><br><span class="line">    <span class="type">int</span> la = len;</span><br><span class="line">    tp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= lenwai;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pair x = wai[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = la;j &gt;= x.first;j --)</span><br><span class="line">        &#123;</span><br><span class="line">            ll X = dis[ind[j]],Y = f[ind[j]];</span><br><span class="line">            <span class="keyword">while</span> (tp &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">pd</span>(<span class="built_in">make_pair</span>(X,Y),st2[tp],st2[tp - <span class="number">1</span>])) tp --;</span><br><span class="line">            st2[++ tp] = <span class="built_in">make_pair</span>(X,Y);</span><br><span class="line">        &#125;</span><br><span class="line">        la = <span class="built_in">min</span>(len,(<span class="type">int</span>)x.first - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>,r = tp,res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">double</span> K = p[x.second];</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = ((l + r) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">1</span> || <span class="built_in">calk</span>(st2[mid],st2[mid - <span class="number">1</span>]) &gt;= K) res = mid,l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res) f[x.second] = <span class="built_in">min</span>(f[x.second],st2[res].second - p[x.second] * st2[res].first + dis[x.second] * p[x.second] + q[x.second]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[root];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (dep[u] &gt; dep[root]) <span class="built_in">dfz</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld%lld%lld&quot;</span>,&amp;x,&amp;y,p + i,q + i,lim + i);</span><br><span class="line">        <span class="built_in">add</span>(x,i,y),<span class="built_in">add</span>(i,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i ++) f[i] = inf;</span><br><span class="line">    <span class="built_in">pre</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">// 预处理每个点最高可以从哪个祖先转移过来</span></span><br><span class="line">    <span class="built_in">dfz</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i ++) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>点分治</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>DP 优化</title>
    <url>/2022/02/19/DP%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>upd on 20220405 修了炸了的图和 LaTeX</p>
<p>upd on 20230903 关于数据结构优化 DP，可以看看新写的博客~</p>
<p>upd on 20240228 加了一道题 qwq</p>
<p>题单：<a href="https://www.luogu.com.cn/training/144843">https://www.luogu.com.cn/training/144843</a></p>
<p>有的时候，普通的动态规划不能通过题目，需要用到一些数据结构或思想进行优化。</p>
<h1 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul>
<li>单调队列</li>
</ul>
<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>在 dp 转移的时候，会取上一个阶段最优的答案进行转移得到现在的答案。</p>
<p>而一个一个枚举上一个阶段的所有情况会导致时间复杂度增加，所以我们可以使用单调队列进行优化。</p>
<p>由于单调队列的时间复杂度很小，所以经常被使用。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>CF372C Watching Fireworks is Fun <a href="https://codeforces.com/problemset/problem/372/C">https://codeforces.com/problemset/problem/372/C</a></p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>普通的 dp 解法时间复杂度为 $O(mn^2)$，显然过不去。</p>
<p>观察转移方程：$f_{i,j}$​ 表示第 $i$​ 个烟花，在位置 $j$​ 的最优答案。</p>
<p>$$<br>f_{i,j} &#x3D; \max \limits_{k&#x3D;1} ^{n} ( {f_{i-1,k} } +b_i-|{a_i}-j| )<br>$$</p>
<p>由于我们枚举了 $i$ 和 $j$，所以可以把确定的量提出来：</p>
<p>$$<br>f_{i,j} &#x3D; \max \limits_{k&#x3D;1} ^n ( {f_{i-1,k} } )+b_i-|{a_i} -j|<br>$$</p>
<p>时间复杂度降为了 $O(mn)$，可以过。</p>
<h2 id="单调队列优化多重背包"><a href="#单调队列优化多重背包" class="headerlink" title="单调队列优化多重背包"></a>单调队列优化多重背包</h2><p>观察一下朴素多重背包算法的式子：</p>
<p>$$<br>f[i][j]&#x3D;\max \limits_{k&#x3D;0} ^{m[i]} ( f[i-1][j-k\cdot w[i]]+k\cdot v[i] )<br>$$</p>
<p>其中 $i$ 表示现在枚举到第 $i$ 中物品，$j$ 表示已经用了的背包容量，$k$ 表示第 $i$ 种物品放几个，$w[i]$ 表示体积，$v[i]$​ 表示价值，$m[i]$ 表示物品个数。</p>
<p>令 $x&#x3D;j-w[i]$，可以发现只有在 $j \equiv x \space (mod\space w[i])$​ 的情况下才能转移。</p>
<p>我们把这个式子改一下：</p>
<p>$$<br>\begin{aligned} f[i][j+y \cdot  w[i]] &amp;&#x3D;\max \limits_{k&#x3D;1} ^{m[i]} ( f[i-1][j+(y-k)w[i]]+k\cdot v[i] ) \newline &amp;&#x3D; \max \limits_{k&#x3D;1} ^{m[i]} ( f[i-1][j+(y-k) \cdot w[i]] -(y-k)v[i] )+y\cdot v[i] \end{aligned}<br>$$</p>
<p>令 $t&#x3D;y-k$​​，则</p>
<p>$$<br>f[i][j+y\cdot w[i]]&#x3D;\max \limits_{t&#x3D;y-m[i]} ^{y-1}( f[i-1][j+t\cdot w[i]] - t\cdot v[i] )+y\cdot v[i]<br>$$</p>
<p>花括号内的东西可以用单调队列维护。</p>
<p>枚举 $j$​ 的时间复杂度为 $O(w[i])$​，枚举 $t$​ 的时间复杂度为 $O([\tfrac {W}{w[i]}])$​，</p>
<p>总的时间复杂度就是 $O(n)\times O(w[i]) \times O([\tfrac{W}{w[i]}])&#x3D;O(nW)$​。</p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>多重背包板子：Luogu P1776 宝物筛选 <a href="https://www.luogu.com.cn/problem/P1776">https://www.luogu.com.cn/problem/P1776</a>（用单调队列做）</p>
<p>Loj #10183 股票交易 <a href="https://loj.ac/p/10183">https://loj.ac/p/10183</a></p>
<h1 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h1><h2 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h2><p>有一些题目，可以把转移方程看做直线的方程，把问题转化为求二维平面上选择一些点，最小化直线的截距。</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p>Loj 玩具装箱 <a href="https://loj.ac/p/10188">https://loj.ac/p/10188</a></p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>状态转移方程：$f_i$​​​ 表示以 $i$​ 为右端点分一段的最小代价，$sum_i$​ 表示 $c$​​ 数组的前缀和。</p>
<p>$$<br>f_{i}&#x3D;\min \limits_{j&#x3D;0} ^{i-1} ( f_j + (i-(j+1) + sum_i-sum_j - L) ^2 )<br>$$</p>
<p>枚举 $i$，把确定的提出来：</p>
<p>$$<br>\begin{aligned}<br>f_i &amp;&#x3D; \min \limits_{j&#x3D;0} ^{i-1}( f_j + (i+sum_i - 1-L) ^2 + (j + sum_j) ^2 - 2 (i+sum_i-1-L)(j+sum_j) )\newline<br>&amp;&#x3D; \min \limits_{j&#x3D;0} ^{i-1} ( f_j+(j+sum_j) ^2 - 2(i + sum_i-1-L)(j + sum_j) ) + (i+sum_i - 1 - L) ^2<br>\end{aligned}<br>$$</p>
<p>令 $g_i&#x3D;sum_i+i$，$L’&#x3D;L+1$，则</p>
<p>$$<br>f_i-(g_i-L’)^2 &#x3D; \min ( f_j+g_j\ ^2 - 2(g_i-L’)g_j )<br>$$</p>
<p>我们把直线的方程 $y&#x3D;kx+b$​ 变一下，就可以得到 $b&#x3D;y-kx$​。</p>
<p>令</p>
<p>$$<br>b_i&#x3D;f_i-(g_i-L’) ^2\newline<br>y_j &#x3D; f_j+g_j\ ^2\newline<br>k_i &#x3D; 2(g_i-L’)\newline<br>x_j &#x3D; g_j<br>$$</p>
<p>我们就成功地把转移方程变成了直线方程：</p>
<p>$$<br>b_i&#x3D;\min \limits_{j&#x3D;0} ^{i-1} ( y_j - k_i x_j )<br>$$</p>
<p>$k_i$ 表示一条经过点 $(x_j,y_j)$​ 的直线的斜率。</p>
<p>把问题转化为了选择合适的 $j$，使得 $b_i$，也就是直线的<strong>截距</strong>最小。</p>
<ul>
<li>怎么求这个点呢？</li>
</ul>
<p>我们画一下图。</p>
<p><img src="https://s21.ax1x.com/2024/04/20/pkSrIjP.png" alt="pkSrIjP.png"></p>
<p>红色直线的斜率为 $k_i$。</p>
<p>我们把这条直线向上移，直到碰到一个点：</p>
<p><img src="https://s21.ax1x.com/2024/04/20/pkSr7B8.png" alt="pkSr7B8.png"></p>
<p>碰到的第一个点就是要求的点。</p>
<p>证明：反证法，若继续向上移，$b_i$ 会继续变大，所以后面的都不会比这个点更优。</p>
<p>不难发现可能的答案在下凸壳（黑色线）上。</p>
<p>所以我们不需要枚举每一个点，只需要维护下凸壳上的点即可。</p>
<p>这个点的性质为：它和左边的点连成的直线的斜率 $\leq k_i&lt;$ 它和右边的点连成的直线的斜率。</p>
<p>而本题中，$k_i&#x3D;2(g_i-L’)$​​​，$g_i$​​​ 随着 $i$​​​ 的增加而增加，所以 $k_i$​​​​ 是递增的。</p>
<p>所以可以用单调队列维护下凸壳，用一个指针 $ans$ 维护答案。</p>
<p>由于 $k_i$ 单调递增，所以每次 $ans$​ 的移动次数为均摊 $O(1)$。</p>
<p>在更新完 $f_i$ 后，我们把 $(x_i,y_i)$​ 也加进去。</p>
<p>这样，就成功地把时间复杂度降到了 $O(n)$。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>斜率优化的思想就是：把状态转移方程通过转化，把确定的量提到外面来，变成直线方程，使点的坐标代表待定的值，斜率和截距代表确定的值和待求的值，再转化成让截距最小的问题。</p>
<h2 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h2><h3 id="SDOI2016-征途"><a href="#SDOI2016-征途" class="headerlink" title="[SDOI2016] 征途"></a>[SDOI2016] 征途</h3><p><a href="https://loj.ac/p/2035">https://loj.ac/p/2035</a> &#x2F; <a href="https://www.luogu.com.cn/problem/P4072">https://www.luogu.com.cn/problem/P4072</a></p>
<p><strong>题解</strong></p>
<p>$$<br>\begin {aligned}<br>ans &amp;&#x3D; m ^2 \frac {\sum (dis[i]-average)^2}{m}\newline<br>&amp;&#x3D; m\sum(dis[i]-average)^2\newline<br>&amp;&#x3D; m\sum(dis[i] ^2 + average ^2 - 2dis[i]\cdot average)\newline<br>&amp;&#x3D; m\sum(dis[i]^2)-2\cdot sumdis ^2 + m^2 \cdot \frac {sumdis^2}{m^2}\newline<br>&amp;&#x3D; m\sum(dis[i] ^2) - sumdis^2<br>\end {aligned}<br>$$</p>
<p>所以问题变为了使 $\sum (dis[i]^2)$ 最小。</p>
<p>状态转移：</p>
<p>$$<br>\begin{aligned} &amp;f[i]&#x3D;\min \limits_{j&#x3D;0} ^{i-1} ( f[j]+(s[i]-s[j])^2 )\newline<br>\Rightarrow &amp;f[i] &#x3D; \min ( f[j]+s[i] ^2 + s[j] ^2 - 2 s[i]s[j] ) \newline<br>\Rightarrow &amp;f[i]-s[i] ^2 &#x3D; \min ( f[j]+s[j] ^2 - 2s[i]s[j] )\newline<br>\Rightarrow &amp;b &#x3D; \min ( y-kx ) \end{aligned}<br>$$</p>
<p>也就是：</p>
<p>$$<br>b[i]&#x3D;f[i]-s[i] ^2\newline<br>y[j]&#x3D;f[j]+s[j] ^2\newline<br>k[i]&#x3D;2s[i]\newline<br>x[j]&#x3D;s[j]<br>$$</p>
<p>后面就和上面那道题一样了。</p>
<h1 id="四边形不等式优化"><a href="#四边形不等式优化" class="headerlink" title="四边形不等式优化"></a>四边形不等式优化</h1><h2 id="四边形不等式"><a href="#四边形不等式" class="headerlink" title="四边形不等式"></a>四边形不等式</h2><blockquote>
<p>设$w(x,y)$是定义在整数集合上的二元函数。若对于定义域上的任意整数 $a,b,c,d$​，其中 $a\leq b \leq c \leq d$​，都有 $w(a,d)+w(b,c) \geq w(a,c) + w(b,d)$​ 成立，则称函数 $w$​​ 满足<strong>四边形不等式</strong>。</p>
<p>若等号永远成立，则称函数 满足<strong>四边形恒等式</strong>。</p>
</blockquote>
<h3 id="定理（另一种定义）"><a href="#定理（另一种定义）" class="headerlink" title="定理（另一种定义）"></a>定理（另一种定义）</h3><p>设 $w(x,y)$​​ 是定义在整数集合上的二元函数。若对于定义域上的任意整数 $a,b$​，其中 $a &lt;b$​，</p>
<p>都有 $w(a,b + 1) + w(a+1,b) \geq w(a,b)+w(a+1,b+1)$​ 成立，则函数 $w$​ 满足四边形不等式。</p>
<h3 id="定理证明"><a href="#定理证明" class="headerlink" title="定理证明"></a>定理证明</h3><p>对于 $a&lt;c$，有 $w(a,c+1)+w(a+1,c) \geq w(a,c)+w(a+1,c+1)$；</p>
<p>对于 $a+1 &lt;c$，有 $w(a+1,c+1)+w(a+2,c) \geq w(a+1,c)+w(a+1,c+1)$。</p>
<p>两式相加，得到 $w(a,c+1)+w(a+2,c) \geq w(a+1,c)+w(a+2,c+1)$。</p>
<p>以此类推，对任意的 $a \leq b \leq c$，有 $w(a,c+1)+w(b,c) \geq w(a,c)+w(b,c+1)$。</p>
<p>同理，对任意的 $a\leq b \leq c \leq d$，有 $w(a,d)+w(b,c) \geq w(a,c)+w(b,d)$。</p>
<h2 id="一维线性-dp-的四边形不等式优化"><a href="#一维线性-dp-的四边形不等式优化" class="headerlink" title="一维线性 dp 的四边形不等式优化"></a>一维线性 dp 的四边形不等式优化</h2><h3 id="决策单调性"><a href="#决策单调性" class="headerlink" title="决策单调性"></a>决策单调性</h3><p>对于形如 $f[i]&#x3D;\min \limits_{j&#x3D;0} ^{i-1} ( f[j] + val(j,i) )$ 的转移方程，记 $p[i]$ 为令 $f[i]$ 取到最小值的值，即 $f[i]$ 的最优决策。若 $p$ 单调不减，则称 $f$​ 具有决策单调性。</p>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>在状态转移方程 $f[i]&#x3D;\min \limits_{j&#x3D;0} ^{i-1} ( f[j] + val(j,i) )$ 中，若函数 $val$ 满足四边形不等式，则 $f$​ 具有决策单调性。</p>
<h3 id="定理证明-1"><a href="#定理证明-1" class="headerlink" title="定理证明"></a>定理证明</h3><p>$$<br>\begin {aligned} &amp;f[i]&#x3D;\min {f[j]+w(j,i)}\newline \Rightarrow &amp;f[p[i]]+w(p[i],i) \leq f[j]+w(j,i) \space\space\space\space\space (1)\newline &amp;j\leq p[i] \leq i \leq i’ \newline \Rightarrow &amp;w(j,i’)+w(p[i],i)\geq w(j,i)+w(p[i],i’)\newline \Rightarrow &amp;w(j,i’)-w(j,i) \geq w(p[i],i’) - w(p[i],i)\space\space\space\space\space (2)\newline &amp;(1)+(2) \Rightarrow f[j]+w(j,i’) \geq f[p[i]]+w(p[i],i’) \end{aligned}<br>$$</p>
<p>也就是对于 $i’$ 来说，$p[i]$ 比 $j$ 更优，即 $p[i’] \geq p[i]$。</p>
<h3 id="优化过程"><a href="#优化过程" class="headerlink" title="优化过程"></a>优化过程</h3><p>当 $f$ 具有决策单调性时，$p$ 会被分成若干段，使每一段中所有元素的值相同，如下图：</p>
<p><img src="https://s21.ax1x.com/2024/04/20/pkSrqAg.png" alt="pkSrqAg.png"></p>
<p>当我们求出了一个新的 $f[i]$，就可以通过一些操作计算出有哪些 $i’$ 的最优决策是 $p[i]$。</p>
<p>根据决策单调性，我们一定可以找出一个位置 $pos$，使得 $pos$ 之前的所有位置目前存储的决策比 $p[i]$ 更优，而 $pos$ 及以后的所有位置目前存储的决策不比 $p[i]$​ 更优。</p>
<p>我们的目标就变为了找出 $pos$，并把 $pos$ 及以后的所有位置存储的决策更新为 $p[i]$。</p>
<p>直接暴力修改显然会超时，还不如不优化。这时，我们可以借助队列。</p>
<p>我们把 $p$​​​​ 的每一段用一个三元组记录下来：$(p_t,l_t,r_t)$​​​​​，其中 $p$​​​ 记录的是当前存储的决策，$l$​​​ 和 $r$​​​ 分别时这一段的左端点和右端点。设队尾为 $(p_0,l_0,r_0)$​​​。</p>
<p>如果对于 $l_0$​ 来说，$p[i]$​ 比 $p_0$​​​ 更优，则代表我们需要更新这一段存储的决策，直接弹出队尾；</p>
<p>如果对于 $r_0$​​​ 来说，$p_0$​​​ 比 $p[i]$​​​ 更优，则代表我们已经找到了最右的存储决策比 $p[i]$ 更优的点，即 $pos-1$​，把新的三元组 $(p[i],r_0+1,n)$​​ 插入队尾；</p>
<p>否则，进行二分查找，找到 $pos$，更新 $r_0$，把新三元组 $(p[i],pos,n)$​ 插入队尾。</p>
<p>这样，我们就把 $O(n^2)$ 的时间复杂度优化到了 $O(n \log n)$​。</p>
<h2 id="二维区间dp的四边形不等式优化"><a href="#二维区间dp的四边形不等式优化" class="headerlink" title="二维区间dp的四边形不等式优化"></a>二维区间dp的四边形不等式优化</h2><p>朴素的转移方程：$f(i,j)&#x3D;\min \limits_{i \leq k &lt; j} ( f(i,k)+f(k+1,j)+w(i,j) )$</p>
<h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>在转移方程 $f(i,j)&#x3D;\min \limits_{i \leq k &lt; j} ( f(i,k)+f(k+1,j)+w(i,j) )$（$f(i,i)&#x3D;w(i,i)&#x3D;0$）中，如果下面两个条件成立：</p>
<ol>
<li>$w$ 满足四边形不等式；</li>
<li>对于任意的 $a\leq b \leq c \leq d$，有 $w(a,d) \geq w(b,c)$​。</li>
</ol>
<p>那么 $f$ 也满足四边形不等式。</p>
<h3 id="定理2（二维决策单调性）"><a href="#定理2（二维决策单调性）" class="headerlink" title="定理2（二维决策单调性）"></a>定理2（二维决策单调性）</h3><p>在转移方程 $f(i,j)&#x3D;\min \limits_{i \leq k &lt; j} ( f(i,k)+f(k+1,j)+w(i,j) )$（$f(i,i)&#x3D;w(i,i)&#x3D;0$）中，记 $p(i,j)$ 为 $f(i,j)$ 的最优决策。</p>
<p>如果 $f$ 满足四边形不等式，那么对于任意 $i&lt;j$，有 $p(i,j-1) \leq p(i,j) \leq p(i+1,j)$。</p>
<hr>
<p>有了定理2，我们就只需要在 $p(l,r-1) \leq k \leq p(l+1,r)$ 的范围内枚举 $k$，时间复杂度为 $O(n^2)$。</p>
<h2 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h2><h3 id="Luogu-P1880-石子合并"><a href="#Luogu-P1880-石子合并" class="headerlink" title="Luogu P1880 石子合并"></a>Luogu P1880 石子合并</h3><p><a href="https://www.luogu.com.cn/problem/P1880">https://www.luogu.com.cn/problem/P1880</a> $n\leq 5000$​</p>
<h3 id="Luogu-P4767-IOI2000-邮局"><a href="#Luogu-P4767-IOI2000-邮局" class="headerlink" title="Luogu P4767 [IOI2000] 邮局"></a>Luogu P4767 [IOI2000] 邮局</h3><p><a href="https://www.luogu.com.cn/problem/P4767">https://www.luogu.com.cn/problem/P4767</a></p>
<p><strong>题解</strong></p>
<p>转移方程：</p>
<p>$$<br>f[i][j]&#x3D;\min \limits_{k&#x3D;0} ^{i-1} ( f[k][j-1]+w(k+1,i) )<br>$$</p>
<p>其中$f[i][j]$ 表示前 $i$ 个村庄放了 $j$ 个邮局的最小距离和，$w(i,j)$ 表示第 $i$ ~ $j$ 个村庄中放一个邮局的最小距离和。</p>
<p>显然在一个区间中，邮局要放在最中间的那个村庄那里。</p>
<p>$sumx[i]$ 表示前 $i$ 个村庄的坐标和。</p>
<p>对于 $w$：</p>
<p>$$<br>\begin{aligned} &amp;w(i,j)&#x3D;sumx[j]-sumx[(i+j)&#x2F;2]-sumx[(i+j-1)&#x2F;2] + sumx[i-1]\newline \Rightarrow &amp;w(l,r+1)+w(l+1,r)-w(l,r) - w(l+1,r+1)&#x3D;sumx[(l+r+1)&#x2F;2]-sumx[(l+r-1)&#x2F;2]\geq 0\newline \Rightarrow &amp;w(l,r+1)+w(l+1,r) \geq w(l,r)+w(l+1,r+1) \end{aligned}<br>$$</p>
<p>所以 $w$​ 满足四边形不等式。</p>
<p>又因为显然对于任意的 $a\leq b \leq c \leq d$，有 $w(a,d) \geq w(b,c)$，</p>
<p>所以 $f$ 满足四边形不等式，具有二维决策单调性。</p>
<p>时间复杂度为 $O(nV)$。</p>
<h3 id="SPOJ-LARMY"><a href="#SPOJ-LARMY" class="headerlink" title="SPOJ LARMY"></a>SPOJ LARMY</h3><p><a href="https://www.spoj.com/problems/LARMY/">https://www.spoj.com/problems/LARMY/</a></p>
<h1 id="KMP（？）"><a href="#KMP（？）" class="headerlink" title="KMP（？）"></a>KMP（？）</h1><p>主要是思想。</p>
<p>KMP算法中，通过<strong>记录失配指针</strong>减少枚举的量，优化了时间复杂度。AC自动机就运用了这种思路。</p>
<p>扩展KMP算法中，通过<strong>记录最靠右的已经算出的区间</strong>，让待计算的一部分直接使用之前算出的结果，减少了枚举的量，优化了时间复杂度。Manacher也运用了类似的思路。</p>
<h1 id="数据结构优化"><a href="#数据结构优化" class="headerlink" title="数据结构优化"></a>数据结构优化</h1><p>在一些情况下，我们可以用数据结构维护决策的候选集合，从而快速执行插入、查找、删除等操作。</p>
<p>主要是把转移的一部分过程用数据结构优化。</p>
<p>upd on 2023&#x2F;9: 可以看看新写的线段树优化 DP 的博客！</p>
<h2 id="练习题-3"><a href="#练习题-3" class="headerlink" title="练习题"></a>练习题</h2><p>（注意选用好写、适用的数据结构）</p>
<h3 id="Luogu-P1442-铁球落地"><a href="#Luogu-P1442-铁球落地" class="headerlink" title="Luogu P1442 铁球落地"></a>Luogu P1442 铁球落地</h3><p><a href="https://www.luogu.com.cn/problem/P1442">https://www.luogu.com.cn/problem/P1442</a></p>
<p><strong>题解</strong></p>
<p>线段树优化dp。<br>先离散化，预处理出每一块木板左边会掉到那块木板，右边会掉到哪里，再从下往上dp。<br>预处理的时候用线段树优化。</p>
<h3 id="Luogu-P1020-导弹拦截"><a href="#Luogu-P1020-导弹拦截" class="headerlink" title="Luogu P1020 导弹拦截"></a>Luogu P1020 导弹拦截</h3><p><a href="https://www.luogu.com.cn/problem/P1020">https://www.luogu.com.cn/problem/P1020</a></p>
<p><strong>题解</strong></p>
<p>朴素算法的基础上，用树状数组 &#x2F; 线段树维护最优决策。</p>
<h3 id="HBTSC-PRE-2024-花神诞日-sabzeruz"><a href="#HBTSC-PRE-2024-花神诞日-sabzeruz" class="headerlink" title="HBTSC PRE 2024 花神诞日 &#x2F; sabzeruz"></a>HBTSC PRE 2024 花神诞日 &#x2F; sabzeruz</h3><p><a href="https://www.luogu.com.cn/problem/P10200">https://www.luogu.com.cn/problem/P10200</a></p>
<p><strong>题解</strong></p>
<p>一个性质：$a &lt; b &lt; c$ 时，$a \oplus b &gt; \min(a \oplus c,c\oplus b)$。于是排序后可以 dp，记录当前两组的最后分别是什么。发现两组的最后肯定有一个是上一个数，状态数可以压掉一维。用 01-Trie 优化转移，可以做到 $O(n\log V)$。</p>
<h1 id="其他的dp题"><a href="#其他的dp题" class="headerlink" title="其他的dp题"></a>其他的dp题</h1><h2 id="CF1627E-Not-Escaping"><a href="#CF1627E-Not-Escaping" class="headerlink" title="CF1627E Not Escaping"></a>CF1627E Not Escaping</h2><p><a href="https://codeforces.com/problemset/problem/1627/E">https://codeforces.com/problemset/problem/1627/E</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>SA 的 基础 知识</title>
    <url>/2022/08/06/SA/</url>
    <content><![CDATA[<h1 id="SA-的-基础-知识"><a href="#SA-的-基础-知识" class="headerlink" title="SA 的 基础 知识"></a>SA 的 基础 知识</h1><p><del>你问我为什么是基础？因为我还没有学会更难的</del></p>
<h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><h3 id="后缀数组（SA）是什么？"><a href="#后缀数组（SA）是什么？" class="headerlink" title="后缀数组（SA）是什么？"></a>后缀数组（SA）是什么？</h3><p>主要指两个数组：$sa$ 和 $rk$。</p>
<p>$sa$ 存储的是<strong>后缀是什么</strong>，$rk$​ 存储的是<strong>排名是多少</strong>。</p>
<p>$sa[i]$ 代表将所有后缀排序后，排名为 $i$ 的后缀；$rk[i]$ 表示从第 $i$ 个字符开始的后缀的排名。</p>
<p>显然，有性质 $sa[rk[i]]&#x3D;rk[sa[i]]&#x3D;i$。​</p>
<p>知道这两个数组中的一个可以 $O(n)$​ 求出另一个。</p>
<p>下面用 $Sa(i)$​ 表示从第 $i$​ 个字符开始的后缀，$Str(i,j)$​ 表示从第 $i$​ 个字符开始，长度为 $j$​​ 的字符串。</p>
<h3 id="维护方法"><a href="#维护方法" class="headerlink" title="维护方法"></a>维护方法</h3><p><strong>算法一</strong>：暴力求出每一个后缀，存进一个数组里，<code>sort</code> 排序。由于比较两个字符串的大小是 $O(n)$​ 的，所以时间复杂度为 $O(n^2 \log n)$​​​​。</p>
<p><strong>算法二</strong>：</p>
<p>运用倍增的思想，用 $rk_{len}[i]$ 表示的 $Str(i,2 ^{len})$​排名，</p>
<p>可以用 $rk _{len-1}$ 推出 $rk _{len}$。</p>
<p>显然，$Str(i,2 ^{len})$​​​​ 是由 $Str(i,2 ^{len-1})$​​​​ 和 $Str(i + 2 ^{len - 1},2 ^{len - 1})$​​​​​ 两个字符串组成的。</p>
<p>根据字符串大小比较的规则，两个长度为 $len$​ 的字符串的大小为以 $Str(i,2 ^{len - 1})$ 为第一关键字，以 $Str(j,2 ^{len - 1})$ 为第二关键字比较的结果。</p>
<p>因此，按照上述比较规则，将上一次求出的结果进行排序即可得出这一次的结果。</p>
<p>注意，排序后要进行去重，因为两个一样的字符串排名是相等的。</p>
<p>时间复杂度 $O(n \log^2 n)$。</p>
<p>倍增排序示意图（from OI-Wiki）：</p>
<p><img src="https://oi-wiki.org/string/images/sa2.png"></p>
<p><strong>算法三</strong>：可以用<a href="https://oi-wiki.org/basic/radix-sort/">基数排序</a>将算法二优化至 $O(n \log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">2000010</span>];</span><br><span class="line"><span class="type">int</span> rk[<span class="number">2000010</span>],sa[<span class="number">1000010</span>],num[<span class="number">1000010</span>],tmp[<span class="number">2000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    m = <span class="built_in">max</span>(n,<span class="number">250</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cnt[s[i]] ++,rk[i] = s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rk[i]] --] = i;<span class="comment">// 对每个后缀的第一位计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>;len &lt;= n;len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) num[i] = sa[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cnt[rk[num[i] + len]] ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rk[num[i] + len]] --] = num[i];<span class="comment">// 对第二关键字计数排序</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) num[i] = sa[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cnt[rk[num[i]]] ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rk[num[i]]] --] = num[i];<span class="comment">// 对第一关键字计数排序</span></span><br><span class="line">        <span class="type">int</span> no = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) tmp[i] = rk[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[sa[i]] == tmp[sa[i - <span class="number">1</span>]] &amp;&amp; tmp[sa[i] + len] == tmp[sa[i - <span class="number">1</span>] + len])</span><br><span class="line">                rk[sa[i]] = no;</span><br><span class="line">            <span class="keyword">else</span> no ++,rk[sa[i]] = no;</span><br><span class="line">            <span class="comment">// 计算每个字符串的排名</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sa[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法四</strong>：有时间复杂度 $O(n)$​​ 的算法​，但是一般来说算法三够用<del>但是我不会</del></p>
<p>模板：<a href="https://loj.ac/p/111">LOJ #111 后缀排序</a> （Luogu P3809）</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">2000010</span>];</span><br><span class="line"><span class="type">int</span> rk[<span class="number">2000010</span>],sa[<span class="number">1000010</span>],num[<span class="number">1000010</span>],tmp[<span class="number">2000010</span>],rn[<span class="number">2000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    m = <span class="built_in">max</span>(n,<span class="number">250</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cnt[s[i]] ++,rk[i] = s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rk[i]] --] = i;<span class="comment">// 对每个后缀的第一位计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>;len &lt; n;len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> no = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// num[no] 表示按第二关键字排好序后，第 no 位对应的第一关键字 x 的 sa[x] 是什么</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= n - len + <span class="number">1</span>;i --) no ++,num[no] = i;</span><br><span class="line">        <span class="comment">// 后缀长度不满 len，就直接把这个后缀扔到前面去（第二关键字为 0）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="keyword">if</span> (sa[i] &gt; len) no ++,num[no] = sa[i] - len;</span><br><span class="line">        <span class="comment">// 剩下的按第二关键字的顺序把第一关键字排好</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) rn[i] = rk[num[i]],cnt[rn[i]] ++;<span class="comment">// 记录 rk[num[i]]，减少不连续访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rn[i]] --] = num[i];<span class="comment">// 对第一关键字计数排序</span></span><br><span class="line">        no = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) tmp[i] = rk[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[sa[i]] == tmp[sa[i - <span class="number">1</span>]] &amp;&amp; tmp[sa[i] + len] == tmp[sa[i - <span class="number">1</span>] + len])</span><br><span class="line">                rk[sa[i]] = no;</span><br><span class="line">            <span class="keyword">else</span> no ++,rk[sa[i]] = no;</span><br><span class="line">            <span class="comment">// 处理 rk</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (no == n) <span class="keyword">break</span>;<span class="comment">// 如果每个后缀的排名都不一样了，意味着排好了（这之后每个后缀的排名都不会变）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sa[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h4><p>即在主串 $T$ 中寻找模式串 $S$​。</p>
<p><strong>解法</strong>：</p>
<p>若 $S$ 在 $T$ 中出现，那么它一定是一些后缀的前缀。</p>
<p>由于已经将后缀通过后缀数组有序化，那么前缀为 $S$ 的后缀一定是连续的，直接二分查找即可。时间复杂度 $O(n \log n + \log n)$，可以求出 $S$ 的每个出现位置。</p>
<hr>
<h4 id="Luogu-P4051-JSOI-字符加密"><a href="#Luogu-P4051-JSOI-字符加密" class="headerlink" title="Luogu P4051  [JSOI]字符加密"></a><a href="https://www.luogu.com.cn/problem/P4051">Luogu P4051  [JSOI]字符加密</a></h4><p>喜欢钻研问题的JS 同学，最近又迷上了对加密方法的思考。一天，他突然想出了一种他认为是终极的加密办法：把需要加密的信息排成一圈，显然，它们有很多种不同的读法。</p>
<p>例如‘JSOI07’，可以读作： JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 把它们按照字符串的大小排序： 07JSOI 7JSOI0 I07JSO JSOI07 OI07JS SOI07J 读出最后一列字符：I0O7SJ，就是加密后的字符串。给定一个字符串 $S$，求加密后的字符串。</p>
<p>对于 $40 %$ 的数据，$\left| s \right| \leq 10000$；</p>
<p>对于所有数据，$\left| s \right| \leq 10^5$。</p>
<p><strong>解法</strong>：</p>
<p>将字符串复制一遍到后面，就变成了普通的后缀排序问题。</p>
<hr>
<h4 id="Luogu-P2870-USACO07DEC-Best-Cow-Line-G"><a href="#Luogu-P2870-USACO07DEC-Best-Cow-Line-G" class="headerlink" title="Luogu P2870 [USACO07DEC]Best Cow Line G"></a><a href="https://www.luogu.com.cn/problem/P2870">Luogu P2870 [USACO07DEC]Best Cow Line G</a></h4><p>给你一个字符串，每次从首或尾取一个字符组成字符串，问所有能够组成的字符串中字典序最小的一个。</p>
<p>$1 \leq N \leq 5\times 10^5$。</p>
<p><strong>解法</strong>：</p>
<p>考虑暴力做法，每次从头选还是从尾选只需要判断原串小还是反串小，选小的那个更优，$O(n)$ 判断，总时间复杂度 $O(n^2)$。</p>
<p>考虑优化判断过程。</p>
<h3 id="height-数组"><a href="#height-数组" class="headerlink" title="$height$ 数组"></a>$height$ 数组</h3><h4 id="lcp"><a href="#lcp" class="headerlink" title="$lcp$"></a>$lcp$</h4><p>$lcp(i,j)$ 表示字符串 $i$ 和 $j$​ 的最长公共前缀。</p>
<p>下文中用 $lcp(i,j)$ 表示它们的最长公共前缀长度。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>$height_i$ 表示 $lcp(sa[i - 1],sa[i])$。</p>
<h4 id="求-height-数组"><a href="#求-height-数组" class="headerlink" title="求 $height$ 数组"></a>求 $height$ 数组</h4><p>有一个定理：$height_{rk[i]} \geq height_{rk[i - 1]} - 1$。</p>
<p>证明：</p>
<p>定义 $Suffix(x)$ 为排名为 $x$ 的后缀，$S(x)$ 表示以第 $x$ 个字符开头的后缀。</p>
<p>设已知 $height_{rk[i - 1]}$。</p>
<p>若 $height_{rk[i - 1]} \leq 1$，上式成立；</p>
<p>若 $height_{rk[i - 1]} &gt; 1$：</p>
<p>设 $Suffix(rk[i - 1])$ 为 <code>aAC</code>，$Suffix(rk[i - 1] - 1)$ 为 <code>aAB</code>，且 $lcp(B,C) &#x3D; 0$，$B &lt; C$，则 $height_{rk[i - 1]} &#x3D; 1+|A|$。</p>
<p>而 $S(i)$ 为 <code>AC</code>，$S(sa[rk[i - 1] - 1] + 1)$ 即 $Suffix(rk[i - 1] - 1)$ 在原串中的后一个后缀为 <code>AB</code>，</p>
<p>所以 $S(sa[rk[i - 1] - 1] + 1)$ 肯定在 $S(i)$ 前面。</p>
<p>所以 $lcp(s(i),s(sa[rk[i] - 1])) \geq |A| &#x3D; height_{rk[i - 1]} - 1$，即它们的最大公共前缀有一个前缀为 <code>A</code>。</p>
<h4 id="height-数组求-lcp"><a href="#height-数组求-lcp" class="headerlink" title="$height$ 数组求 $lcp$"></a>$height$ 数组求 $lcp$</h4><p>有一个定理：$lcp(sa_i,sa_j) &#x3D; \min \limits _{k&#x3D;i + 1} ^j { height_k }$。</p>
<p>证明：感性理解一下，由于后缀已经排好了序，两个后缀的排名差越大，$lcp$ 就越小，</p>
<p>$lcp(sa_{i},sa_{i+2}) &#x3D; \min { height_{i + 1},height_{i + 2} }$。</p>
<hr>
<p>有了这个定理，两个<strong>子串</strong>求 $lcp$ 就变成了区间求最小值（RMQ）问题。通常用 ST 表解决，或者观察题目性质，或者其他数据结构。</p>
<p>$lcp(Str(l_1,r_1),Str(l_2,r_2)) &#x3D; \min { lcp(S(l_1),S(l_2)), (r_1 - l_1 + 1),(r_2 - l_2 + 1) }$。</p>
<p><a href="https://oi-wiki.org/string/sa/">https://oi-wiki.org/string/sa/</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>笔记</tag>
        <tag>后缀数组（SA）</tag>
      </tags>
  </entry>
  <entry>
    <title>《语言引论》第一章 阅读笔记</title>
    <url>/2025/01/16/an-introduction-to-language-note-1/</url>
    <content><![CDATA[<h1 id="1-语言知识"><a href="#1-语言知识" class="headerlink" title="1 语言知识"></a>1 语言知识</h1><p>语言由全部的语音、词汇和无限多的可能句子构成，掌握一门语言即掌握该语言的语音、词汇及组合规则。</p>
<h2 id="1-1-语音系统的知识"><a href="#1-1-语音系统的知识" class="headerlink" title="1.1 语音系统的知识"></a>1.1 语音系统的知识</h2><ul>
<li><p>知道一种语言中哪些<strong>音或手势</strong>有，哪些没有。</p>
</li>
<li><p>知道哪些音在词首，哪些在词尾，哪些前后相继。</p>
</li>
</ul>
<h2 id="1-2-词的知识"><a href="#1-2-词的知识" class="headerlink" title="1.2 词的知识"></a>1.2 词的知识</h2><ul>
<li>知道特定的语音序列表达特定的概念或<strong>意义</strong>，即<strong>词</strong>。</li>
</ul>
<h3 id="1-2-1-形式和意义之间的任意关系"><a href="#1-2-1-形式和意义之间的任意关系" class="headerlink" title="1.2.1 形式和意义之间的任意关系"></a>1.2.1 形式和意义之间的任意关系</h3><ul>
<li><p>形式即声音或手势，意义即概念</p>
</li>
<li><p>大体上<strong>任意的</strong>：人为赋予词的语音以意义；手语也在发展中，由和哑剧一样的不任意变得约定俗成。</p>
</li>
<li><p><strong>不任意</strong>：语音象征（发音暗示其意义），如拟声词、某些特定语音序列与一个特定的概念相联系。</p>
</li>
<li><p>词要组成短语和句子。</p>
</li>
</ul>
<h2 id="1-3-语言知识的创造性"><a href="#1-3-语言知识的创造性" class="headerlink" title="1.3 语言知识的创造性"></a>1.3 语言知识的创造性</h2><ul>
<li><p>指能够<strong>创造新的句子</strong>，同时能<strong>理解别人创造的新句子</strong>。</p>
</li>
<li><p>并非只限于刺激-反应行为（驳斥 20 世纪前半叶的行为主义语音观）</p>
</li>
<li><p>体现：句子数量无限，句子长度上限无限。</p>
</li>
</ul>
<h2 id="1-4-句与非句的知识"><a href="#1-4-句与非句的知识" class="headerlink" title="1.4 句与非句的知识"></a>1.4 句与非句的知识</h2><ul>
<li>判断词串是否构成合式的句子的<strong>规则</strong>。</li>
</ul>
<h1 id="2-语言知识和语言运用"><a href="#2-语言知识和语言运用" class="headerlink" title="2 语言知识和语言运用"></a>2 语言知识和语言运用</h1><ul>
<li><p>语言能力：掌握的<strong>知识</strong>。</p>
</li>
<li><p>语言<strong>运用</strong>：如何将知识用于实际的言语产出与理解。</p>
</li>
<li><p>传递信息时会发生曲解、<strong>口误</strong>。</p>
</li>
<li><p>大体上，语言知识不是一种自觉的知识，语言系统都是不知不觉中学会的。</p>
</li>
</ul>
<h1 id="3-语法是什么？"><a href="#3-语法是什么？" class="headerlink" title="3 语法是什么？"></a>3 语法是什么？</h1><h2 id="3-1-描写语法"><a href="#3-1-描写语法" class="headerlink" title="3.1 描写语法"></a>3.1 描写语法</h2><ul>
<li><p>包括把语音组合成词的规则（称为<strong>音系</strong>），构词规则（称为<strong>形态</strong>），将词组合成短语、短语组合成句子的规则（称为<strong>句法</strong>），以及指派语义的规则（称为<strong>语义</strong>）。</p>
</li>
<li><p>“语法”的两种用法：<strong>心理语法</strong>， 即说话者头脑中的该语言的规则；<strong>描写语法</strong>，即语言学家对于不同说话者之间的共享知识的模型。</p>
</li>
<li><p>描写语法只是一种解释，而不是告诉你话应该怎么说。</p>
</li>
<li><p><strong>合乎语法</strong>：符合语言学家所描述的心里语法的规则。不同的语言变体（<strong>方言</strong>）的心里语法有所不同，没有高低之分。</p>
</li>
</ul>
<h2 id="3-2-规定语法"><a href="#3-2-规定语法" class="headerlink" title="3.2 规定语法"></a>3.2 规定语法</h2><ul>
<li><p>“纯语主义者”：坚信一种语言的某些说法优于另一些说法，希望<strong>规定</strong>而不是描写语法规则。力图改变使用者已经掌握的语言规则或用法。</p>
</li>
<li><p>文艺复兴时期，罗伯特·洛恩规定了一系列英语的新规则，从而有许多新规则进入了权势人物使用的语言变体——<strong>优势方言</strong>中。</p>
</li>
<li><p>但是语言随着时间的推移而演变，词义也在演变。所有的语言和方言都受到规则的制约，并无高低贵贱之分。</p>
</li>
<li><p><strong>标准方言</strong>。</p>
</li>
<li><p>以上都针对口语。文字要遵循某些口语不需要遵循的规范性规则，且很少受方言变体的影响。</p>
</li>
</ul>
<h2 id="3-3-教学语法"><a href="#3-3-教学语法" class="headerlink" title="3.3 教学语法"></a>3.3 教学语法</h2><ul>
<li><p>用来学习另一种语言或方言。</p>
</li>
<li><p>假定学生已经掌握一种语言，将目标语的语法与学生母语的语法进行比较。</p>
</li>
<li><p>目的与规定语法不同。</p>
</li>
</ul>
<h1 id="4-语言共相"><a href="#4-语言共相" class="headerlink" title="4 语言共相"></a>4 语言共相</h1><ul>
<li><p><strong>普遍语法（UG）</strong>：所有语言普遍属性的规则，是人类与生俱来的语言机能的一部分，提供了一切语言都要遵循的基本蓝图。</p>
</li>
<li><p><strong>语言学理论</strong>的一个主要目的为探索 UG 的属性。对多种语言进行比较研究的重要性特别突出。</p>
</li>
</ul>
<h2 id="4-1-语法之发展"><a href="#4-1-语法之发展" class="headerlink" title="4.1 语法之发展"></a>4.1 语法之发展</h2><ul>
<li><p>儿童学习语言的方法大体一致，刚开始每次只用一个词，然后才组成简单的句子；刚开始造句时，某些成分可能会漏掉。然后形成<strong>词库</strong>。</p>
</li>
<li><p>儿童语言习得过程的一致性 $\rightarrow$ 普遍语法。</p>
</li>
</ul>
<h2 id="4-2-手语：语言天赋机制的证据"><a href="#4-2-手语：语言天赋机制的证据" class="headerlink" title="4.2 手语：语言天赋机制的证据"></a>4.2 手语：语言天赋机制的证据</h2><ul>
<li><p>学习手语的儿童与正常儿童学习口语经历的阶段有平行关系。</p>
</li>
<li><p>语言习得并不依赖于发音和听音的能力，而是依赖一种<strong>由生物机制决定</strong>、抽象程度高得多的认知能力。</p>
</li>
</ul>
<h3 id="4-2-1-美国手语"><a href="#4-2-1-美国手语" class="headerlink" title="4.2.1 美国手语"></a>4.2.1 美国手语</h3><ul>
<li>手势符号不同于拼写的单词，不能作为一个序列分解为若干独立的手部构型，是一个<strong>连续的整体</strong>。</li>
</ul>
<h1 id="5-动物“语言”"><a href="#5-动物“语言”" class="headerlink" title="5 动物“语言”"></a>5 动物“语言”</h1><ul>
<li><p>鹦鹉的例子 $\rightarrow$ 模仿人类说话，但不会将模仿的音切分成离散的单位（人类语言的一个特征<strong>离散性</strong>）；将语音序列与具体东西一一联系，但不能与儿童习得复杂人类语言的能力相提并论。</p>
</li>
<li><p>蜘蛛和招潮蟹的动作 $\rightarrow$ 同样的动作从不改变，且只传达一种意义。</p>
</li>
<li><p>鸟类和蜜蜂 $\rightarrow$ 能够传递无限多的不同信息，但只局限于表达一种主题，且无法传递信息中的特殊情景。</p>
</li>
<li><p><strong>主要区别</strong>：只是对外部甚至内部刺激的反应。</p>
</li>
</ul>
<h1 id="6-认知和思维"><a href="#6-认知和思维" class="headerlink" title="6 认知和思维"></a>6 认知和思维</h1><ul>
<li><p><strong>萨丕尔-沃尔夫假说</strong>：认为语言结构影响说这种语言的人对周围世界的感知。</p>
</li>
<li><p>最强形式为<strong>语言决定论</strong>：语言决定人对世界的感知和思考。是错误的。</p>
</li>
<li><p>一个温和形式为<strong>语言相对论</strong>：不同的语言对不同的范畴编码，因此说不同语言的人对世界的思考有不同的方式。例子：对颜色、方位的表达；语法上的性影响说话者对事物的思考；政治正确。</p>
</li>
<li><p>特定世界中的经验产生对某些词的需要。</p>
</li>
<li><p>语言在一定程度上影响人类认知的其他方面，如记忆和范畴化。</p>
</li>
</ul>
<h1 id="7-我们对语言的了解-8-小结"><a href="#7-我们对语言的了解-8-小结" class="headerlink" title="7 我们对语言的了解 &amp; 8 小结"></a>7 我们对语言的了解 &amp; 8 小结</h1><p>总结前文。</p>
]]></content>
      <categories>
        <category>语言学</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>语言学</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Beginner Contest 349 G. Palindrome Construction 题解</title>
    <url>/2024/04/15/atcoder-beginner-contest-349-g/</url>
    <content><![CDATA[<p>努力更新！</p>
<p>类似的题目：</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3295">[SCOI2016] 萌萌哒</a>；</li>
<li><a href="https://codeforces.com/gym/103388/problem/L">2021-2022 ACM-ICPC Brazil Subregional Programming Contest L. Listing Passwords</a></li>
</ul>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>定义一个序列 $T &#x3D; (T_1,T_2,\cdots,T_M)$ 是回文的，当且仅当 $\forall i &#x3D; 1,2,\cdots,M : T_i &#x3D; T_{M - i + 1}$，即翻转过来之后一样。</p>
<p>给定一个长度为 $N$ 的序列 $A$，问是否存在一个长度为 $N$ 的序列 $S$，使得：</p>
<ul>
<li>对于所有 $i &#x3D; 1,2,\cdots,N$，$(S_{i - A_i},S_{i - A_i + 1},\cdots,S_{i + A_i - 1},S_{i + A_i})$ 是回文的，且 $(S_{i - A_i - 1},\cdots,S_{i + A_i + 1})$ 不是回文的。</li>
</ul>
<p>如果存在，输出字典序最小的一个。</p>
<p>$1 \le N \le 2 \times 10 ^ 5$，$0 \le A_i \le \min{i - 1,N - i}$。</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>看见这个限制，容易想到并查集。发现每个限制是两端长度相等的区间合并，考虑用倍增优化。</p>
<p>类似 <a href="https://www.luogu.com.cn/problem/P3295">[SCOI2016] 萌萌哒</a>，可以建 $O(\log n)$ 层并查集，把两段区间类似 ST 表合并起来，最后一层一层下传，就把每个点和其他点的关系求出来了。</p>
<p>具体地，第 $i$ 层并查集中，$j$ 这个点代表 $[j,j + 2^i - 1]$ 这个区间。由于合并这个操作是可重复贡献的，合并两段区间 $[L_1,R_1]$ 和 $[L_2,R_2]$ 相当于在第 $k$ 层分别合并 $[L_1,L_1 + 2^k - 1]$ 和 $[L_2,L_2 + 2 ^ k - 1]$ 以及合并 $[R_1 - 2 ^ k + 1,R_1]$ 和 $[R_2 - 2 ^ k + 1,R_2]$，这里的 $k&#x3D;\lfloor \log _{2} (R_1 - L_1 + 1) \rfloor$。对于下传操作，如果第 $i$ 层中，$[L_1,R_1]$ 和 $[L_2,R_2]$ 在一个并查集里，则在第 $(i - 1)$ 层中，它们的前一半和后一半分别在两个个并查集里。所以，此时要分别合并它们的前一半和后一半。每次合并的时间复杂度是 $O(1)$，下传只需要对每一层，枚举每个区间，时间复杂度是 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fnd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;<span class="keyword">return</span> fa[k][x] = (fa[k][x] == x ? x : <span class="built_in">fnd</span>(fa[k][x],k));&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span> <span class="comment">// 在第 k 层上合并 [l, l + 2^k - 1] 和 [r, r + 2^k - 1]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// printf(&quot;*Merge %d %d %d\n&quot;,l,r,k);</span></span><br><span class="line">	l = <span class="built_in">fnd</span>(l,k),r = <span class="built_in">fnd</span>(r,k);</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span> (l &lt; r) <span class="built_in">swap</span>(l,r);</span><br><span class="line">	fa[k][l] = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> ll,<span class="type">int</span> len)</span> <span class="comment">// 合并 [l, l + len - 1] 和 [ll, ll + len - 1]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// printf(&quot;merge %d %d %d\n&quot;,l,ll,len);</span></span><br><span class="line">	<span class="keyword">if</span> (l == ll) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> r = l + len - <span class="number">1</span>,rr = ll + len - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> L = (len == <span class="number">1</span> ? <span class="number">0</span> : <span class="built_in">log2</span>(len));</span><br><span class="line">	<span class="built_in">Merge</span>(l,ll,L);</span><br><span class="line">	<span class="built_in">Merge</span>(r - (<span class="number">1</span> &lt;&lt; L) + <span class="number">1</span>,rr - (<span class="number">1</span> &lt;&lt; L) + <span class="number">1</span>,L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于合并的两端区间一个是从前往后的，一个是从后往前的，可以把整个序列反过来拼在后面，把其中一个区间翻到后一半，顺序就一样了。这样就可以直接用上面的东西做了。</p>
<p>在算出点与点之间的关系后，只需要对于每个 $i$，判断 $(i - A_i - 1)$ 和 $(i + A_i + 1)$ 在不在一个并查集里面就行了。最后要输出字典序最小的解，只需要贪心地从前往后放当前能放的、不矛盾的最小数就行了。判断矛不矛盾可以直接暴力做，因为总共只有 $O(n)$ 条这样的限制。</p>
<p>合并的总时间复杂度是 $O(n)$，下传是 $O(n \log n)$，求解是 $O(n)$，总时间复杂度为 $O(n \log n)$。</p>
<p><a href="https://atcoder.jp/contests/abc349/submissions/52398116">AC 提交记录</a>。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Beginner Contest 351 G. Hash on Tree 题解</title>
    <url>/2024/04/28/atcoder-beginner-contest-351-g/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/AT_abc351_g">洛谷</a>，<a href="https://atcoder.jp/contests/abc351/tasks/abc351_g">AtCoder</a>。</p>
<p>赛时想出来的动态 DP 做法，但是赛时没调完。</p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一棵 $N$ 个点的有根树，编号为 $1$ 到 $N$，根节点为 $1$，点 $i$ 的父亲是 $p_i\space (p_i &lt; i)$。</p>
<p>有一个序列 $a&#x3D;(a_1,a_2,\cdots,a_N)$，初始值给定。定义函数 $f(x)$ 如下：</p>
<ul>
<li><p>如果 $x$ 是叶子，则 $f(x) &#x3D; a_x$；</p>
</li>
<li><p>否则 $f(x) &#x3D; a_x + \prod \limits_{c \in son(x)} f ( c ) $。</p>
</li>
</ul>
<p>定义这棵树的值为 $f(1) \operatorname{mod} 998244353$。</p>
<p>有 $Q$ 次询问，每次将 $a_x$ 改为 $y$，询问当前树的值。</p>
<p>$2 \le N \le 2 \times 10 ^ 5$，$1 \le Q \le 2 \times 10^5$，$0 \le a_i,y &lt; 998244353$。</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>发现 $f(x)$ 的值由它的儿子转移得来，可以 DP 求出刚开始的所有 $f(x)$。观察到每次修改只会影响到修改的点到根路径上的 $f(x)$ 值。</p>
<p>对于一个点 $u$，有$f(p_u) &#x3D; a_{p_u} + f(u) \prod \limits_{c\in son(p_u) \operatorname{and} c \ne u} f ( c ) $。如果 $f(u)$ 被修改了，这个式子中的其他部分并不会改变。也就是说，对于一条往上走的链，设这条链的底部是点 $v$，那么这条链的值写出来形如 $A_k(A_{k-1}(\cdots(A_1 f(v) + B_1) \cdots) + B_{k - 1}) + B_k$，也就是若干个 $Ax + B$ 嵌套起来。这种形式让我们想到可以用矩阵表示这样的转移，用线段树维护矩阵的区间积，而修改一个点的 $a_x$ 只需要修改它对应的一个矩阵就行了。</p>
<p>现在要把链的做法放到树上。考虑树链剖分，一个点的 $f$ 先算出轻儿子的贡献，再从重儿子直接转移过来。记这个点为 $u$，重儿子为 $v$，对应到上面的 $Ax + B$，也就是 $A &#x3D; \prod \limits_{c\in son(u) \operatorname{and} c\ne v} f ( c ) $，$x &#x3D; f(v)$，$B &#x3D; a_u$。把转移写成矩阵形式如下：</p>
<p>$$<br>\left[ \begin{matrix} f(v) &amp; 1 \end{matrix} \right] \times \left[ \begin{matrix} \prod \limits_{c\in son(u) \operatorname{and} c\ne v} f ( c )  &amp; 0 \newline a_u &amp; 1 \end{matrix} \right] &#x3D; \left[ \begin{matrix} f(u) &amp; 1 \end{matrix} \right]<br>$$</p>
<p>每次修改时，要修改被修改的点的矩阵的左下角，以及每次跳轻边的时候，要修改新算出来的链头父亲的矩阵左上角，总共 $O(\log n)$ 次修改。对于一个点 $u$，$f(u)$ 也就是把 $u$ 开始的重链拉出来，从下到上求一次矩阵乘法，左下角的值。这里可以按 dfn 建一棵维护矩阵的区间乘积的线段树，支持单点修改和区间查询，注意矩阵乘法的顺序。</p>
<p>跳轻边时，矩阵左上角的值可以除以之前链头贡献的值，再乘上新的链头的 $f$ 求出来。注意题目数据中存在先把一个点赋值为 $0$，再改成非 $0$ 值的情况，不能只维护当前的矩阵左上角的值，否则还原不回去。可以对每个点，记录儿子中有多少个 $0$ 以及非 $0$ 儿子的乘积，如果儿子中有 $0$，则矩阵左上角也为 $0$，否则为儿子的积。</p>
<p>总时间复杂度为 $O(Kn \log n + QK \log n (\log n +  \log 998244353))$。这里的 $K$ 是矩阵乘法的复杂度，$\log 998244353$ 是因为我在算新的矩阵左上角的值时用了逆元。</p>
<p><a href="https://atcoder.jp/contests/abc351/submissions/52901323">AC 提交记录</a>。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
        <tag>DP</tag>
        <tag>树链剖分</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>DP 套 DP 学习笔记</title>
    <url>/2024/04/16/dp-of-dp/</url>
    <content><![CDATA[<p>努力更新 x 2（</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>DP 套 DP 顾名思义，就是在一层 DP（或者自动机）外面再套一层，把里面的 DP（或自动机）的<strong>结果</strong>作为外层 DP 的<strong>状态</strong>，从而更方便地转移。</p>
<p>这么说好像很抽象，我也不知道自己在说什么，还是看题目吧 qwq</p>
<h1 id="例题：-TJOI2018-游园会"><a href="#例题：-TJOI2018-游园会" class="headerlink" title="例题：[TJOI2018] 游园会"></a>例题：[TJOI2018] 游园会</h1><p>题目链接：<a href="https://www.luogu.com.cn/problem/P4590">https://www.luogu.com.cn/problem/P4590</a></p>
<p>题目要算的字符串总共有三种限制：长度为 $N$，不出现子串 <code>NOI</code>，以及最难搞的和奖章串的最长公共子序列长为 $i$。而且对于每一个 $i$ 都要算一次，如果直接算复杂度就爆炸了。</p>
<p>考虑 DP，状态 $f_{i,j,k}$ 表示现在构造到第 $i$ 位，与兑奖串的最长公共子序列长为 $j$，当前后缀出现了 <code>NOI</code> 的前 $k$ 位时的兑奖串个数，是一个计数 DP。这样 DP 看起来很对，但是有一个地方有问题：维护 $j$ 的时候，没有维护当前扫到了奖章串的哪一位，导致我们不知道现在构造的第 $i$ 位应该和奖章串的哪一个字符比较。于是状态应该是 $f_{i,(g_1,g_2,\cdots,g_K),k}$，其中 $i$ 和 $k$ 的含义同上，$K$ 是奖章串长度，中间的 $(g_1,g_2,\cdots,g_K)$ 代表当前扫到奖章串的第 $1,2,\cdots,K$ 位时，最长公共子序列长是多少。在转移的时候，枚举第 $i$ 位填什么，$g$ 数组就是一个单独的 DP，也就是<strong>内层 DP</strong>。而 $f$ 数组的转移就是<strong>外层 DP</strong>。</p>
<p>但是这样的状态根本存不下。观察一下 $g$ 数组有什么性质，发现它的差分数组全是 $0$ 和 $1$，且 $K$ 很小，可以状压。这样状态数就变成了 $O(NK2^K)$。转移的时候直接枚举 $i$、状压后的差分数组、 $k$ 和接下来填的字母，时间复杂度 $O(NK2^K)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,K;</span><br><span class="line"><span class="type">char</span> s[<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> g[<span class="number">20</span>],gg[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][<span class="number">33000</span>][<span class="number">3</span>],ans[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= K;i ++)</span><br><span class="line">		a[i] = (s[i] == <span class="string">&#x27;N&#x27;</span> ? <span class="number">0</span> : s[i] == <span class="string">&#x27;O&#x27;</span> ? <span class="number">1</span> : <span class="number">2</span>);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++,p ^= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; (<span class="number">1</span> &lt;&lt; K);j ++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">2</span>;k ++)</span><br><span class="line">				f[p][j][k] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; (<span class="number">1</span> &lt;&lt; K);j ++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= K;k ++)</span><br><span class="line">				g[k] = g[k - <span class="number">1</span>] + (j &gt;&gt; (k - <span class="number">1</span>) &amp; <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">2</span>;k ++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>;w &lt;= K;w ++)</span><br><span class="line">					gg[w] = <span class="built_in">max</span>(<span class="built_in">max</span>(gg[w - <span class="number">1</span>],g[w]),g[w - <span class="number">1</span>] + (k == a[w]));</span><br><span class="line">				<span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> w = K;w &gt;= <span class="number">1</span>;w --) tmp = (tmp &lt;&lt; <span class="number">1</span> | (gg[w] - gg[w - <span class="number">1</span>]));</span><br><span class="line">				<span class="comment">// 以上是内层 DP 以及把算出来的新 g 数组状压</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> nw = <span class="number">0</span>;nw &lt;= <span class="number">2</span>;nw ++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (nw == <span class="number">2</span> &amp;&amp; k == <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">					(f[p][tmp][(k == nw ? nw + <span class="number">1</span> : (!k ? <span class="number">1</span> : <span class="number">0</span>))] += f[p ^ <span class="number">1</span>][j][nw]) %= mod;</span><br><span class="line">					<span class="comment">// 外层 DP 的转移</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	p ^= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; (<span class="number">1</span> &lt;&lt; K);i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= K;j ++)</span><br><span class="line">			g[j] = g[j - <span class="number">1</span>] + (i &gt;&gt; (j - <span class="number">1</span>) &amp; <span class="number">1</span>);</span><br><span class="line">		(ans[g[K]] += ((f[p][i][<span class="number">0</span>] + f[p][i][<span class="number">1</span>]) % mod + f[p][i][<span class="number">2</span>]) % mod) %= mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= K;i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，DP 套 DP 这个名字确实很形象。</p>
<h1 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h1><h2 id="ZJOI2019-麻将"><a href="#ZJOI2019-麻将" class="headerlink" title="[ZJOI2019] 麻将"></a>[ZJOI2019] 麻将</h2><p>题目链接：<a href="https://www.luogu.com.cn/problem/P5279">https://www.luogu.com.cn/problem/P5279</a></p>
<p>这道题的内层 DP 是个自动机 <del>，我还没有搞懂，先放在这里（</del></p>
<h2 id="SDOI-SXOI2022-小-N-的独立集"><a href="#SDOI-SXOI2022-小-N-的独立集" class="headerlink" title="[SDOI&#x2F;SXOI2022] 小 N 的独立集"></a>[SDOI&#x2F;SXOI2022] 小 N 的独立集</h2><p>题目链接：<a href="https://www.luogu.com.cn/problem/P8352">https://www.luogu.com.cn/problem/P8352</a></p>
<p>像上面的例题一样，可以搞一个计数 DP，$f_{i,j,k}$ 代表以 $i$ 为根的子树中，选 $i$ 和不选 $i$ 的答案分别是 $j$ 和 $k$ 的数量。状态和转移的时间复杂度还是一如既往地爆炸。观察一下 $j$ 和 $k$ 之间的关系，发现如果 $j \le k$，那 $j$ 没有一点用；否则 $j - k \le K$（这里的 $K$ 就是原题面的 $k$），不然的话可以通过从选 $i$ 的最优方案中去掉 $i$ 创造出一种新的、比当前最优的不选 $i$ 的方案更优的方案，产生矛盾。这样就可以换一种状态表示，$f_{i,j,k}$ 表示以 $i$ 为根的子树中，不选 $i$ 和选不选 $i$ 都行（也就是上面 $j$ 和 $k$ 的较大值）的答案分别是 $j$ 和 $k$。由于 $k \ge j$ 且 $0\le k - j \le K$，可以把状态写成 $f_{i,j,k - j}$，状态数变成 $O(n^2K^2)$。根据<a href="https://oi-wiki.org/dp/tree/#%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85">树上背包</a>的时间复杂度分析，总的时间复杂度是 $O(n^2K^4)$，因为还要枚举每个点填什么。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,K;</span><br><span class="line"><span class="type">int</span> to[<span class="number">2010</span>],nxt[<span class="number">2010</span>],head[<span class="number">1010</span>],cnt;</span><br><span class="line"><span class="type">int</span> siz[<span class="number">1010</span>],f[<span class="number">1010</span>][<span class="number">5010</span>][<span class="number">7</span>],ff[<span class="number">1010</span>][<span class="number">5010</span>][<span class="number">7</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">5010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	to[++ cnt] = y;</span><br><span class="line">	nxt[cnt] = head[x];</span><br><span class="line">	head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> la)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	siz[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= K;i ++) f[x][<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u = to[i];</span><br><span class="line">		<span class="keyword">if</span> (u == la) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(u,x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= siz[x] * K;j ++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt;= K;k ++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (!f[x][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="type">int</span> valx1 = j,valx2 = j + k;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>;l &lt;= siz[u] * K;l ++)</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>;w &lt;= K;w ++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> (!f[u][l][w]) <span class="keyword">continue</span>;</span><br><span class="line">						<span class="type">int</span> valu1 = l,valu2 = l + w;</span><br><span class="line">						<span class="type">int</span> newval1 = valx1 + valu2,newval2 = valx2 + valu1;</span><br><span class="line">						newval2 = <span class="built_in">max</span>(newval2,newval1);</span><br><span class="line">						(ff[x][newval1][newval2 - newval1] += <span class="number">1ll</span> * f[x][j][k] * f[u][l][w] % mod) %= mod;</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		siz[x] += siz[u];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= siz[x] * K;j ++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt;= K;k ++)</span><br><span class="line">				f[x][j][k] = ff[x][j][k],ff[x][j][k] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">		<span class="built_in">add</span>(x,y),<span class="built_in">add</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n * K;i ++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= K;j ++)</span><br><span class="line">			ans[i + j] = (ans[i + j] + f[<span class="number">1</span>][i][j]) % mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n * K;i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（DP 套 DP 的代码好像还挺好写的？直接按照算法流程写就行了）</p>
<p>其他题目待补 qwq</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Regular Contest 171 全场题解</title>
    <url>/2024/04/05/atcoder-regular-contest-171/</url>
    <content><![CDATA[<p>某天 vp 了一下这场比赛，题解拖到了现在（）</p>
<p>赛时做出了前三题，第四题写挂了 ovo</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个 $N \times N$ 的国际象棋棋盘，需要在上面放上 $A$ 个车和 $B$ 个兵，车可以吃同行同列的棋子，兵可以吃在同列且在它上一行的棋子，问是否存在放法，使得这 $A + B$ 个棋子互相不能吃到，有多测。</p>
<p>$1 \le T \le 10^5$，$1 \le N \le 10^4$，$0 \le A,B$，$1 \le A + B \le N ^ 2$。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>一行一列中最多放一个车，所以车的上界是 $N$。</p>
<p>同时，放了车的行和列不能有兵，所以放了兵的行和列上界都为 $N - A$。</p>
<p>由于兵的限制只和上一行有关，可以贪心地对于每一行，把能放兵的位置放满。此时下一行就放不了了，所以放兵的行还有一个上界 $\lfloor \frac{N + 1}{2} \rfloor$。</p>
<p>综合起来，兵的上界就为 $\min(N - A,\lfloor \frac {N + 1}{2} \rfloor) \times (N - A)$。</p>
<p>考虑构造。发现任意两列是可以任意交换的，只考虑行。放兵的行的上一列放不了棋子，考虑尽量让放兵的行和放车的行间隔起来。具体地，先把车放在奇数行，放完再从上到下放偶数行，再把兵放在空出来的行。</p>
<p>考虑证明。若车的数量不足以占领所有奇数行，那么放兵相当于没有限制地放，可以达到上界 $\lfloor \frac{N + 1}{2} \rfloor$。若车的数量够占领奇数行，那么剩下的行都可以放车，可以达到上界 $N - A$。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>对于一个 $[1,N]$ 的排列 $P$，定义 $F(P)$ 为这个排列经过以下操作后生成的排列 $B$：</p>
<ul>
<li>排列 $B$ 初始为 $(1,2,\cdots,N)$。<br>如果有一个最小的数 $i$ 满足 $B_i &lt; P_{B_i}$，则 $B_i \leftarrow P_{B_i}$。</li>
</ul>
<p>给定一个长度为 $N$ 的 $A$，问有多少个排列 $P$ 满足 $F(P) &#x3D; A$。</p>
<p>$1 \le N \le 2 \times 10 ^ 5$。</p>
<h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p>先看看操作是什么东西。看到排列，想到建图（？）。建一个有 $N$ 个点的有向图，$i$ 向 $P_i$ 连边。则这个图被分为若干个环。</p>
<p>初始时，每个点上有一个东西。题面中所说的操作，相当于找一个最小编号的点，使得它的编号小于它指向的点，把在它上的东西沿边移动。发现这个“最小编号”其实没什么用，每个东西最终停住的地方，就是它到达的第一个指向的点编号大于自己的点。它经过的点编号单调递减。</p>
<p>将给定的 $A$ 中值一样的位置拿出来，除最后一个点外，它们原本连的边一定指向下一个点。由于图是若干个环，每一种值的编号最大的点指向的一定为一个小于自己、且为某种值的编号最小的点。同时，编号最大的点必然为这个值。这样，原问题转化为有多少种将各种值的编号最小（黑）、最大（白）点两两连边的方式。</p>
<p>由于每个白点只能连向比自己小的点，考虑从小到大枚举白点，第 $i$ 个点有 $(比自己小的黑点数 - i + 1)$ 种选法。乘法原理算出来就是答案。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">200010</span>],use[<span class="number">200010</span>],pd[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> ans,res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a + i),v[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] != i &amp;&amp; v[i].<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!v[i].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j : v[i])</span><br><span class="line">			<span class="keyword">if</span> (j &gt; i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		pd[i] = <span class="number">1</span>;</span><br><span class="line">		use[v[i][<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (use[i]) ans ++;</span><br><span class="line">		<span class="keyword">if</span> (pd[i]) res = <span class="number">1ll</span> * res * ans % mod,ans --;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定一棵有 $N$ 个节点的树，编号为 $1$ 到 $N$。初始时，每一个点 $i$ 上有一个编号为 $i$ 的棋子。</p>
<p>你可以进行任意多次（包括 $0$ 次）如下操作：</p>
<ul>
<li>选择一条边，交换边的两端节点上的棋子，然后把这条边删掉。</li>
</ul>
<p>问最后树上的棋子有几种放法。</p>
<p>$2 \le N \le 3000$。</p>
<h2 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h2><p>发现子树内的棋子的方案数比较独立，只有子树的根和父亲交换可能影响到这棵子树。考虑树上 dp。</p>
<p>手动模拟一下，会发现一棵树最终的形态由操作的相对顺序（指祖先和儿子的关系（？））决定。因此，在 dp 的时候要记录操作数，便于算操作的相对顺序个数。</p>
<p>dp 的转移就是将两棵树的方案合并起来的过程。状态设为 $f[i][j]$，表示以 $i$ 为根的子树中发生了 $j$ 次交换操作的放法数。如果两棵树的根不交换，方案数就是直接乘起来；否则枚举这次交换操作要插进两个操作序列的哪里，再乘起来更新答案。将根为 $v$ （$v \in son_u$）的子树与根为 $u$ 的子树合并的转移式：</p>
<p>$$<br>f’[u][k] &#x3D; \sum \limits_{i + j &#x3D; k} f[u][i] \times f[v][j] + \sum \limits _{i + j &#x3D; k - 1} f[u][i] \times f[v][j] \times (i + 1) \times (j + 1)<br>$$</p>
<p>直接 dp，时间复杂度 $O(n ^ 2)$。</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定非负整数 $P$ 和 $B$，对于一个序列 $X$，定义 $\operatorname{hash}(X) &#x3D; ( \sum \limits_{ i &#x3D; 1 } ^{ |X| } {X_i B^{ |X| - i } } ) \mod p$。给出 $M$ 个区间 $[L_i,R_i]$，问是否可能构造序列 $A&#x3D;(A_1,A_2,\cdots,A_N)$，使得对于所有 $1 \le i \le M$，$\operatorname{hash}(A_{L_i},A_{L_i + 1},\cdots,A_{R_i}) \ne 0$。</p>
<p>$2 \le P \le 10^9$，$1 \le B &lt; P$，$1 \le N \le 16$，$1 \le M \le \frac{N(N + 1)}{2}$，区间互不相同。</p>
<h2 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h2><p>定义 $F(i)&#x3D;\operatorname{hash}(A_i,A_{i + 1},\cdots,A_{|X|})$，根据哈希函数定义可得 $\operatorname{hash}({A_x | x \in [L_i,R_i]}) &#x3D; \frac{F(L_i) - F(R_i + 1)}{B^{|X| - R_i}} \mod P$。由于 $B^{|X| - R_i} \ne 0$，要使这个值不为 $0$，则 $F(L_i) \ne F(R_i + 1)$。题目给的 $M$ 条限制，相当于在图上连了 $M$ 条边，边的两端填的数不一样。而 $0 \le F(i) &lt; P$，所以原题有解等价于这个图上没有 $(P + 1)$ 阶完全图。</p>
<p>发现 $N \le 16$，考虑用状压 dp 解决。定义 $f[i]$ 为二进制数 $i$ 代表的子图中最大的完全图有几个点，转移方程为</p>
<p>$$<br>f[i] &#x3D; \min \limits _{j \oplus k &#x3D; i} (f[j] + f[k])<br>$$</p>
<p>注意特判 $i$ 代表的子图中没有边的情况。时间复杂度 $O(2 ^ N N ^ 2)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> P,B,n,m;</span><br><span class="line"><span class="type">int</span> pd[<span class="number">20</span>][<span class="number">20</span>],f[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;P,&amp;B,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">if</span> (P &gt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">		y ++;</span><br><span class="line">		pd[x][y] = pd[y][x] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	n ++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; (<span class="number">1</span> &lt;&lt; n);i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">bool</span> fl = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!(i &gt;&gt; (j - <span class="number">1</span>) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>;k &lt;= n;k ++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (!(i &gt;&gt; (k - <span class="number">1</span>) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">				fl &amp;= (!pd[j][k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (fl)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		f[i] = n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = (i - <span class="number">1</span>) &amp; i;j;j = (j - <span class="number">1</span>) &amp; i)</span><br><span class="line">			f[i] = <span class="built_in">min</span>(f[i],f[j] + f[i ^ j]);</span><br><span class="line">		<span class="keyword">if</span> (f[i] &gt;= P + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给定一个 $N \times N$ 的网格，$(i,j)$ 表示第 $i$ 行第 $j$ 列的格子。现在需要在网格上摆放 $1$ 个黑色石头和 $M$ 个白色石头，且每行每列最多只有一个白色石头，黑色石头在 $(A,B)$ 上。接下来，要进行以下操作，直到不可进行为止：</p>
<ul>
<li>设黑色石头位于 $(i,j)$。若上下左右四个方向上有至少一个白色石头，选择其中一个，将黑色石头放到白色石头后面（白色石头所对方向）一格，并拿走这个白色石头。</li>
</ul>
<p>如果操作结束后，黑色石头重新位于 $(A,B)$，且白色石头全部被拿走，则操作成功。问有多少种白色石头的摆放方式，使得操作成功。</p>
<p>$2 \le M \le N \le 2 \times 10^5$。</p>
<h2 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h2><p>黑色石头走的路线和白色石头的摆放方式是一一对应的，证明略，可以手动模拟感性理解一下（）</p>
<p>由于黑色石头的路线是横一下竖一下的，总步数应为偶数。每一次黑色石头进入一行或者一列，相当于把两行或两列标记上不能再次进入，因为这两行或两列的白色石头被拿走了。考虑确定白色石头的位置，每个石头占领两行或两列，且互不相同。行和列可以分开考虑，再乘起来。</p>
<p>观察行的情况，总共 $K &#x3D; \lfloor \frac {M}{2} \rfloor$ 个石头占领两行，其中一定有一个石头，占领的两行包括第 $A$ 行。分两种情况考虑，一种是第 $A - 1$ 和 $A$ 行，一种是 $A$ 和 $A + 1$ 行。先确定占领第 $A$ 行的石头是哪个，再算剩下的占领哪些行，两种情况的方案数分别如下：</p>
<p>$$<br>\sum \limits _i i{ {A - 2 - i} \choose {i} } { {N - A - (K - i - 1)} \choose {K - i - 1} }<br>$$</p>
<p>$$<br>\sum \limits _i (K - i - 1){ {A - 1 - i} \choose i} { {N - A - 1 - (K - i - 1)} \choose {K - i - 1} }<br>$$</p>
<p>列的情况同理。最后再乘上行选择列的 $(M - 2)!$。时间复杂度线性。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>定义一个字符串 $T$ 是<strong>好的</strong>，当且仅当它满足下列条件：</p>
<ul>
<li>存在非空字符串 $A$ 和 $B$，使得 $A + B &#x3D; T$，且 $A + \operatorname{rev}(B)$ 和 $\operatorname{rev}(A) + B$ 均为回文串。</li>
</ul>
<p>$A + B$ 表示将 $A$ 和 $B$ 拼接得到的字符串，$\operatorname{rev}(A)$ 表示将 $A$ 首尾反转得到的字符串。</p>
<p>给定一个长为 $N$，由小写英文字母和 <code>?</code> 组成的字符串 $S$，问有多少种将 <code>?</code> 改成小写字母的方法，使得 $S$ 是<strong>好的</strong>字符串。</p>
<p>$2 \le N \le 5 \times 10^4$。</p>
<h2 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h2><p>（这里空着一段官方题解的说明，从最后一段的 <code>This part is also somewhat complex, but we will omit the details.</code> 开始 qwq）</p>
<p>官方题解讲得十分详细，但是实现没有讲。</p>
<p>题解中得到了一个结论，就是把 $S$ 划分成 $(A,B)$ 分为两种情况：</p>
<ol>
<li><p>$S &#x3D; T^n$，其中 $T$ 为 primitive root。此时有 $n - 1$ 种分法，把 $S$ 分为两个回文串。</p>
</li>
<li><p>$S$ 不为回文串，那么 $A$ 和 $B$ 形如一堆 $T$ 和 $T$ 的一半拼在一起。此时分法是唯一的。</p>
</li>
</ol>
<p>考虑怎么用这个结论和容斥求出原问题的解。</p>
<p>对于第一种情况，直接枚举 $T$ 的长度，把相对应位置并起来求方案数就行了。注意 $T$ 要求是 primitive root，要把不是的情况容斥掉，即去掉 $|T| \mod |T’| &#x3D; 0$ 的情况。</p>
<p>对于第二种情况，也是枚举 $T$ 的长度，同时枚举 $A$ 和 $B$ 的断点。把 $T$ 看成 $X + \operatorname{rev} (X)$，相当于 $X$ 正着接一个，反着接一个，但在断点左右都是正着的。可以先正着和反着预处理正反正反地接到当前节点的方案数，枚举断点的时候左右一拼就行了。</p>
<p>想一想这么做会多算哪些东西。一种是 $X$ 也为回文串的情况，需要减掉。另一种是 $X$ 不为回文串，但 $T$ 为回文串的情况，如 <code>abbaabbaabba</code>。此时，通过观察可以发现，在同一断点上， $T$ 比较长的情况包含了比较短的情况。所以，在实际处理中，只需要在同一断点上保留 $|T|$ 最大时算出来的答案就行了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[<span class="number">50010</span>],t[<span class="number">50010</span>];</span><br><span class="line"><span class="type">int</span> P[<span class="number">50010</span>];</span><br><span class="line"><span class="type">int</span> pre[<span class="number">50010</span>],suf[<span class="number">50010</span>];</span><br><span class="line">vector &lt;<span class="type">char</span>&gt; prestr[<span class="number">50010</span>],sufstr[<span class="number">50010</span>];</span><br><span class="line"><span class="type">int</span> tot,Ans[<span class="number">50010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// is a palindrome</span></span><br><span class="line">		<span class="type">bool</span> fl = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j ++) t[j] = s[j];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>;j &lt;= n / i;j ++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> l = (j - <span class="number">1</span>) * i + <span class="number">1</span>,r = j * i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = l;k &lt;= r;k ++)</span><br><span class="line">				<span class="keyword">if</span> (t[k - l + <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span> &amp;&amp; s[k] != <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">					t[k - l + <span class="number">1</span>] = s[k];</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (t[k - l + <span class="number">1</span>] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; s[k] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; t[k - l + <span class="number">1</span>] != s[k])</span><br><span class="line">					fl = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt; i - j + <span class="number">1</span>;j ++)</span><br><span class="line">			<span class="keyword">if</span> (t[j] != t[i - j + <span class="number">1</span>] &amp;&amp; t[j] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; t[i - j + <span class="number">1</span>] != <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">				fl = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (fl &amp;&amp; i &lt; n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i - j + <span class="number">1</span>;j ++)</span><br><span class="line">				<span class="keyword">if</span> (t[j] == <span class="string">&#x27;?&#x27;</span> &amp;&amp; t[i - j + <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) ans = <span class="number">26ll</span> * ans % mod;</span><br><span class="line">			P[i] = ans;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// is not a palindrome</span></span><br><span class="line">		<span class="keyword">if</span> (i * <span class="number">2</span> &gt; n || n / i % <span class="number">2</span> != <span class="number">0</span> || i == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> tmp = n / i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j ++) t[j] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">		pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= tmp;j ++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> l = (j - <span class="number">1</span>) * i + <span class="number">1</span>,r = j * i;</span><br><span class="line">			prestr[j].<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">if</span> ((j + <span class="number">1</span>) &amp; <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				pre[j] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (!pre[j - <span class="number">1</span>]) pre[j] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= i;k ++)</span><br><span class="line">					<span class="keyword">if</span> (t[k] == <span class="string">&#x27;?&#x27;</span> &amp;&amp; s[r - k + <span class="number">1</span>] != <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">						t[k] = s[r - k + <span class="number">1</span>];</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (t[k] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; s[r - k + <span class="number">1</span>] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; t[k] != s[r - k + <span class="number">1</span>])</span><br><span class="line">						pre[j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				pre[j] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (!pre[j - <span class="number">1</span>]) pre[j] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= i;k ++)</span><br><span class="line">					<span class="keyword">if</span> (t[k] == <span class="string">&#x27;?&#x27;</span> &amp;&amp; s[l + k - <span class="number">1</span>] != <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">						t[k] = s[l + k - <span class="number">1</span>];</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (t[k] != <span class="string">&#x27;?&#x27;</span>&amp;&amp; s[l + k - <span class="number">1</span>] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; t[k] != s[l + k - <span class="number">1</span>])</span><br><span class="line">						pre[j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= i;k ++) prestr[j].<span class="built_in">push_back</span>(t[k]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j ++) t[j] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">		suf[tmp + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = tmp;j &gt;= <span class="number">1</span>;j --)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> l = (j - <span class="number">1</span>) * i + <span class="number">1</span>,r = j * i;</span><br><span class="line">			sufstr[j].<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">if</span> ((tmp - j) &amp; <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				suf[j] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (!suf[j + <span class="number">1</span>]) suf[j] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= i;k ++)</span><br><span class="line">					<span class="keyword">if</span> (t[k] == <span class="string">&#x27;?&#x27;</span> &amp;&amp; s[r - k + <span class="number">1</span>] != <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">						t[k] = s[r - k + <span class="number">1</span>];</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (t[k] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; s[r - k + <span class="number">1</span>] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; t[k] != s[r - k + <span class="number">1</span>])</span><br><span class="line">						suf[j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				suf[j] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (!suf[j + <span class="number">1</span>]) suf[j] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= i;k ++)</span><br><span class="line">					<span class="keyword">if</span> (t[k] == <span class="string">&#x27;?&#x27;</span> &amp;&amp; s[l + k - <span class="number">1</span>] != <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">						t[k] = s[l + k - <span class="number">1</span>];</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (t[k] != <span class="string">&#x27;?&#x27;</span>&amp;&amp; s[l + k - <span class="number">1</span>] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; t[k] != s[l + k - <span class="number">1</span>])</span><br><span class="line">						suf[j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= i;k ++) sufstr[j].<span class="built_in">push_back</span>(t[k]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt; tmp;j += <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!pre[j] || !suf[j + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; i;k ++)</span><br><span class="line">				<span class="keyword">if</span> (prestr[j][k] == <span class="string">&#x27;?&#x27;</span> &amp;&amp; sufstr[j + <span class="number">1</span>][k] == <span class="string">&#x27;?&#x27;</span>) ans = <span class="number">26ll</span> * ans % mod,t[k + <span class="number">1</span>] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (prestr[j][k] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; sufstr[j + <span class="number">1</span>][k] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; prestr[j][k] != sufstr[j + <span class="number">1</span>][k])</span><br><span class="line">					ans = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (prestr[j][k] != <span class="string">&#x27;?&#x27;</span>) t[k + <span class="number">1</span>] = prestr[j][k];</span><br><span class="line">				<span class="keyword">else</span> t[k + <span class="number">1</span>] = sufstr[j + <span class="number">1</span>][k];</span><br><span class="line">			<span class="keyword">if</span> (ans)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= i - k + <span class="number">1</span>;k ++)</span><br><span class="line">					<span class="keyword">if</span> (t[k] == <span class="string">&#x27;?&#x27;</span> &amp;&amp; t[i - k + <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">						res = <span class="number">26ll</span> * res % mod;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (t[k] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; t[i - k + <span class="number">1</span>] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; t[k] != t[i - k + <span class="number">1</span>])</span><br><span class="line">						res = <span class="number">0</span>;</span><br><span class="line">				ans = (ans - res + mod) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">			Ans[j * i] = ans;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i ++)</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span> &amp;&amp; P[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt; i;j ++)</span><br><span class="line">				<span class="keyword">if</span> (i % j == <span class="number">0</span>) P[i] = (P[i] - P[j] + mod) % mod;</span><br><span class="line">			tot = (tot + P[i]) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) tot = (tot + Ans[i]) % mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-The End-</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>2025，你好！</title>
    <url>/2025/01/02/hello-2025/</url>
    <content><![CDATA[<p>2025 年来啦！决定随便写点东西（虽然今天已经 2 号了 awa）</p>
<p>作为一个即将退役的高二 OIer，2024 年可以说是 OI 生涯中的<del>经典年</del>最重要的一年了。我的收获不能说非常非常大，但是也不是很小。最重要的，大概是 7 月的那枚银牌。</p>
<p>快两年前，我在报送考的面试时说自己的目标大概是拿个国赛银牌。当时，我并没有什么一定要实现目标的决心，对于未来也没有什么理想，这个目标实际上是一个自我感觉不是没有可能，但也没什么壮志的目标。在真正比赛的两天，我在 Day1 考炸掉之后再宿舍的阳台边打电话边哭，才后知后觉地想到了自己对实现目标的淡淡决心。直到现在，我也还没有什么远大的目标，但是拿到牌那天的喜悦仍然时而浮现在脑海。在这种时候，我总是一下冒出来“不过是银牌，还不是能放下心来开心的时候”的念头，又想到自己当时相比于其他人并没有全身心地向着目标冲刺，只是在一如既往地正常学习、生活，有一种奇怪的感觉。不过国赛之后，我感觉自己似乎有一种燃尽的感觉（虽然并没有怎么燃），有点在逃避 OI。然后 NOIP 就很当然地炸了（</p>
<p>除了 OI，另一个从 23 年底开始的东西也占了我生活的一部分，那就是电吉他。虽然出去外面集训的时候并没有在练，在家里也一天练一天不练地，但相较于小学一周只弹那么两天已经很多了 &#x2F;xk。我从小学开始想学电吉他，直到高一终于下定决心开始自学，终于练会了几首一直想弹的歌，也在 24 年最后一天的迎新班会上弹了 Roselia 的《LOUDER》，有一种实现梦想的感觉。</p>
<p>说到学东西，我有一种啥都想学一学的冲动，甚至我某一天想到，小时候的我说不定不是想学编程，而只是想学新东西。2025 年，我也想接触学习各种新东西，也深入学习之前已经开始接触的东西。前面说，我还没有什么远大的目标，连自己真正喜欢什么、人生的方向都还没有找到。趁着高中，我也想通过接触各种东西，试着找找看。</p>
<p>总之，在还没有退役的这一段时间里，我也会认真地搞 OI，之后我也会认真地搞各种各样的东西。这个博客或许之后的一段时间都不会有 OI 相关文章了，但是其他的我尽量努力写！毕竟，2025 年才开了个头呢。</p>
<p>——但是我感冒了 qwq</p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>树上启发式合并（dsu on tree）学习笔记</title>
    <url>/2024/02/26/dsu-on-tree/</url>
    <content><![CDATA[<h1 id="树上启发式合并是什么？"><a href="#树上启发式合并是什么？" class="headerlink" title="树上启发式合并是什么？"></a>树上启发式合并是什么？</h1><p>树上启发式合并（dsu on tree）通过继承重儿子的信息，可以将某些合并更新答案次数为 $O(n^2)$ 的问题优化至 $O(n \log n)$。</p>
<h1 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h1><p>在普通 dfs 的基础上，继承重儿子传上来的信息。</p>
<p>先 dfs 轻儿子并把记录的信息清空，再 dfs 重儿子且不清空信息（继承）。随后暴力搜索轻子树内的节点更新信息。</p>
<p>这样做可以保证每次传上来的只有重儿子的信息，且算完当前子树的答案后，目前保留的信息只有这棵子树的。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfss</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfss</span>(u);<span class="comment">//递归处理轻儿子</span></span><br><span class="line">        <span class="built_in">clr</span>(u);<span class="comment">//清空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) <span class="built_in">dfss</span>(son[x]);</span><br><span class="line">    ...<span class="comment">//加入当前节点信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">upd</span>(u,x);<span class="comment">//更新答案</span></span><br><span class="line">        <span class="built_in">add</span>(u);<span class="comment">//更新信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>对每一个节点，如果它是父亲的轻儿子，它所在子树就会在 dfs 父亲时被暴力更新一次。也就是说，一个点被暴力更新的次数即为它到根经过的轻边数，是 $O(\log n)$ 的。所以总的更新次数是 $O(n \log n)$ 的。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>为了保证时间复杂度正确，继承重儿子信息这一步要保证更新次数为 $O(1)$的，所以一般存信息时，要存不会因为当前节点变化而变化很大的信息。</p>
<p>另外，清空信息的复杂度也要注意不要爆炸。一般直接 dfs 子树清空即可。</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/blog/entry/44351">这篇文章</a>的最后有一堆题目。</p>
<p><a href="https://codeforces.com/contest/1923/problem/E">CF1923E</a></p>
<p><a href="https://codeforces.com/problemset/problem/778/C">CF778C</a>，甚至不用传信息</p>
<p><a href="https://www.luogu.com.cn/problem/P5384">[Cnoi2019] 雪松果树</a>，虽然我写的 $O(n)$ 做法跑得比 $O(n \log n)$ 还慢。。。</p>
<p>p.s: 一个很像但是似乎不一样的东西：带撤销的完全背包的空间优化 <a href="https://www.luogu.com.cn/problem/P5391">[Cnoi2019] 青染之心</a>，通过将问题转化为类似树上的问题，重链剖分后同一条链用一个数组、深度相同的用同一个数组，把空间从 $O(nV)$ 优化到 $O(V\log n)$。这里是从上到下的信息传递。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>「知道了也没什么用的知识」-1</title>
    <url>/2025/06/13/mei-yong-de-xiao-zhi-shi-1/</url>
    <content><![CDATA[<p>试图开新坑 ing</p>
<p>记录一些上文化课的时候想到的问题 &#x2F; 平时见到的有趣小知识，希望能每周更新。</p>
<p>（这里面的大多数内容是我现查的，有错误的可能性，望指正）</p>
<hr>
<h1 id="问题-1：人的口水里面含有-DNA-吗？"><a href="#问题-1：人的口水里面含有-DNA-吗？" class="headerlink" title="问题 1：人的口水里面含有 DNA 吗？"></a>问题 1：人的口水里面含有 DNA 吗？</h1><details>
    <summary>答案</summary>
    <b>有。</b><br>
    初中的生物课上，有过用牙签在嘴巴里面刮一刮，再在生理盐水里面抹一抹，来制作口腔上皮细胞临时装片的实验。从这个实验也可以看出，口腔内的上皮细胞其实还挺容易脱落的。虽然纯净的唾液不含 DNA，但是口水中含有口腔内脱落的黏膜细胞、白细胞等，所以含有 DNA。在某些动画或者小说中，也有出现过把别人吸完的烟头拿去检测 DNA 之类的剧情。

</details>

<hr>
<h1 id="问题-2：“BTB溶液”指的是什么？"><a href="#问题-2：“BTB溶液”指的是什么？" class="headerlink" title="问题 2：“BTB溶液”指的是什么？"></a>问题 2：“BTB溶液”指的是什么？</h1><details>
    <summary>答案</summary>
    <b>溴麝香草酚蓝溶液（Bromothymol Blue）。</b><br>
    在高中生物必修一中，这个溶液名字由于比较难写让我印象深刻。在课本中，它出现在探究酵母菌呼吸方式的实验里，用来检测二氧化碳，现象是由蓝变绿再变黄。实际上，这种溶液是一种酸碱指示剂，变色范围在 6.0-7.6，遇酸变黄，遇碱变蓝。通入二氧化碳变蓝，是因为二氧化碳溶于水生成碳酸。而由于变色范围挺大，且碳酸酸性没那么强，所以有一个逐渐变化的过程。
</details>

<hr>
<h1 id="问题-3：手机的定时开机功能是怎么实现的？"><a href="#问题-3：手机的定时开机功能是怎么实现的？" class="headerlink" title="问题 3：手机的定时开机功能是怎么实现的？"></a>问题 3：手机的定时开机功能是怎么实现的？</h1><details>
    <summary>答案</summary>
    网上有很多详细的答案，但是有一些太专业的我也看不懂……总的来说，应该是<b>虽然手机关机了，但某些基础功能仍在运行，如时钟模块。</b>这样就自然可以做到定时开机。
</details>

<hr>
<h1 id="问题-4：“五行诗（Cinquain）”是写五行就行了吗？"><a href="#问题-4：“五行诗（Cinquain）”是写五行就行了吗？" class="headerlink" title="问题 4：“五行诗（Cinquain）”是写五行就行了吗？"></a>问题 4：“五行诗（Cinquain）”是写五行就行了吗？</h1><p><del>这什么问题，都这么问了肯定不对啊（</del></p>
<p>换一个，以下这一首诗是否符合五行诗的格式要求？</p>
<blockquote>
<p>parents<br>strict harsh<br>wash push teath<br>my most trusted people<br>love</p>
</blockquote>
<details>
    <summary>答案</summary>
    <b>不符合。</b>
    <s>这什么这什么问题，都这么问了肯定不对啊（</s><br>
    在英语课上，老师布置了让同学们回家自创五行诗的作业，并给出了一大堆示例。然而，那一大堆示例实际上都不符合五行诗的格式要求。<br>
    五行诗的格式要求为：第一行一个主题名词，第二行两个形容词描述主题，第三行三个 v-ing 描述主题，第四行四个单词描述主题，第五行一个单词进一步阐释主题，其中四五行没有词性要求。<br>
    题外话：明明课上整整两页 PPT 的错误示范，同学们交上去的作业也全是错误示范（虽然只有三个人交了），为什么网上的全是对的……上面这个是好不容易找到的比较难判断的错的（
</details>

<hr>
<p>这周就这么多，希望下周还能再见ヾ(￣▽￣)Bye<del>Bye</del></p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>圆方树 学习笔记</title>
    <url>/2023/10/25/round-square-tree/</url>
    <content><![CDATA[<blockquote>
<p>前置知识：<br>点双联通分量，Tarjan 算法</p>
</blockquote>
<h1 id="圆方树是什么"><a href="#圆方树是什么" class="headerlink" title="圆方树是什么"></a>圆方树是什么</h1><p>（在下面的所有内容中，认为两个点由一条边连接也双联通）</p>
<p>一个无向图可以建出一棵树，树上有圆点和方点，圆点对应原图中的点，方点对应点双联通分量，方点在树中连上在这个双联通分量中的圆点。每个方点周围会连一圈圆点，每个圆点会连一圈方点。</p>
<h1 id="怎么建树"><a href="#怎么建树" class="headerlink" title="怎么建树"></a>怎么建树</h1><p>可以用 Tarjan 建圆方树。</p>
<p>在 Tarjan 算法中，对于每个点 $x$，我们都记录了它的 dfs 序 $dfn_x$ 和经过最多一条返祖边（对于 dfs 树来说）能到达的最小 dfs 序 $low_x$。</p>
<p>用 Tarjan 求割点的时候，判断一个点 $x$ 是不是割点的条件是是否存在一个儿子 $u$，使得 $low_u \geq dfn_x$，即是否存在一个儿子不经过 $x$ 就不能往上走。</p>
<p>如果一个点 $x$ 的儿子 $u$ 满足 $low_u&#x3D;dfn_x$，代表 $u$ 只经过一条返祖边最高只能走到 $x$，这就有了一个点双联通分量。把栈里从栈顶一直到 $u$ 的元素出栈，和一个新的方点连边，同时把 $x$ 也连向这个方点（不出栈）就好了。</p>
<p>OI-wiki 的代码比较好看。</p>
<p>下面是我的代码 qwq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tar</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++ dfncnt;</span><br><span class="line">    p[x] = <span class="number">1</span>;</span><br><span class="line">    st.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tar</span>(u);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x],low[u]);</span><br><span class="line">            <span class="keyword">if</span> (low[u] == dfn[x])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt2 ++;</span><br><span class="line">                <span class="type">int</span> nw;</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nw = st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    p[nw] = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">Add</span>(cnt2 + n,nw),<span class="built_in">Add</span>(nw,cnt2 + n);</span><br><span class="line">                &#125; <span class="keyword">while</span> (nw != u);</span><br><span class="line">                <span class="built_in">Add</span>(x,cnt2 + n),<span class="built_in">Add</span>(cnt2 + n,x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[u]) low[x] = <span class="built_in">min</span>(low[x],dfn[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="圆方树的一些性质"><a href="#圆方树的一些性质" class="headerlink" title="圆方树的一些性质"></a>圆方树的一些性质</h1><p>两个点之间所有简单路径上的点的点集，就是圆方树上两个点的路径上所有方点代表的点集的并集。</p>
<p>（待补）</p>
<p>题目：</p>
<p><a href="https://www.luogu.com.cn/problem/P4630">[APIO2018] 铁人两项</a></p>
<p>技巧：给圆方树的每个点赋予适当的权值。</p>
<p><a href="https://www.luogu.com.cn/problem/P4606">[SDOI2018] 战略游戏</a></p>
<p>结合虚树</p>
<p>（待补）</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>一些后缀数组（SA）的题目</title>
    <url>/2024/04/19/sa-problems/</url>
    <content><![CDATA[<p><del>不知道 SA 是什么？<a href="https://rabbiew.github.io/2022/08/06/SA/">SA 的基础知识</a></del></p>
<p>以下所有题目都可以用 SAM 解决，这里记录 SA 做法。</p>
<h1 id="SPOJ-LCS2-Longest-Common-Substring-II"><a href="#SPOJ-LCS2-Longest-Common-Substring-II" class="headerlink" title="SPOJ LCS2 - Longest Common Substring II"></a>SPOJ LCS2 - Longest Common Substring II</h1><p>题目链接：<a href="https://www.spoj.com/problems/LCS2/">https://www.spoj.com/problems/LCS2/</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定不超过 $10$ 个长度不超过 $10^5$ 的字符串，求它们的最长公共子串长度。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>子串就是某个后缀的前缀。把所有字符串中间加上分隔符连成一个求 SA，最长公共子串的长度就是从原先的每个字符串挑一个后缀出来求 LCP，也就是 $height$ 数组的区间求 $\min$。</p>
<p>考虑排名数组上的每一个区间，这个区间满足条件，当且仅当原先的每个字符串都有一个后缀在这里面。把原先的字符串当成颜色，对应后缀染色，区间满足条件即为这里面每种颜色都出现了。可以滑动窗口求所有满足条件的区间，单调队列维护区间 $\min$。时间复杂度 $O(n\log n)$。</p>
<p>在实现的时候，字符串连在一起时加上分隔符可以规避一些奇怪的特殊情况。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code by RabbieWjy</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">1000010</span>],S[<span class="number">1000100</span>];</span><br><span class="line"><span class="type">int</span> n,K;</span><br><span class="line"><span class="type">int</span> rk[<span class="number">2001000</span>],ork[<span class="number">2001000</span>],sa[<span class="number">2001000</span>],cnt[<span class="number">2001000</span>],rn[<span class="number">2001000</span>],num[<span class="number">2001000</span>];</span><br><span class="line"><span class="type">int</span> hei[<span class="number">1000100</span>];</span><br><span class="line"><span class="type">int</span> col[<span class="number">1000100</span>],Cnt[<span class="number">20</span>],ans;</span><br><span class="line">deque &lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> m = <span class="built_in">max</span>(n,<span class="number">300</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) rk[i] = S[i],cnt[rk[i]] ++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rk[i]] --] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>;len &lt; n;len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> no = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = n - len + <span class="number">1</span>;i &lt;= n;i ++) num[++ no] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">			<span class="keyword">if</span> (sa[i] &gt; len) num[++ no] = sa[i] - len;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) rn[i] = rk[num[i]],cnt[rn[i]] ++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rn[i]] --] = num[i];</span><br><span class="line">		no = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) ork[i] = rk[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">			<span class="keyword">if</span> (ork[sa[i]] == ork[sa[i - <span class="number">1</span>]] &amp;&amp; ork[sa[i] + len] == ork[sa[i - <span class="number">1</span>] + len])</span><br><span class="line">				rk[sa[i]] = no;</span><br><span class="line">			<span class="keyword">else</span> rk[sa[i]] = ++ no;</span><br><span class="line">		<span class="keyword">if</span> (no == n) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp = <span class="built_in">max</span>(hei[rk[i - <span class="number">1</span>]] - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span> (i + tmp &lt;= n &amp;&amp; sa[rk[i] - <span class="number">1</span>] + tmp &lt;= n &amp;&amp; S[i + tmp] == S[sa[rk[i] - <span class="number">1</span>] + tmp]) tmp ++;</span><br><span class="line">		hei[rk[i]] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s + <span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> m = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">		K ++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) S[n + i] = s[i],col[n + i] = K;</span><br><span class="line">		S[n + m + <span class="number">1</span>] = K; <span class="comment">// 分隔符</span></span><br><span class="line">		n += m + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (K == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">SA</span>();</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>,j = <span class="number">1</span>,ncnt = <span class="number">0</span>;</span><br><span class="line">	Cnt[col[sa[<span class="number">1</span>]]] ++;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt;= j &amp;&amp; ncnt == K &amp;&amp; (!col[sa[i]] || Cnt[col[sa[i]]] &gt; <span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			Cnt[col[sa[i]]] --;</span><br><span class="line">			<span class="keyword">if</span> (q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">front</span>() == i + <span class="number">1</span>) q.<span class="built_in">pop_front</span>();</span><br><span class="line">			i ++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ncnt == K) ans = <span class="built_in">max</span>(ans,hei[q.<span class="built_in">front</span>()]);</span><br><span class="line">		Cnt[col[sa[j + <span class="number">1</span>]]] ++;</span><br><span class="line">		<span class="keyword">if</span> (col[sa[j + <span class="number">1</span>]] &amp;&amp; Cnt[col[sa[j + <span class="number">1</span>]]] == <span class="number">1</span>) ncnt ++;</span><br><span class="line">		<span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; hei[q.<span class="built_in">back</span>()] &gt;= hei[j + <span class="number">1</span>]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">		q.<span class="built_in">push_back</span>(j + <span class="number">1</span>);</span><br><span class="line">		j ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Luogu-P2408-不同子串个数"><a href="#Luogu-P2408-不同子串个数" class="headerlink" title="Luogu P2408 不同子串个数"></a>Luogu P2408 不同子串个数</h1><p>题目链接：<a href="https://www.luogu.com.cn/problem/P2408">https://www.luogu.com.cn/problem/P2408</a></p>
<h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给你一个长为 $n$ 的字符串，求本质不同的子串的个数。</p>
<p>$1 \le n \le 10^5$。</p>
<h2 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h2><p>先求出 SA 和 $height$ 数组。总共的 $\frac{n(n + 1)}{2}$ 个子串中，对于每个后缀，它和前一名的 LCP 都是多算了的，要减去，也就是总共减去 $\sum \limits _{i&#x3D;2} ^n height[i]$。</p>
<p>也许可以直接记结论？</p>
<p>代码简单，就不放了。</p>
<h1 id="NOI2018-你的名字"><a href="#NOI2018-你的名字" class="headerlink" title="[NOI2018] 你的名字"></a>[NOI2018] 你的名字</h1><p>题目链接：<a href="https://www.luogu.com.cn/problem/P4770">https://www.luogu.com.cn/problem/P4770</a> &#x2F; <a href="https://loj.ac/p/2720">https://loj.ac/p/2720</a></p>
<h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定字符串 $S$，$Q$ 次询问，每次询问给出字符串 $T$ 和区间 $[L,R]$，求有多少个 $T$ 的本质不同子串不是 $S_LS_{L + 1}\cdots S_R$ 的子串。</p>
<p>$|S| \le 5 \times 10^5$，$Q \le 10^5$，$\sum |T| \le 10^6$。</p>
<h2 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h2><p>符号：$S(L,R)$ 表示字符串 $S_LS_{L+1}\cdots S_R$，字符串 $T$ 的后缀 $i$ 表示字符串 $T_iT_{i + 1}\cdots T_{|T|}$。</p>
<p>和上面一道题类似，考虑从所有子串中减去算多的。</p>
<p>先把所有字符串加上分隔符连起来。所有本质不同子串个数就是上一题，现在需要把这些子串中是 $S(L,R)$ 的子串的减掉。</p>
<p>对于每个字符串 $T$ 的后缀 $i$，存在一个最长的前缀，使得它是 $S(L,R)$ 的子串，且比这个前缀长的前缀都不是 $S(L,R)$ 的子串。记这个前缀长度为 $len_i$，则有 $len_{i + 1} \ge \max(0,len_i - 1)$。证明类似 $height$ 数组的结论证明，具体来说就是 $T(i + 1,i + len_i - 1)$ 就是 $T(i,i + len_i - 1)$ 去掉第一个字符，显然也是 $S(L,R)$ 的子串。</p>
<p>根据这个结论，我们可以类似求 $height$ 数组的过程求出 $len$ 数组。但是，这里面需要快速判断 $T(i,i + X - 1)$ 是不是 $S(L,R)$ 的子串。这个判断相当于判断是否存在 $j \in [L,R - X + 1]$，使得 $\operatorname{LCP}(S(j,j + X - 1),T(i,i + X - 1)) &#x3D; X$，也就是 $\operatorname{LCP}(S(j,|S|),T(i,|T|) \ge X$。对于一个固定的 $i$，$S(j,|S|)$ 的排名在一个包含 $rank[T(i,|T|)]$ 且区间 $height_{\min} \ge X$ 的区间里，可以二分+ST 表找出这个区间。判断就转化为了区间中是否存在 $j\in [L,R - X + 1]$ 的问题，可以通过主席树解决。</p>
<p>求出来 $len$ 以后，就可以把答案算出来了。注意减掉是 $S(L,R)$ 的子串个数的时候，有一些已经在求本质不同子串的时候减掉了的子串要加回来。</p>
<p>总时间复杂度是 $O(n\log n)$，$n&#x3D;|S| + \sum |T|$。我的代码常数较大。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code by RabbieWjy</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,N,q;</span><br><span class="line"><span class="type">char</span> s[<span class="number">2000010</span>],t[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> col[<span class="number">2000010</span>],L[<span class="number">100010</span>],R[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> rk[<span class="number">4000010</span>],cnt[<span class="number">4000010</span>],sa[<span class="number">4000010</span>],rn[<span class="number">4000010</span>],num[<span class="number">4000010</span>],ork[<span class="number">4000010</span>];</span><br><span class="line"><span class="type">int</span> hei[<span class="number">2000010</span>];</span><br><span class="line"><span class="type">int</span> st[<span class="number">30</span>][<span class="number">2000010</span>];</span><br><span class="line"><span class="type">int</span> ed[<span class="number">100010</span>],res[<span class="number">2000010</span>];</span><br><span class="line">ll ans[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ls,rs,sum;</span><br><span class="line">&#125; tree[<span class="number">500010</span> * <span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> rt[<span class="number">2000010</span>],tcnt;</span><br><span class="line"><span class="type">int</span> del[<span class="number">2000010</span>],las[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> m = <span class="built_in">max</span>(n,<span class="number">300</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) rk[i] = s[i],cnt[rk[i]] ++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rk[i]] --] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>;len &lt; n;len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> no = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = n - len + <span class="number">1</span>;i &lt;= n;i ++) num[++ no] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">			<span class="keyword">if</span> (sa[i] &gt; len) num[++ no] = sa[i] - len;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) rn[i] = rk[num[i]],cnt[rn[i]] ++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rn[i]] --] = num[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) ork[i] = rk[i];</span><br><span class="line">		no = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">			<span class="keyword">if</span> (ork[sa[i]] == ork[sa[i - <span class="number">1</span>]] &amp;&amp; ork[sa[i] + len] == ork[sa[i - <span class="number">1</span>] + len])</span><br><span class="line">				rk[sa[i]] = no;</span><br><span class="line">			<span class="keyword">else</span> rk[sa[i]] = ++ no;</span><br><span class="line">		<span class="keyword">if</span> (no == n) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp = <span class="built_in">max</span>(<span class="number">0</span>,hei[rk[i - <span class="number">1</span>]] - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span> (i + tmp &lt;= n &amp;&amp; sa[rk[i] - <span class="number">1</span>] + tmp &lt;= n &amp;&amp; s[i + tmp] == s[sa[rk[i] - <span class="number">1</span>] + tmp])</span><br><span class="line">			tmp ++;</span><br><span class="line">		hei[rk[i]] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ST</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) st[<span class="number">0</span>][i] = hei[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i ++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n;j ++)</span><br><span class="line">			st[i][j] = <span class="built_in">min</span>(st[i - <span class="number">1</span>][j],st[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmin</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!l || !r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="built_in">swap</span>(l,r);</span><br><span class="line">	l ++;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">2e9</span>;</span><br><span class="line">	<span class="type">int</span> L = <span class="built_in">log2</span>(r - l + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(st[L][l],st[L][r - (<span class="number">1</span> &lt;&lt; L) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> qx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (qx &lt; l || qx &gt; r) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="type">int</span> nw = ++ tcnt;</span><br><span class="line">	tree[nw] = tree[x];</span><br><span class="line">	tree[nw].sum ++;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> nw;</span><br><span class="line">	<span class="keyword">if</span> (qx &lt;= mid) tree[nw].ls = <span class="built_in">upd</span>(tree[nw].ls,l,mid,qx);</span><br><span class="line">	<span class="keyword">else</span> tree[nw].rs = <span class="built_in">upd</span>(tree[nw].rs,mid + <span class="number">1</span>,r,qx);</span><br><span class="line">	<span class="keyword">return</span> nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> tree[y].sum - tree[x].sum;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ql &lt;= mid) res = <span class="built_in">query</span>(tree[x].ls,tree[y].ls,l,mid,ql,qr);</span><br><span class="line">	<span class="keyword">if</span> (mid &lt; qr) res += <span class="built_in">query</span>(tree[x].rs,tree[y].rs,mid + <span class="number">1</span>,r,ql,qr);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fnd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> len,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">1</span>,r = rk[x],resl = <span class="number">0</span>,resr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">qmin</span>(mid,rk[x]) &gt;= len) resl = mid,r = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	l = rk[x],r = n;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">qmin</span>(rk[x],mid) &gt;= len) resr = mid,l = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">query</span>(rt[resl - <span class="number">1</span>],rt[resr],<span class="number">1</span>,N,ql,qr)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">	n = <span class="built_in">strlen</span>(s + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	s[n] = <span class="number">1</span>;</span><br><span class="line">	N = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= q;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,L + i,R + i);</span><br><span class="line">		<span class="type">int</span> m = <span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++) s[n + j] = t[j],col[n + j] = i;</span><br><span class="line">		n += m + <span class="number">1</span>;</span><br><span class="line">		ed[i] = n - <span class="number">1</span>;</span><br><span class="line">		s[n] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">SA</span>();</span><br><span class="line">	<span class="built_in">ST</span>();</span><br><span class="line">	rt[<span class="number">0</span>] = ++ tcnt;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) rt[i] = <span class="built_in">upd</span>(rt[i - <span class="number">1</span>],<span class="number">1</span>,N,sa[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">		<span class="keyword">if</span> (col[sa[i]])</span><br><span class="line">		&#123;</span><br><span class="line">			del[sa[i]] = <span class="built_in">min</span>(ed[col[sa[i]]] - sa[i] + <span class="number">1</span>,<span class="built_in">min</span>(ed[col[sa[i]]] - sa[las[col[sa[i]]]] + <span class="number">1</span>,<span class="built_in">qmin</span>(i,las[col[sa[i]]])));</span><br><span class="line">			ans[col[sa[i]]] += ed[col[sa[i]]] - sa[i] + <span class="number">1</span> - del[sa[i]];</span><br><span class="line">			las[col[sa[i]]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!col[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> tmp = <span class="built_in">max</span>(<span class="number">0</span>,res[i - <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span> (i + tmp &lt;= ed[col[i]] &amp;&amp; tmp &lt;= R[col[i]] - L[col[i]] &amp;&amp; <span class="built_in">fnd</span>(i,tmp + <span class="number">1</span>,L[col[i]],R[col[i]] - tmp)) tmp ++;</span><br><span class="line">		res[i] = tmp;</span><br><span class="line">		ans[col[i]] -= <span class="built_in">max</span>(<span class="number">0</span>,tmp - del[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= q;i ++) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="美团杯2020-半前缀计数"><a href="#美团杯2020-半前缀计数" class="headerlink" title="[美团杯2020] 半前缀计数"></a>[美团杯2020] 半前缀计数</h1><p>题目链接：<a href="https://uoj.ac/problem/523">https://uoj.ac/problem/523</a></p>
<h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>定义一个字符串的半前缀为一个前缀（可以为空）删去它的一个子串（可以为空）的结果。求字符串 $S$ 有多少个本质不同的半前缀。</p>
<p>$1 \le |S| \le 10^6$。</p>
<h2 id="做法-3"><a href="#做法-3" class="headerlink" title="做法"></a>做法</h2><p>半前缀的定义相当于一个前缀加上后面的某个子串。对于每一种半前缀，存在一个最大的 $i$，使得它由 $S(1,i)$ 加上后面的某个子串构成，且无法被 $S(1,j)$（$j &gt; i$）和后面的某个子串构成。考虑对于每一个前缀 $S(1,i)$，计算它作为最大满足上述条件的 $i$ 的半前缀数量。</p>
<p>把后面加的子串记为 $T$。由于 $i$ 是最大的，$T_1 \ne S_{i + 1}$，否则可以选 $S(1,i + 1)$ 和 $T$ 去掉第一个字符拼起来。发现如果 $T_1 \ne S_{i + 1}$，则 $i$ 一定是最大的。因此只需要计算 $T_1 \ne S_{i + 1}$ 的本质不同串数量。</p>
<p>求出 $S$ 的 SA，由于 $T$ 要是 $S(1,i)$ 后面的某个子串，考虑从后往前求答案。可以用上两道题的结论，求出 $S(i + 1,|S|)$ 的本质不同子串数和分别以每个字母开头的本质不同子串数，然后直接求答案。中间需要维护后缀 $i + 1$ 到 $|S|$ 的按排名排序后两两相邻的 $\operatorname{LCP}$，可以用数据结构（如树状数组）快速求出当前新加入排名的前驱和后继，加上 ST 表更新答案。总时间复杂度 $O(n\log n)$，$n &#x3D; |S|$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code by RabbieWjy</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> rk[<span class="number">1000010</span>],cnt[<span class="number">1000010</span>],sa[<span class="number">1000010</span>],num[<span class="number">1000010</span>],rn[<span class="number">1000010</span>],ork[<span class="number">2000010</span>];</span><br><span class="line"><span class="type">int</span> hei[<span class="number">1000010</span>];</span><br><span class="line">ll nsum,sum[<span class="number">30</span>],ans;</span><br><span class="line"><span class="type">int</span> st[<span class="number">30</span>][<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> m = <span class="built_in">max</span>(n,<span class="number">150</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) rk[i] = s[i],cnt[rk[i]] ++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rk[i]] --] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>;len &lt; n;len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> no = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = n - len + <span class="number">1</span>;i &lt;= n;i ++) num[++ no] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">			<span class="keyword">if</span> (sa[i] &gt; len) num[++ no] = sa[i] - len;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) rn[i] = rk[num[i]],cnt[rn[i]] ++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) sa[cnt[rn[i]] --] = num[i];</span><br><span class="line">		no = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) ork[i] = rk[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">			<span class="keyword">if</span> (ork[sa[i]] == ork[sa[i - <span class="number">1</span>]] &amp;&amp; ork[sa[i] + len] == ork[sa[i - <span class="number">1</span>] + len])</span><br><span class="line">				rk[sa[i]] = no;</span><br><span class="line">			<span class="keyword">else</span> rk[sa[i]] = ++ no;</span><br><span class="line">		<span class="keyword">if</span> (no == n) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp = <span class="built_in">max</span>(<span class="number">0</span>,hei[rk[i - <span class="number">1</span>]] - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span> (i + tmp &lt;= n &amp;&amp; sa[rk[i] - <span class="number">1</span>] + tmp &lt;= n &amp;&amp; s[i + tmp] == s[sa[rk[i] - <span class="number">1</span>] + tmp])</span><br><span class="line">			tmp ++;</span><br><span class="line">		hei[rk[i]] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tree[<span class="number">2</span>][<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ini</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) tree[<span class="number">1</span>][i] = n + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = x;i &lt;= n;i += <span class="built_in">lowbit</span>(i)) tree[<span class="number">0</span>][i] = <span class="built_in">max</span>(tree[<span class="number">0</span>][i],x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = x;i;i -= <span class="built_in">lowbit</span>(i)) tree[<span class="number">1</span>][i] = <span class="built_in">min</span>(tree[<span class="number">1</span>][i],x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> opt,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> res = (opt ? n + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (opt)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = x;i &lt;= n;i += <span class="built_in">lowbit</span>(i)) res = <span class="built_in">min</span>(res,tree[<span class="number">1</span>][i]);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = x;i;i -= <span class="built_in">lowbit</span>(i)) res = <span class="built_in">max</span>(res,tree[<span class="number">0</span>][i]);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; T[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ST</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) st[<span class="number">0</span>][i] = hei[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20</span>;i ++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n;j ++)</span><br><span class="line">			st[i][j] = <span class="built_in">min</span>(st[i - <span class="number">1</span>][j],st[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmin</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!l || r == n + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	l ++;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ERROR\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> L = <span class="built_in">log2</span>(r - l + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(st[L][l],st[L][r - (<span class="number">1</span> &lt;&lt; L) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s + <span class="number">1</span>);</span><br><span class="line">	n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">SA</span>();</span><br><span class="line">	<span class="built_in">ST</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">26</span>;i ++) T[i].<span class="built_in">ini</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">0</span>;i --)</span><br><span class="line">	&#123;</span><br><span class="line">		ans += nsum - sum[s[i + <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		<span class="keyword">if</span> (!i) <span class="keyword">break</span>;</span><br><span class="line">		nsum += n - i + <span class="number">1</span>;</span><br><span class="line">		sum[s[i] - <span class="string">&#x27;a&#x27;</span>] += n - i + <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> pre = T[<span class="number">0</span>].<span class="built_in">query</span>(<span class="number">0</span>,rk[i]),nxt = T[<span class="number">0</span>].<span class="built_in">query</span>(<span class="number">1</span>,rk[i]);</span><br><span class="line">		nsum += <span class="built_in">qmin</span>(pre,nxt);</span><br><span class="line">		nsum -= <span class="built_in">qmin</span>(pre,rk[i]) + <span class="built_in">qmin</span>(rk[i],nxt);</span><br><span class="line">		pre = T[s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>].<span class="built_in">query</span>(<span class="number">0</span>,rk[i]),nxt = T[s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>].<span class="built_in">query</span>(<span class="number">1</span>,rk[i]);</span><br><span class="line">		sum[s[i] - <span class="string">&#x27;a&#x27;</span>] += <span class="built_in">qmin</span>(pre,nxt);</span><br><span class="line">		sum[s[i] - <span class="string">&#x27;a&#x27;</span>] -= <span class="built_in">qmin</span>(pre,rk[i]) + <span class="built_in">qmin</span>(rk[i],nxt);</span><br><span class="line">		T[<span class="number">0</span>].<span class="built_in">upd</span>(rk[i]),T[s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>].<span class="built_in">upd</span>(rk[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans + n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新中……</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>后缀数组（SA）</tag>
      </tags>
  </entry>
  <entry>
    <title>点分治 &amp; 点分树</title>
    <url>/2023/05/01/%E7%82%B9%E5%88%86%E6%B2%BB%E5%92%8C%E7%82%B9%E5%88%86%E6%A0%91/</url>
    <content><![CDATA[<h1 id="点分治（树分治）"><a href="#点分治（树分治）" class="headerlink" title="点分治（树分治）"></a>点分治（树分治）</h1><h2 id="点分治是什么？"><a href="#点分治是什么？" class="headerlink" title="点分治是什么？"></a>点分治是什么？</h2><p>字面上理解，点分治就是“点”和“分治”。它的思路是把一个无根树树上问题拆分成若干个规模更小的无根树上问题和一个有根树（？）上问题。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P3806">【模板】点分治1 - 洛谷</a></p>
<p>给定一棵有 $n$ 个节点的树，$m$ 次询问树上距离为 $k$ 的点对是否存在。</p>
<p>$1 \le n \le 10^4$，$1 \leq m \le 100$，$1 \le k \le 10^7$，边权 $1 \le w \le 10^4$。</p>
<h3 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h3><p>每次询问，考虑对于每一个点，用树形 dp 求出经过这个点（包括以这个点为端点）的路径中是否有长度为 $k$ 的，这个判断可以处理出深度后用双指针实现。时间复杂度 $O(mn^2\log n)$，显然过不去。换根 dp 也因为 $k$ 太大，做不了。</p>
<h3 id="点分治做法"><a href="#点分治做法" class="headerlink" title="点分治做法"></a>点分治做法</h3><p>考虑优化这个暴力，发现对于每个点都做一次树形 dp 很浪费时间。</p>
<p>看一下一棵树上的路径有哪些？</p>
<p>我们可以简单把树上的所有路径分为两类：<strong>经过根节点的</strong> 和 <strong>不经过根节点的</strong>。而暴力做法中，就是把每个点都当成一次根节点，在经过根节点的路径中找长度为 $k$ 的。</p>
<p>一个显然的发现是，不经过根节点的路径肯定在根节点的一个子树中。把根节点删掉，剩下的几个子树就成为了几个规模更小的同样的问题，可以分治解决。时间复杂度为 $O(mn\log n\times 层数)$。</p>
<p>这个“层数“看起来很难受，如果随便取每次分治的根节点（也就是 <strong>分治中心</strong>）的话，层数可以达到 $O(n)$ 级别，那就优化了个寂寞。我们要想办法把层数减少。</p>
<p>可以想到，每次 <strong>分出来的几个子问题的规模最大的要尽量小</strong>，才能使得时间减少。这让我们想到了<strong>重心</strong>。</p>
<p>树的重心有一条性质，叫做 <strong>以树的重心为根时，所有子树的大小都不超过整棵树大小的一半</strong>。这条性质使得分治的层数变成了 $O(\log n)$ 级别，总的时间复杂度变成了 $O(mn\log^2 n)$，足以通过这道题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，我们已经了解了这道题中的点分治做法，可以归纳成下面几步：</p>
<ol>
<li><p>找重心，作为根；</p>
</li>
<li><p>树形 dp+ 双指针求解每个询问；</p>
</li>
<li><p>递归求解每个子树。</p>
</li>
</ol>
<p>而点分治的大多数问题，只是把第 $2$ 步改一改，总体思路都是一样的。</p>
<h3 id="例题代码（点分治主体部分）"><a href="#例题代码（点分治主体部分）" class="headerlink" title="例题代码（点分治主体部分）"></a>例题代码（点分治主体部分）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fndroot</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> la)</span><span class="comment">//找根</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    maxsiz[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == la || vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">fndroot</span>(u,x);</span><br><span class="line">        siz[x] += siz[u];</span><br><span class="line">        maxsiz[x] = <span class="built_in">max</span>(maxsiz[x],siz[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxsiz[x] = <span class="built_in">max</span>(maxsiz[x],nsiz - siz[x]);</span><br><span class="line">    <span class="keyword">if</span> (maxsiz[x] &lt; maxsiz[root]) root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">caldis</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> la,<span class="type">int</span> topx)</span><span class="comment">//树形 dp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == la || vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dis[u] = dis[x] + val[i];</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dis[u],topx));</span><br><span class="line">        <span class="built_in">caldis</span>(u,x,topx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//双指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v.<span class="built_in">clear</span>();</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,x));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dis[u] = val[i];</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dis[u],u));</span><br><span class="line">        <span class="built_in">caldis</span>(u,x,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[l].first + v[r].first &lt; que[i]) l ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v[l].first + v[r].first &gt; que[i]) r --;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[l].second == v[r].second)</span><br><span class="line">                &#123;    </span><br><span class="line">                    <span class="keyword">if</span> (v[r].first == v[r - <span class="number">1</span>].first) r --;</span><br><span class="line">                    <span class="keyword">else</span> l ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans[i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//点分治主体</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cal</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x];i;i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        nsiz = siz[u];</span><br><span class="line">        root = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fndroot</span>(u,x);</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="另：关于找重心"><a href="#另：关于找重心" class="headerlink" title="另：关于找重心"></a>另：关于找重心</h3><p><a href="https://liu-cheng-ao.blog.uoj.ac/blog/2969">一种基于错误的寻找重心方法的点分治的复杂度分析 - 博客 - liu_cheng_ao的博客</a></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h2><p><a href="https://www.luogu.com.cn/problem/P4178">Tree - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2634">[国家集训队]聪聪可可 - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P4149">[IOI2011]Race - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2664">树上游戏 - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3714">[BJOI2017]树的难题 - 洛谷</a></p>
<h1 id="点分树（动态点分治）"><a href="#点分树（动态点分治）" class="headerlink" title="点分树（动态点分治）"></a>点分树（动态点分治）</h1><p>在点分治中，我们依次作为分治中心的点根据访问顺序可以形成一棵树（就像 dfs 树那样），这棵树成为点分树。</p>
<p>这颗树的节点与原树的节点相同，且深度为 $O(\log n)$，所以许多点分树上的暴力做法的时间复杂度都是正确的。</p>
<p>点分树有一个常用性质：点分树上两点的 LCA 一定在这两点在原树上的路径上。</p>
<p>还有一个注意点：点分树上两点的关系（父子关系之类的）与原树上这两点的关系 <strong>并没有什么关系</strong>。</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P6329">【模板】点分树 | 震波 - 洛谷</a></p>
<p>题面见链接。</p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>想一想与点 $x$ 距离为 $k$ 的点有哪些。（以下都是在点分树上）</p>
<p>这些点可能在 $x$ 的子树里，可能在 $x$ 的父亲的子树里但不在 $x$ 的子树里，可能在 $x$ 的父亲的父亲的子树里但不在 $x$ 的父亲的子树里……</p>
<p>于是我们想到，可以用一个（$n$ 个？）数据结构存下每个点的子树的节点信息，比如距离 $x$ 为 $k$ 的点的价值和，询问的时候一层一层往父亲跳，同时更新答案就可以了。正好层数那么少，数据结构用动态开点线段树或者什么别的就行了。</p>
<p>但是还有一个问题：跳到 $x$ 的父亲之后，怎么找 $x$ 的子树以外的距离 $x$ 为 $k$ 的点呢？</p>
<p>显然，直接减掉 $x$ 的子树内的就好了。具体的说，用 $dis(x,y)$ 表示点 $x$ 和 $y$ 的距离，要找的点的权值和就是 $\sum \limits _{u \in fa(x) 的子树 \operatorname{and} dis(x,u)&#x3D;k} val(u) - \sum \limits _{u \in x 的子树 \operatorname{and} dis(x,u)&#x3D;k} val(u)$。</p>
<p>根据上面提到的性质，这个式子可以变为：$\sum \limits _{u \in fa(x) 的子树 \operatorname{and} dis(fa(x),u)&#x3D;k-dis(x,fa(x))} val(u)-\sum \limits _{u \in x 的子树 \operatorname{and} dis(fa(x),u)&#x3D;k-dis(x,fa(x))}val(u)$。</p>
<p>左半部分可以继续用数据结构求出，而右半部分则需要多维护一个叫 $dis(fa(x),u)$ 的东西。根据上面的注意点，$dis(fa(x),u) \neq dis(x,u)+dis(x,fa(x))$，所以我们必须多用一个数据结构维护这个东西。</p>
<p>至于修改操作，直接一层一层往上跳修改就好了。</p>
<p>时间复杂度为 $O(n\log^2 n+m\log^2 n)$。</p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p><a href="https://www.luogu.com.cn/problem/P3241">[HNOI2015]开店 - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2056">[ZJOI2007] 捉迷藏 - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/SP2666">QTREE4 - Query on a tree IV - 洛谷</a>  <a href="https://www.luogu.com.cn/problem/P4115">Qtree4 - 洛谷</a>（卡常题）</p>
<p><a href="https://www.luogu.com.cn/problem/P3345">[ZJOI2015]幻想乡战略游戏 - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P4565">[CTSC2018]暴力写挂 - 洛谷</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树 &amp; 线段树合并优化 DP</title>
    <url>/2023/05/19/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96DP/</url>
    <content><![CDATA[<h1 id="线段树优化-DP"><a href="#线段树优化-DP" class="headerlink" title="线段树优化 DP"></a>线段树优化 DP</h1><p>有一些 DP 的初始化和转移操作可以转化为序列上 &#x2F; 值域上的区间操作 &#x2F; 区间查询问题，可以用线段树加速这些操作。</p>
<h2 id="例题-1-NOIP1999-普及组-导弹拦截-洛谷"><a href="#例题-1-NOIP1999-普及组-导弹拦截-洛谷" class="headerlink" title="例题 1. [NOIP1999 普及组] 导弹拦截 - 洛谷"></a>例题 1. <a href="https://www.luogu.com.cn/problem/P1020">[NOIP1999 普及组] 导弹拦截 - 洛谷</a></h2><p>求序列的最长不上升 &#x2F; 最长上升子序列，$1 \le n \le 10^5$，$1 \le a_i \le 5\times10^4$。</p>
<hr>
<p>以最长不上升子序列为例。</p>
<p>朴素转移方程：$f_i &#x3D; \max \limits_{j&#x3D;0} ^{i - 1} (f_j+1)[a_j \ge a_i \lor j&#x3D;0 ]$，$f_i$ 表示以 $a_i$ 结尾的最长子序列，从 $f_0$ 转移表示作为开头。这个 DP 时间复杂度为 $\mathcal{O} (n^2)$。</p>
<p>考虑优化。枚举到 $k$ 时，如果有 $i,j \le k$，$a_i &#x3D; a_j$ 且 $f_i &lt; f_j$，那么 $f_i$ 显然没用。由于值域很小，可以用 $g_i$ 记录 $\max \limits_{a_j&#x3D;i} f_j$，转移方程变为 $f_i &#x3D; \max \limits_{j&#x3D;a_i}^{V} {g_j}$，在计算 $f_i$ 的同时更新 $g_{a_i}$ 即可，时间复杂度 $\mathcal{O}(nV)$。</p>
<p>发现转移时，相当于在 $[0,V]$ 中求了一次后缀最大值，可以用数据结构维护区间最大值，更新 $g_{a_i}$ 的操作转化为单点修改，可以用线段树或其他数据结构维护，时间复杂度 $\mathcal{O}(n\log V)$，可以通过。</p>
<h2 id="例题-2-Problem-1334F-Codeforces"><a href="#例题-2-Problem-1334F-Codeforces" class="headerlink" title="例题 2. Problem - 1334F - Codeforces"></a>例题 2. <a href="https://codeforces.com/problemset/problem/1334/F">Problem - 1334F - Codeforces</a></h2><p>翻译：<a href="https://www.luogu.com.cn/problem/CF1334F">Strange Function - 洛谷</a></p>
<p>定义函数 $f$：$f(x)$ 为所有满足 $x_i&gt;x_{1,2,\cdots,i-1}$ 的 $x_i$ 组成的序列，例如 $f[3,1,2,7,7,3,6,7,8]&#x3D;[3,7,8]$。</p>
<p>给出两个序列 $a,b$，你可以删掉 $a$ 中的一些元素。删掉 $a_i$ 的代价为 $p_i$。你需要求出最小代价使得 $f(a)&#x3D;b$ 或给出无解。</p>
<p>$1 \le |a| \le 5\times 10^5$，$b_{i-1} &lt; b_i$。</p>
<hr>
<p>设计状态 $f_{i,j}$ 表示现在考虑到第 $i$ 个序列 $a$ 中的元素，考虑完元素 $i$ 后新序列的目前最大值（有可能不在目前的新序列中）为 $b_j$，目前代价最小为 $f_{i,j}$。</p>
<p>设 $b_{k} \le a_i &lt; b_{k+1}$。</p>
<p>先假设 $b_j$ 已经 &#x2F; 将来一定会取到。</p>
<p>$p_i&gt;0$ 时，若 $b_{j} \le a_i$ 即 $j \le k$，为了不改变目前最大值，$a_i$ 必须删除，$f_{i,j} \leftarrow f_{i-1,j}+p_i$；否则，$a_i$ 删不删都可以，$f_{i,j} \leftarrow f_{i-1,j}$。</p>
<p>$p_i &lt; 0$ 时，$a_i$ 删除更优，$f_{i,j} \leftarrow f_{i-1,j}+p_i$。</p>
<p>为了保证最后 $b_j$ 可以取到，当 $a_i&#x3D;b_j$ 时，$a_i$ 不能删除，$f_{i,j} &#x3D; \min \limits_{v&#x3D;0} ^j f_{i-1,v} &#x3D; \min \limits_{v&#x3D;0} ^{j} {f_{i,v} - p_i}$（减 $p_i$ 是因为 $v \le j$，在上面加上了 $p_i$，要把 $p_i$ 减回来）。</p>
<p>最终答案即为 $f_{|a|,|b|}$。</p>
<p>发现上面的几个式子可以转化为区间加、区间查询和单点修改，可以用线段树维护。时间复杂度 $\mathcal{O}(|a|\log |b|)$。</p>
<p>DP 的主要代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,a + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,p + i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,b + i),pl[b[i]] = i;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>,b + m + <span class="number">1</span>,a[i]) - b;</span><br><span class="line">        <span class="keyword">if</span> (p[i] &gt; <span class="number">0</span>) <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">0</span>,x - <span class="number">1</span>,p[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">0</span>,m,p[i]);</span><br><span class="line">        <span class="keyword">if</span> (pl[a[i]]) <span class="built_in">upd</span>(<span class="number">1</span>,pl[a[i]],<span class="built_in">query</span>(<span class="number">1</span>,pl[a[i]] - <span class="number">1</span>) - p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// add 为区间加，query 为区间查询，upd 为单点修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">query</span>(<span class="number">1</span>,m) &lt; <span class="number">1e15</span>) <span class="built_in">printf</span>(<span class="string">&quot;YES\n%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,m));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题-3-某位歌姬的故事-洛谷-Ex-Max-Limited-Sequence"><a href="#例题-3-某位歌姬的故事-洛谷-Ex-Max-Limited-Sequence" class="headerlink" title="例题 3. 某位歌姬的故事 - 洛谷 &#x2F; Ex - Max Limited Sequence"></a>例题 3. <a href="https://www.luogu.com.cn/problem/P4229">某位歌姬的故事 - 洛谷</a> &#x2F; <a href="https://atcoder.jp/contests/abc262/tasks/abc262_h">Ex - Max Limited Sequence</a></h2><p><del>其中前一道题实际上可以不用线段树优化 DP。</del></p>
<p>构造一个长度为 $n$ 的整数序列 $a$，要求 $1\le a_i \le A$，还有 $Q$ 条形如 $\max {a_{l_i},a_{l_i+1},\cdots,a_{r_i}}&#x3D;m_i$ 的限制，问有多少种构造方法。</p>
<p>要求时间复杂度为 $\mathcal{O}(Q\log Q)$，空间线性。</p>
<hr>
<p>先求出每个位置上的数最大可以填多少，设为 $b$，顺便判断是否有解：限制 $i$ 可能被满足当且仅当 $\max \limits_{j&#x3D;l_i} ^{r_i} b_j &#x3D; m_i$。</p>
<p>类似<a href="https://www.luogu.com.cn/problem/P3813">[FJOI2017]矩阵填数 - 洛谷</a>这道题，$b_i$ 不同的两个位置的填法互不相关，可以依次求 $b_i&#x3D;x$ 的所有位置的填法，再乘起来。</p>
<p>把位置、限制按 $b$ 分类，分别存起来，所有 $b_i&#x3D;x$ 的位置把整个序列分成若干个左闭右开的区间。现在求 $b_i&#x3D;x$ 的位置的填法数。注意 DP 时一个点不仅代表这一个点填什么，还代表了一个左闭右开的区间，设 $i$ 代表的区间长度为 $len_i$。</p>
<p>设计状态 $f_{i,j}$ 表示现在填到第 $i$ 个位置，上一个填 $x$ 的位置为 $j$，填法有 $f_{i,j}$ 种。</p>
<p><strong>一个观察：右端点在 $i$ 代表的区间中的所有限制，只要满足了左端点最靠右的一个，剩下的所有都满足了</strong>。因此只需要考虑左端点最靠右的一个询问，设这个左端点为 $y$。则 $y$ 到 $i$ 中至少要有一个填 $x$。</p>
<p>如果 $i$ 不填 $x$，则 $y$ 到 $i-1$ 中至少有一个 $x$，所以 $\forall j: 0 \le j &lt; y,\ f_{i,j}\leftarrow 0$，$\forall j : y \le j &lt; i, \ f_{i,j} \leftarrow f_{i-1,j} \times (x-1)^{len_i}$。</p>
<p>如果填了 $x$，则 $f_{i,i}\leftarrow \sum \limits_{j&#x3D;0} ^{i-1} f_{i-1,j} \times [x^{len_i} - (x-1)^{len_i}]$。</p>
<p>这里，位置编号是从 $1$ 开始的，$f_{i,0}$ 表示一个 $x$ 都没有。</p>
<p>答案即为 $\sum \limits_{i&#x3D;0} ^{last} {f_{last,i} }$。</p>
<p>考虑优化，发现上面的转移可以转化为区间推平、区间乘、区间查询和单点修改，可以用线段树维护。</p>
<p>在实现时，区间查询的结果也可以用另外一个数组记录，看起来好看一点。</p>
<p>我的代码写得非常丑，好看的正解代码可以在洛谷 &#x2F; AT 上找 qwq</p>
<p>AT 那道题和这题是一样的，只是没有多测。</p>
<h2 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h2><p><a href="https://www.luogu.com.cn/problem/P2605">https://www.luogu.com.cn/problem/P2605</a></p>
<p>待补充</p>
<h1 id="线段树合并优化-DP"><a href="#线段树合并优化-DP" class="headerlink" title="线段树合并优化 DP"></a>线段树合并优化 DP</h1><p>在一些树上 DP 的题目中，需要把父亲和儿子的 DP 信息合并起来，而合并的过程可以转化为线段树合并操作。</p>
<h2 id="例题-1-PKUWC2018-Minimax-洛谷"><a href="#例题-1-PKUWC2018-Minimax-洛谷" class="headerlink" title="例题 1. [PKUWC2018] Minimax - 洛谷"></a>例题 1. <a href="https://www.luogu.com.cn/problem/P5298">[PKUWC2018] Minimax - 洛谷</a></h2><p>小 $C$ 有一棵 $n$ 个结点的有根树，根是 $1$ 号结点，且每个结点最多有两个子结点。</p>
<p>定义结点 $x$ 的权值为：</p>
<p>1.若 $x$ 没有子结点，那么它的权值会在输入里给出，<strong>保证这类点中每个结点的权值互不相同</strong>。</p>
<p>2.若 $x$ 有子结点，那么它的权值有 $p_x$ 的概率是它的子结点的权值的最大值，有 $1-p_x$ 的概率是它的子结点的权值的最小值。</p>
<p>现在小 $C$ 想知道，假设 $1$ 号结点的权值有 $m$ 种可能性，<strong>权值第 $i$ 小</strong>的可能性的权值是 $V_i$，它的概率为 $D_i(D_i&gt;0)$，求：</p>
<p>$$<br>\sum_{i&#x3D;1}^{m}i\cdot V_i\cdot D_i^2<br>$$</p>
<p>你需要输出答案对 $998244353$ 取模的值。</p>
<hr>
<p>一眼树形 DP。设计状态 $f_{x,i}$ 表示节点 $x$ 取到权值 $i$ 的概率。</p>
<p>若 $x$ 为叶子节点，则 $f_{x,i} \leftarrow [val_x &#x3D; i] val_x$；</p>
<p>若 $x$ 只有一个儿子，则 $f_{x,i} \leftarrow f_{son_x,i}$；</p>
<p>否则，设 $x$ 的两个儿子为 $lson$ 和 $rson$。</p>
<p>$$<br>f_{x,i} \leftarrow p_x\sum \limits_{j&#x3D;1} ^{i-1} { f_{lson,j} f_{rson,i} } + (1-p_x)\sum \limits_{j&#x3D;i+1} ^{V} f_{lson,j}f_{rson,i} +p_x\sum \limits_{j&#x3D;1}^{i-1} {f_{lson,i}f_{rson,j} }+(1-p_x)\sum\limits_{j&#x3D;i+1}^V { {f_{lson,i}f_{rson,j} }+{f_{lson,i}f_{rson,i} } }<br>$$</p>
<p>要怎么把线段树合并和这个东西结合起来呢？</p>
<p>$x$ 为叶子节点就是单点修改，只有一个儿子就是 <code>rt[x] = rt[sonx]</code>，主要问题是两个儿子的情况。</p>
<p>想一下线段树合并的过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y; <span class="comment">// 其中一个为空就直接返回</span></span><br><span class="line">    <span class="comment">// tree[x] &lt;- tree[y]</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> x; <span class="comment">// 没法往下分就返回</span></span><br><span class="line">    tree[x].ls = <span class="built_in">merge</span>(tree[x].ls,tree[y].ls,l,mid);</span><br><span class="line">    tree[x].rs = <span class="built_in">merge</span>(tree[x].rs,tree[y].rs,mid + <span class="number">1</span>,r); <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设现在 $f$ 数组已经成功地存在了两棵线段树里，要把 $f_{rson}$ 合并到 $f_{lson}$ 上作为 $f_x$。</p>
<p>现在合并到了区间 $[l,r]$。如果 $f_{rson}$ 在 $[l,r]$ 没有值，即 $y$ 为空，那么对于所有 $i \in [l,r]$，和它的值有关的 $f_{rson}$ 中的值都在这个区间外面，与 $i$ 本身无关，只与 $[l,r]$ 有关。具体来说，上面转移方程中，第一项、第二项和最后一项都是 $0$，第三项变为 $p_x\sum \limits_{j&#x3D;1} ^{l-1} { f_{lson,i}f_{rson,j} }$，第四项变为 $(1-p_x)\sum \limits_{j&#x3D;r+1}^V { f_{lson,i}f_{rson,j} }$。发现实际上就是给 $[l,r]$ 中的每个位置乘上 $p_x \sum \limits_{j&#x3D;1}^{l-1} {f_{rson,j} }+(1-p_x)\sum \limits_{j&#x3D;r+1}^V f_{rson,j}$，变成了区间乘。$x$ 为空时同理，因为 $x$ 和 $y$ 的关系是对等的。发现要维护一些前缀和和后缀和，在下分时顺便更新之后传下去就行了。</p>
<p>如果 $l&#x3D;r$，直接根据转移方程暴力合并就行了。在这道题中，由于点的权值互不相同，所以不会有这种情况。</p>
<p>否则往下继续分就行了。注意下分前先下传 tag，合并完儿子之后再 pushup。</p>
<p>合并的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> xsum,<span class="type">int</span> ysum,<span class="type">int</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x &amp;&amp; !y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="built_in">swap</span>(x,y),<span class="built_in">swap</span>(xsum,ysum);</span><br><span class="line">        tree[x].sum = <span class="number">1ll</span> * tree[x].sum * xsum % mod;</span><br><span class="line">        tree[x].tg = <span class="number">1ll</span> * tree[x].tg * xsum % mod;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x),<span class="built_in">pushdown</span>(y);</span><br><span class="line">    <span class="type">int</span> tmpx = tree[tree[x].ls].sum,tmpy = tree[tree[y].ls].sum;</span><br><span class="line">    tree[x].ls = <span class="built_in">merge</span>(tree[x].ls,tree[y].ls,l,mid,(xsum + <span class="number">1ll</span> * tree[tree[y].rs].sum * (<span class="number">1</span> - P + mod) % mod) % mod,(ysum + <span class="number">1ll</span> * tree[tree[x].rs].sum * (<span class="number">1</span> - P + mod) % mod) % mod,P);</span><br><span class="line">    tree[x].rs = <span class="built_in">merge</span>(tree[x].rs,tree[y].rs,mid + <span class="number">1</span>,r,(xsum + <span class="number">1ll</span> * tmpy * P % mod) % mod,(ysum + <span class="number">1ll</span> * tmpx * P % mod) % mod,P);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的都是动态开点线段树板子。</p>
<p>最后查询的时候，就是在根节点的线段树上单点查找。</p>
<h2 id="例题-2-NOI2020-命运-洛谷"><a href="#例题-2-NOI2020-命运-洛谷" class="headerlink" title="例题 2. [NOI2020] 命运 - 洛谷"></a>例题 2. <a href="https://www.luogu.com.cn/problem/P6773">[NOI2020] 命运 - 洛谷</a></h2><p>给定一棵树 $T &#x3D; (V, E)$ 和点对集合 $\mathcal Q \subseteq V \times V$ ，满足对于所有 $(u, v) \in \mathcal Q$，都有 $u \neq v$，并且 $u$ 是 $v$ 在树 $T$ 上的祖先。其中 $V$ 和 $E$ 分别代表树 $T$ 的结点集和边集。求有多少个不同的函数 $f$ : $E \to {0, 1}$（将每条边 $e \in E$ 的 $f(e)$ 值置为 $0$ 或 $1$），满足对于任何 $(u, v) \in \mathcal Q$，都存在 $u$ 到 $v$ 路径上的一条边 $e$ 使得 $f(e) &#x3D; 1$。由于答案可能非常大，你只需要输出结果对 $998,244,353$（一个素数）取模的结果。</p>
<p>$1 \le n \le 5 \times 10 ^5$，$1 \le m \le 5 \times 10^5$。</p>
<hr>
<p>这道题和前面讲的 某位歌姬的故事 这道题很像，这道题就是把那道题的部分分做法搬到了树上。</p>
<p>这道题也有<strong>一个观察：对于下端点相同的限制，上端点最深的满足，则这些限制都满足</strong>。</p>
<p>设计状态 $f_{i,j}$ 表示在节点 $i$ 的子树中，还未被满足的限制中上端点最深的深度为 $j$，方案数为 $f_{i,j}$。根节点深度为 $1$。</p>
<p>转移方程：</p>
<p>$$<br>f_{x,i} \leftarrow \sum \limits_{j&#x3D;0} ^{i - 1} { f_{x,i}f_{son,j} }+\sum\limits_{j&#x3D;0} ^{i-1} { f_{x,j}f_{son,i} }+{ f_{x,i}f_{xon,i} }+f_{x,i}\sum \limits_{j&#x3D;0}^{dep_x} {f_{son,j} }<br>$$</p>
<p>前面三项是 $edge(x,son)&#x3D;0$，最后一项是填 $1$。</p>
<p>类似上一道题，这题也可以用线段树合并优化转移。但要注意，这道题里 $x$ 和 $son$ 的关系并不对等，要分别讨论左边为空和右边为空的情况。</p>
<p>合并代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pre,<span class="type">int</span> sonpre,<span class="type">int</span> sondep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    printf(&quot;%d %d %d %d %d %d %d\n&quot;,x,y,l,r,pre,sonpre,sondep);</span></span><br><span class="line">    <span class="keyword">if</span> (!x &amp;&amp; !y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">        tree[x].sum = <span class="number">1ll</span> * tree[x].sum * pre % mod;</span><br><span class="line"><span class="comment">//        printf(&quot;sum %d\n&quot;,tree[x].sum);</span></span><br><span class="line">        tree[x].tg = <span class="number">1ll</span> * tree[x].tg * pre % mod;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!y)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[x].sum = <span class="number">1ll</span> * tree[x].sum * (sondep + sonpre) % mod;</span><br><span class="line">        tree[x].tg = <span class="number">1ll</span> * tree[x].tg * (sondep + sonpre) % mod;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (l == r)</span><br><span class="line">     &#123;</span><br><span class="line">        tree[x].sum = (<span class="number">1ll</span> * tree[x].sum * ((sondep + sonpre) % mod + tree[y].sum) % mod + <span class="number">1ll</span> * tree[y].sum * pre % mod) % mod;</span><br><span class="line"><span class="comment">//        printf(&quot;sum %d\n&quot;,tree[x].sum);</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x),<span class="built_in">pushdown</span>(y);</span><br><span class="line">    <span class="type">int</span> newpre = (pre + tree[tree[x].ls].sum) % mod;</span><br><span class="line">    <span class="type">int</span> newsonpre = (sonpre + tree[tree[y].ls].sum) % mod;</span><br><span class="line">    tree[x].ls = <span class="built_in">merge</span>(tree[x].ls,tree[y].ls,l,mid,pre,sonpre,sondep);</span><br><span class="line">    tree[x].rs = <span class="built_in">merge</span>(tree[x].rs,tree[y].rs,mid + <span class="number">1</span>,r,newpre,newsonpre,sondep);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>遇到整个区间转移的问题，可以往线段树优化上考虑。（？）</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>DP</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
